

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://tva1.sinaimg.cn/large/008qL1EEly1gymvh3hte4j30680680t3.jpg">
  <link rel="icon" href="https://tva1.sinaimg.cn/large/008qL1EEly1gymvh3hte4j30680680t3.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="写在前面正如CMU 15-445的主讲教授所说，这门课并不会教你如何使用数据库去构建应用程序或网站，也不是教你如何去部署和管理数据库的课，这门课的核心课程是有关数据库管理系统的设计与实现。 PROJECT #0 - C++ PRIMER这个热身实验只是让我们把项目文件下载到本地，配置好相关的git，检验一下自己的C++能力，因此对其简要说明。 在这个项目中，您将实现三个类模板：Matrix、Row">
<meta property="og:type" content="article">
<meta property="og:title" content="CMU_15-445_PROJECT#0&amp;1">
<meta property="og:url" content="https://xiao-nanbei.github.io/2022/02/03/CMU-15-445-PROJECT-0-1/index.html">
<meta property="og:site_name" content="databrains">
<meta property="og:description" content="写在前面正如CMU 15-445的主讲教授所说，这门课并不会教你如何使用数据库去构建应用程序或网站，也不是教你如何去部署和管理数据库的课，这门课的核心课程是有关数据库管理系统的设计与实现。 PROJECT #0 - C++ PRIMER这个热身实验只是让我们把项目文件下载到本地，配置好相关的git，检验一下自己的C++能力，因此对其简要说明。 在这个项目中，您将实现三个类模板：Matrix、Row">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008qL1EEly1gzci8busaxj30go05stai.jpg">
<meta property="og:image" content="http://tva1.sinaimg.cn/large/007SD2TBly1h2ym36wge4j30e706cwek.jpg">
<meta property="og:image" content="http://tva1.sinaimg.cn/large/007SD2TBly1h2yn3l8d12j30pb0abgm1.jpg">
<meta property="og:image" content="http://tva1.sinaimg.cn/large/007SD2TBly1h2yory14cqj30t70bfq4d.jpg">
<meta property="article:published_time" content="2022-02-03T14:22:29.000Z">
<meta property="article:modified_time" content="2022-06-07T02:33:53.656Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="CMU_15-455">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/008qL1EEly1gzci8busaxj30go05stai.jpg">
  
  
  <title>CMU_15-445_PROJECT#0&amp;1 - databrains</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="https://at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"xiao-nanbei.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>databrains</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://tva1.sinaimg.cn/large/008qL1EEly1gymvk0ibtcj31hc0u04qp.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="CMU_15-445_PROJECT#0&amp;1">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-02-03 22:22" pubdate>
        2022年2月3日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      16k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      133 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">CMU_15-445_PROJECT#0&amp;1</h1>
            
            <div class="markdown-body">
              <h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>正如CMU 15-445的主讲教授所说，这门课并不会教你如何使用数据库去构建应用程序或网站，也不是教你如何去部署和管理数据库的课，这门课的核心课程是有关数据库管理系统的设计与实现。</p>
<h3 id="PROJECT-0-C-PRIMER"><a href="#PROJECT-0-C-PRIMER" class="headerlink" title="PROJECT #0 - C++ PRIMER"></a>PROJECT #0 - C++ PRIMER</h3><p>这个热身实验只是让我们把项目文件下载到本地，配置好相关的git，检验一下自己的C++能力，因此对其简要说明。</p>
<p>在这个项目中，您将实现三个类模板：<code>Matrix</code>、<code>RowMatrix</code>和<code>RowMatrixOperations</code>。这些矩阵是简单的二维矩阵，必须支持加法、矩阵乘法和简化的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/General_matrix_multiply">通用矩阵乘法</a>(GEMM) 运算（我们只要修改一个文件：p0_starter.h）。</p>
<p>这个就不多说了。</p>
<h3 id="PROJECT-1-BUFFER-POOL"><a href="#PROJECT-1-BUFFER-POOL" class="headerlink" title="PROJECT #1 - BUFFER POOL"></a>PROJECT #1 - BUFFER POOL</h3><hr>
<p>以前我从来没思考过buffer和cache的区别，为什么叫buffer pool而不叫cache pool，在做这个实验时，突然想到这个问题了，现记录如下（与实验无太大关系）：</p>
<ol>
<li>buffer与cache操作的对象不一样<ul>
<li>buffer（缓冲）是为了提高内存和硬盘之间的数据交互的速度而设计的。</li>
<li>cache（缓存）是为了提高CPU和内存之间的数据交互速度设计的，也就是平常见到的一级缓存、二级缓存等。</li>
<li>CPU在执行程序所用的指令和读取数据都是针对内存的，也就是从内存中取得的。由于内存读写速度慢，为了提高cpu和内存之间数据交换的速度，在cpu和内存之间增加了cache，它的速度比内存快。</li>
<li>缓冲是根据磁盘的读写设计的，把分散的写操作集中进行，减少磁盘碎片和磁盘的反复寻道，从而提高系统性能。</li>
</ul>
</li>
<li>或者可以这样说，buffer是系统两端处理速度平衡时使用的，而cache是系统两端不匹配时的一种折衷策略。我们在组原中学习过TLB（translation lookaside buffer），这玩意名字虽然叫buffer，但其实是一种cache。</li>
</ol>
<p>所以说，这里之所以叫buffer，那是因为它直接和磁盘进行数据交互。</p>
<p>在Free命令中显示的buffer和cache，它们都是占用内存：</p>
<ul>
<li><p>buffer : 作为buffer cache的内存，是块设备的读写缓冲区，更靠近存储设备，或者直接就是disk的缓冲区。</p>
</li>
<li><p>cache: 是内存的缓冲区 。</p>
</li>
</ul>
<p>补充，linux中buffer cache和page cache的概念和二者的区别：</p>
<p>Page cache在linux读写文件时，它用于缓存文件的逻辑内容，从而加快对磁盘上映像和数据的访问。具体说是加速对文件内容的访问，buffer cache缓存文件的具体内容——物理磁盘上的磁盘块，这是加速对磁盘的访问。</p>
<p>简单说来，page cache用来缓存文件数据，buffer cache用来缓存磁盘数据。在有文件系统的情况下，对文件操作，那么数据会缓存到page cache，如果直接采用dd等工具对磁盘进行读写，那么数据会缓存到buffer cache。</p>
<p>由于我对文件系统所知甚少，后面再继续补充。</p>
<hr>
<p>在传统的数据库管理系统中，数据的存储介质是磁盘，文件是以page的形式存储在磁盘上的。对于结构化数据来说，一条记录会被保存在磁盘上的某个数据块中。在对某条记录进行处理时，可以通过代表该记录地址的page_id从磁盘上获取该记录，随后系统会把存储有该条记录的数据块从磁盘读到缓冲区，缓冲区分为多个frame，每个frame可以保存一个磁盘块，再从缓冲区将该条记录读到线程或事务的工作区进行处理，处理结束后将更新的记录写回缓冲区中的数据块，再由数据库管理系统将修改过的数据块写回到磁盘上。</p>
<p>在buffer pool中，有一个又一个的chunk块，我们称之为frame，我们可以将page放置在其中，一个frame对应一个page，这就是很简单的一对一拷贝，page可以以它们想要的任何顺序放置在frame中，如下图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/008qL1EEly1gzci8busaxj30go05stai.jpg" srcset="/img/loading.gif" lazyload alt=""></p>
<p>在此之上，我们需要一个额外的indirection层，如果我想要某个特定的page，通过这个indirection层我就知道它在哪个frame中——也就是pagetable，pagetable就是一个hash表，它用来跟踪内存中有哪些page，如果我们想找一个特定的page，通过page表和page id，我们就可以知道这个page在哪个frame中。数据库系统必须维护一些额外的元数据，以此来跟踪当前buffer池中发生了什么。下面是对这些元数据的详解：</p>
<p>dirty_page——这个数据告诉我们当我们从磁盘中读取到这个page后，这个page是否被修改过。</p>
<p>pin_count——引用计数，它用来跟踪想要使用该page的当前线程数量或者是正在查询该page的数量，这意味着我们并不想该page写出到磁盘上，因为我可能回去对它进行更新。从该page被放入内存到我对它进行更新这段时间内，我不想让该page被移除或者是交换回磁盘，这也将阻止我们去移除那些还未被安全写回磁盘的page。这也是我们后面的Pin函数想要表达的意思。</p>
<p>基本上来说，就是管理我们自己的内存，但我们也要去跟踪事务或查询是如何修改page的，在我们想做任何事之前，我们必须保护pagetable免受其他人污染或者是被其他人覆盖里面的东西。因此我们会用到Latches，下面是Locks和Latches的区别。</p>
<hr>
<blockquote>
<p>在数据库的世界中，lock是某种更高级的逻辑原语，它会去保护数据库中的逻辑内容，例如，tuple、表、以及数据库，事物会在运行的时候去持有这个lock，这就意味着可以有多个查询，数据库系统可以为我们提供这些东西，它能将这些暴露给我们这些开发人员。</p>
<p>Latch是一种底层保护原语，我们使用它来保护数据库系统内部的关键部分，比如，保护数据结构和保护内存区域，我们在执行操作的期间内，会持有这些Latch,用来保护某些东西，比如说，如果我去更新我的pagetable，我会在我要去修改的地方加上一个latch，修改完后，我会将它释放。</p>
</blockquote>
<p>后面教授就讲得很绕了，甚至spin mutex都讲出来了，我先去查查资料，后面填坑。</p>
<hr>
<p>另一个我们需要去区分的就是page目录和pagetable，二者之间的区别我在MIT6.S081 labs的博客里面也说过，我们还是来听听Andy教授怎么说：</p>
<blockquote>
<p>page目录的作用是用来找到page在我们数据库文件中的位置，比如我们想要找到page_no_1，它会告诉我们要找的那个page在这些数据库文件中的什么地方，page中的offset值有哪些，所以我们将page目录写在磁盘上，如果系统崩溃了，恢复后我们想知道该在哪里可以找到我么拥有的page，就可以访问page目录找到。</p>
<p>pagetable是内存中的映射，它将page_id映射到它们在buffer池中frame的位置。</p>
</blockquote>
<hr>
<p>当我们想将一个page放到内存中，但是内存中没有位置了应该怎么办呢？在替换策略中，我们最关心的就是正确性，如果说某个数据我们并没有真正地使用完，那么我们不想将它写出或移除，我们要确保我们所移除的page是在未来不太会被用到的那些page。</p>
<p>总而言之，为什么要使用buffer pool manager呢？</p>
<ol>
<li>如果没有缓冲池，那么数据都位于磁盘上，每次访问数据都要将其从磁盘读取到内存，下一次访问相同的数据时，还需要从磁盘读取，非常耗时。</li>
<li>现实中内存是有限的，如果我们在内存中缓存了page 1，2，3，已经存满内存了现在想访问page4，就要用到buffer pool manager，通过LRU机制进行替换。</li>
</ol>
<h5 id="CLOCK算法（了解）"><a href="#CLOCK算法（了解）" class="headerlink" title="CLOCK算法（了解）"></a>CLOCK算法（了解）</h5><hr>
<p>clock算法会给每个page设置一个标志位，唯一需要跟踪的就是每个page的标志位（referrence bit），它会告诉你自上次检查过该page之后，这个page是否被访问了。我们用环形队列来组织page，就像是一个clock，用一个能够旋转的指针去检查标志位是被设置为1还是0，如果是0，我们就可以知道从上次检查过之后该page就没有被访问过，因此我们就可以将该page从环形buffer中移除。</p>
<hr>
<p>我们将为BusTub DBMS构建一个面向磁盘的存储管理器。这样的存储管理器假定数据库的主要存储位置在磁盘上，project_1的任务是在存储管理器中实现缓冲池，缓冲池负责将物理页面从主存移动到磁盘，值的注意的是，DBMS需要支持大于系统可用内存量的数据库；多个线程将同时访问内部数据结构，因此我们需要确保他们的关键部分受到锁存器的保护。</p>
<p>我们可以维护一个单独的数据结构，比如队列，它根据page的时间戳进行排序，在某个时刻，有人对一个page进行读和写，我们只需要把该page从队列中拿出来，然后处理完放到队列的末尾，因为队列是先进先出的。</p>
<p>一句话，实验一的目标便在于主动管理磁盘中的页在内存中的缓存，从而最小化磁盘访问次数、最大化相关数据连续。</p>
<p>我们需要在存储管理器中实现以下组件：</p>
<ul>
<li>LRU更换策略</li>
<li>缓冲池管理器实例</li>
<li>并行缓冲池管理器</li>
</ul>
<h4 id="LRU更换策略"><a href="#LRU更换策略" class="headerlink" title="LRU更换策略"></a>LRU更换策略</h4><p>LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。也就是说我们这里定义一个<code>lru_list</code>，我们把pin_count为0的frame_id存放在lru_list，然后每次按照顺序出队（victim），如果在队列中的时候，这个frame_id被访问了，那么我们就从队列中删除它，直到它的pin_count再次为0，再次将它入队，循环往复。这样就达到了LRU的机制。</p>
<p>我们先来分析一下<code>include/buffer/replacer.h</code>中定义的父类Replacer。Replacer 是一个跟踪页面使用情况的抽象类。我们要实现以下方法：</p>
<ol>
<li><p>Victim(frame_id_t*)：Replacer跟踪与所有元素相比最近访问次数最少的对象并删除，将其删除页号存储在输出参数中，并返回 True。如果 Replacer 为空则返回 False。</p>
</li>
<li><p>Pin(frame_id_t)：在将page固定到BufferPoolManager中的frame后，应调用此方法。它应该从LRUReplacer中删除包含固定page的frame。</p>
</li>
<li><p>Unpin(frame_id_t)：当页面的引用计数变为 0 时，应该调用此方法。这个方法应该将未包含固定 page 的 frame 添加到 LRUReplacer，表示可能会被替换掉。（注意，需要判断是否超出了内存大小，如果超过了，则删除较新的页面，然后再添加。）</p>
</li>
<li><p>Size()：此方法返回当前在LRUReplacer中的页面数。</p>
<p><img src="http://tva1.sinaimg.cn/large/007SD2TBly1h2ym36wge4j30e706cwek.jpg" srcset="/img/loading.gif" lazyload alt="Untitled Diagram.drawio.png"></p>
</li>
</ol>
<p>在LRUReplacer中我们要实现一个队列<code>std::list&lt;frame_id_t&gt; lru_list_;</code>，这个队列用来维护page写入frame。我们可以将LRUReplacer当作是一个替换器，在初始状态下，LRUReplacer应当被初始化为不包含任何frames。当page加入到buffer pool的某个frame后，调用Pin删除在LRU队列中的frame<em>id，表示该frame已经不应该成为victim；Unpin则将未固定page的frame加入到LRU队列，表示该frame使用情况比较差（页面的引用计数变为0）；victim方法则是将LRU队列中最后一名frame_id弹出（在另外的对应的函数中会删除对应页面）。LRUReplacer的最大页数与缓冲池的大小相同（这样做是为了管理缓冲池中的所有frames），因此我们在LRUReplacer的构造函数中将capacity</em>的大小设置为参数num_pages，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs c++">LRUReplacer::<span class="hljs-built_in">LRUReplacer</span>(<span class="hljs-keyword">size_t</span> num_pages) &#123;<br>  capacity_ = num_pages;  <span class="hljs-comment">// Initialization the capacity</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>当我们将page加入到BufferPoolManager中的frame后，需要从LRUReplacer中删除相应的frame。Pin函数如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LRUReplacer::Pin</span><span class="hljs-params">(<span class="hljs-keyword">frame_id_t</span> frame_id)</span> </span>&#123;<br>  <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(latch_)</span></span>;<br>  <span class="hljs-keyword">if</span> (map_.<span class="hljs-built_in">count</span>(frame_id) == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><span class="hljs-comment">//</span><br>  <span class="hljs-keyword">auto</span> iter = map_[frame_id];<br>  lru_list_.<span class="hljs-built_in">erase</span>(iter);<br>  map_.<span class="hljs-built_in">erase</span>(frame_id);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>值得注意的是，我们在对LRUReplacer进行操作时应该上锁，以避免内存中特定的数据结构不会因为并发访问而导致错误。</strong>其实我们在每个函数前面用unique_lock是最稳妥的，既不会死锁，也保证安全。</p>
<p>当页面的引用计数为0时，应该调用Unpin，这个方法应该将未固定 page 的 frame 添加到 LRUReplacer，表示有被victim的风险。代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LRUReplacer::Unpin</span><span class="hljs-params">(<span class="hljs-keyword">frame_id_t</span> frame_id)</span> </span>&#123;<br>  <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(latch_)</span></span>;<br>  <span class="hljs-keyword">if</span> (map_.<span class="hljs-built_in">count</span>(frame_id) != <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果map里面已经没有这一帧/页了，就直接返回</span><br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (lru_list_.<span class="hljs-built_in">size</span>() == capacity_) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  lru_list_.<span class="hljs-built_in">push_front</span>(frame_id);<br>  map_.<span class="hljs-built_in">emplace</span>(frame_id, lru_list_.<span class="hljs-built_in">begin</span>());<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>Replacer跟踪与所有元素相比最近访问次数最少的对象并删除，将其删除页号存储在输出参数中，并返回 True。如果 Replacer 为空则返回 False。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">LRUReplacer::Victim</span><span class="hljs-params">(<span class="hljs-keyword">frame_id_t</span> *frame_id)</span> </span>&#123;<br>  <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(latch_)</span></span>;<br><br>  <span class="hljs-keyword">if</span> (map_.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><span class="hljs-comment">//将需要删除的frame_id写入参数</span><br>  *frame_id = lru_list_.<span class="hljs-built_in">back</span>();<br>  map_.<span class="hljs-built_in">erase</span>(*frame_id);<br>  lru_list_.<span class="hljs-built_in">pop_back</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="缓冲池管理器实例"><a href="#缓冲池管理器实例" class="headerlink" title="缓冲池管理器实例"></a>缓冲池管理器实例</h4><p>接下来，需要在系统中实现缓冲池管理器实例，该BufferPoolManagerInstance负责从DiskManager中读取数据库页并将它们存储在内存中。</p>
<p>我们来看看该类的数据结构：</p>
<ul>
<li><p><code>pages_</code>，保存在buffer pool中的page数组；</p>
</li>
<li><p><code>disk_manager</code>，磁盘管理器；</p>
</li>
<li><p><code>log_manager</code></p>
</li>
<li><p><code>page_table_</code>，页表，保存了page_id到frame_id的映射；</p>
</li>
<li><p><code>replacer</code>，查找未固定的页面进行替换；</p>
</li>
<li><p><code>free_list_</code>，没有被page填充的frame list。</p>
<p><img src="http://tva1.sinaimg.cn/large/007SD2TBly1h2yn3l8d12j30pb0abgm1.jpg" srcset="/img/loading.gif" lazyload alt="Untitled Diagram.drawio (1).png"></p>
</li>
</ul>
<p>刚看到这个任务的时候无从下手，还是一个函数一个函数分析。</p>
<ul>
<li><p><code>FlushPgImp</code>函数，我们要将在内存中的page内容刷新到磁盘。</p>
<p>题外话：由刷盘想到的——面试官问我，刷盘时机怎么选择，就比如微博的热榜tag数据，本来这个tag不是热数据，但是这个tag数据可能激增，激增之后刷盘策略要怎么改变来适应，热度又会慢慢降低，这个时候又怎么改变刷盘策略，主要是刷盘时机。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">BufferPoolManagerInstance::FlushPgImp</span><span class="hljs-params">(<span class="hljs-keyword">page_id_t</span> page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// Make sure you call DiskManager::WritePage</span><br>  <span class="hljs-comment">//在这里也是一样，每个函数前面加上unique_lock</span><br>  <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(latch_)</span></span>;<br>  <span class="hljs-comment">//如果page id不合法，或者page_id不存在于页表中，直接返回</span><br>  <span class="hljs-keyword">if</span>(page_id==INVALID_PAGE_ID||page_table_.<span class="hljs-built_in">count</span>(page_id)==<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-comment">//找到之后获取frame_id</span><br>  <span class="hljs-keyword">auto</span> iter=page_table_.<span class="hljs-built_in">find</span>(page_id);<br>  <span class="hljs-keyword">frame_id_t</span> frame_id=iter-&gt;second;<br>  <span class="hljs-comment">//获取相应的page</span><br>  Page *page=&amp;pages_[frame_id];<br>  <span class="hljs-comment">//将page写入磁盘</span><br>  disk_manager_-&gt;<span class="hljs-built_in">WritePage</span>(page-&gt;page_id_, page-&gt;data_);<span class="hljs-comment">//这里的page-&gt;page_id_就是参数page_id</span><br>  <span class="hljs-comment">//写回磁盘之后将page设置为不是脏页</span><br>  page-&gt;is_dirty_ = <span class="hljs-literal">false</span>;<span class="hljs-comment">//这里的is_dirty就是说是否在数据更改之后被刷回到盘里了，如果数据没有更改就是false,数据更改了还没有被刷回到盘里就是true</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>FlushAllPgsImp</code>函数，刷新所有页面到磁盘。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BufferPoolManagerInstance::FlushAllPgsImp</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(latch_)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span>;i&lt;pool_size_;++i)&#123;<br>      Page *page=&amp;pages_[i];<br>      <span class="hljs-built_in">FlushPgImp</span>(page-&gt;page_id_);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p><code>NewPgImp</code>函数：在缓冲池创建一个新页面。</p>
<p><img src="http://tva1.sinaimg.cn/large/007SD2TBly1h2yory14cqj30t70bfq4d.jpg" srcset="/img/loading.gif" lazyload alt=""></p>
<p>如果</p>
<ol>
<li>确保你调用<code>allocatepage</code>函数；</li>
<li>如果所有在buffer pool的page都pinned，那么返回nullptr；</li>
<li>从空闲列表或替换器中选择一个受害者页面 P。 始终首先从空闲列表中选择。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">page_id_t</span> <span class="hljs-title">BufferPoolManagerInstance::AllocatePage</span><span class="hljs-params">()</span> </span>&#123;<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">page_id_t</span> next_page_id = next_page_id_;<br>  <span class="hljs-comment">//一旦拿出一个next_page_id，就加上num_instances，到下一个next_page_id</span><br>  next_page_id_ += num_instances_;<br>  <span class="hljs-built_in">ValidatePageId</span>(next_page_id);<br>  <span class="hljs-keyword">return</span> next_page_id;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>那么我们看具体的代码实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Page *<span class="hljs-title">BufferPoolManagerInstance::NewPgImp</span><span class="hljs-params">(<span class="hljs-keyword">page_id_t</span> *page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// 0.   Make sure you call AllocatePage!</span><br>  <span class="hljs-comment">// 1.   If all the pages in the buffer pool are pinned, return nullptr.</span><br>  <span class="hljs-comment">// 2.   Pick a victim page P from either the free list or the replacer. Always pick from the free list first.</span><br>  <span class="hljs-comment">// 3.   Update P&#x27;s metadata, zero out memory and add P to the page table.</span><br>  <span class="hljs-comment">// 4.   Set the page ID output parameter. Return a pointer to P.</span><br>  <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(latch_)</span></span>;<br>  <span class="hljs-keyword">bool</span> all_pinned = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; pool_size_; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (pages_[i].pin_count_ &lt;= <span class="hljs-number">0</span>) &#123;<br>      all_pinned = <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (all_pinned) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>  <span class="hljs-keyword">frame_id_t</span> frame_id=<span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">if</span>(!free_list_.<span class="hljs-built_in">empty</span>())&#123;<br>    <span class="hljs-keyword">if</span>(!replacer_-&gt;<span class="hljs-built_in">Victim</span>(&amp;frame_id))&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    frame_id=free_list_.<span class="hljs-built_in">front</span>();<br>    free_list_.<span class="hljs-built_in">pop_front</span>();<br>  &#125;<br>  *page_id=<span class="hljs-built_in">AllocatePage</span>();<span class="hljs-comment">//</span><br>  Page *page = &amp;pages_[frame_id];<span class="hljs-comment">//我们找到pages序列中对应的要被替换的一帧</span><br>  <span class="hljs-comment">//disk page-&gt;pool page</span><br>  <span class="hljs-keyword">if</span> (page-&gt;<span class="hljs-built_in">IsDirty</span>()) &#123;<span class="hljs-comment">//如果这一页数据是dirty,先把这一页数据写回去</span><br>    disk_manager_-&gt;<span class="hljs-built_in">WritePage</span>(page-&gt;page_id_, page-&gt;data_);<br>    page-&gt;is_dirty_ = <span class="hljs-literal">false</span>;<br>  &#125;<br>  page_table_.<span class="hljs-built_in">erase</span>(page-&gt;page_id_);<br>  <span class="hljs-keyword">if</span> (*page_id != INVALID_PAGE_ID) &#123;<br>    page_table_.<span class="hljs-built_in">emplace</span>(*page_id, frame_id);<br>  &#125;<br>  page-&gt;<span class="hljs-built_in">ResetMemory</span>();<br>  page-&gt;page_id_ = *page_id;<br>  replacer_-&gt;<span class="hljs-built_in">Pin</span>(frame_id);<br>  page-&gt;pin_count_=<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> page;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>FetchPgImp</code>函数，从缓冲池中获取请求的页面，我们可以从官方注释中具体了解这个方法要实现的任务：</p>
<ol>
<li>在页表中寻找请求页面P；<ul>
<li>如果页面P存在，调用Pin方法后返回；</li>
<li>如果页面P不存在，则从空闲列表或替换其中查找替换页R；</li>
</ul>
</li>
<li>将脏页写回磁盘；</li>
<li>从页表中删除R，插入P；</li>
<li>更新P的元数据，从磁盘读入页面内容，返回一个指向P的指针。</li>
</ol>
</li>
</ul>
<p>​        代码如下，具体解析在注释中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Page *<span class="hljs-title">BufferPoolManagerInstance::FetchPgImp</span><span class="hljs-params">(<span class="hljs-keyword">page_id_t</span> page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// 1.     Search the page table for the requested page (P).</span><br>  <span class="hljs-comment">// 1.1    If P exists, pin it and return it immediately.</span><br>  <span class="hljs-comment">// 1.2    If P does not exist, find a replacement page (R) from either the free list or the replacer.</span><br>  <span class="hljs-comment">//        Note that pages are always found from the free list first.</span><br>  <span class="hljs-comment">// 2.     If R is dirty, write it back to the disk.</span><br>  <span class="hljs-comment">// 3.     Delete R from the page table and insert P.</span><br>  <span class="hljs-comment">// 4.     Update P&#x27;s metadata, read in the page content from disk, and then return a pointer to P.</span><br>  <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(latch_)</span></span>;<br>  <span class="hljs-keyword">if</span>(page_id==INVALID_PAGE_ID)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>  <span class="hljs-keyword">auto</span> iter = page_table_.<span class="hljs-built_in">find</span>(page_id);<br>  <span class="hljs-keyword">if</span>(iter==page_table_.<span class="hljs-built_in">end</span>())&#123;<br>    <span class="hljs-keyword">frame_id_t</span> frame_id=<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(free_list_.<span class="hljs-built_in">empty</span>()&amp;&amp;!replacer_-&gt;<span class="hljs-built_in">Victim</span>(&amp;frame_id))&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!free_list_.<span class="hljs-built_in">empty</span>())&#123;<br>      frame_id=free_list_.<span class="hljs-built_in">front</span>();<br>      free_list_.<span class="hljs-built_in">pop_front</span>();<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-keyword">auto</span> old_page_id=page_table_[frame_id];<br>      <span class="hljs-keyword">auto</span> page=&amp;pages_[frame_id];<br>      <span class="hljs-keyword">if</span>(page-&gt;<span class="hljs-built_in">IsDirty</span>())&#123;<br>        disk_manager_-&gt;<span class="hljs-built_in">WritePage</span>(page-&gt;page_id_,page-&gt;data_);<br>        page-&gt;is_dirty_=<span class="hljs-literal">false</span>;<br>      &#125;<br>      page_table_.<span class="hljs-built_in">erase</span>(old_page_id);<br>    &#125;<br>    page_table_.<span class="hljs-built_in">emplace</span>(page_id, frame_id);<br>    <span class="hljs-keyword">auto</span> tar = &amp;pages_[frame_id];<br>    tar-&gt;page_id_=page_id;<br>    tar-&gt;<span class="hljs-built_in">ResetMemory</span>();<br>    disk_manager_-&gt;<span class="hljs-built_in">ReadPage</span>(page_id, tar-&gt;data_);<br>    replacer_-&gt;<span class="hljs-built_in">Pin</span>(frame_id);<br>    tar-&gt;pin_count_ = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> tar;<br>  &#125;<span class="hljs-comment">//如果pool中有该page</span><br>  <span class="hljs-keyword">frame_id_t</span> frame_id=iter-&gt;second;<br>  <span class="hljs-keyword">auto</span> tar=&amp;pages_[frame_id];<span class="hljs-comment">//获取相应的page_id</span><br>  replacer_-&gt;<span class="hljs-built_in">Pin</span>(frame_id);<span class="hljs-comment">//不管replacer里面有没有我们都调用一次</span><br>  tar-&gt;pin_count_++;<br>  <span class="hljs-keyword">return</span> tar;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>UnpinPgImp函数</code>：这个函数就是完成对该页面操作之后，进行Unpin操作。<ol>
<li>如果一开始<code>pin_couter==0</code>，直接返回。</li>
<li>如果这个页面的<code>pin_couter&gt;0</code>，我们直接返回。</li>
<li>如果这个页面的<code>pin_couter==0</code>，我们需要给它加入到LRU_Replacer中。<strong>因为没有人引用它，所以它可以成为被替换的候选人</strong>。</li>
</ol>
</li>
</ul>
<p>​        其代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">BufferPoolManagerInstance::UnpinPgImp</span><span class="hljs-params">(<span class="hljs-keyword">page_id_t</span> page_id, <span class="hljs-keyword">bool</span> is_dirty)</span> </span>&#123;<br>  <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(latch_)</span></span>;<br>  <span class="hljs-comment">//如果page id不合法，或者page_id不存在于页表中，直接返回</span><br>  <span class="hljs-keyword">if</span>(page_id==INVALID_PAGE_ID||page_table_.<span class="hljs-built_in">count</span>(page_id)==<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-comment">//找到之后获取frame_id</span><br>  <span class="hljs-keyword">auto</span> iter=page_table_.<span class="hljs-built_in">find</span>(page_id);<br><br>  <span class="hljs-keyword">frame_id_t</span> frame_id = iter-&gt;second;<br>  Page *page = &amp;pages_[frame_id];<br>  <span class="hljs-comment">//如果直接是等于0的，说明不需要unpin操作，直接返回</span><br>  <span class="hljs-keyword">if</span> (page-&gt;pin_count_ == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-comment">//如果之前被调用过，执行下列操作</span><br>  page-&gt;pin_count_--;<br>  <span class="hljs-keyword">if</span> (page-&gt;pin_count_ == <span class="hljs-number">0</span>) &#123;<br>    replacer_-&gt;<span class="hljs-built_in">Unpin</span>(frame_id);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (is_dirty) &#123;<br>    page-&gt;is_dirty_ = <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p><code>DeletePgImp</code>函数：从缓冲池删除一个页面，如果页面存在但无法删除，则返回 false，如果页面不存在或删除成功，则返回 true。</p>
<ol>
<li>Make sure you call DeallocatePage!</li>
<li>Search the page table for the requested page (P).</li>
<li>If P des not exist, return true.</li>
<li>If P exists, but has a non-zero pin-count, return fale. Someone is using the page.</li>
<li>Otherwise, P can be deleted. Remove P from the page table, reset its metadata and return it to the free list.</li>
</ol>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">BufferPoolManagerInstance::DeletePgImp</span><span class="hljs-params">(<span class="hljs-keyword">page_id_t</span> page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// 0.   Make sure you call DeallocatePage!</span><br>  <span class="hljs-comment">// 1.   Search the page table for the requested page (P).</span><br>  <span class="hljs-comment">// 1.   If P does not exist, return true.</span><br>  <span class="hljs-comment">// 2.   If P exists, but has a non-zero pin-count, return false. Someone is using the page.</span><br>  <span class="hljs-comment">// 3.   Otherwise, P can be deleted. Remove P from the page table, reset its metadata and return it to the free list.</span><br>  <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(latch_)</span></span>;<br>  <span class="hljs-keyword">auto</span> iter = page_table_.<span class="hljs-built_in">find</span>(page_id);<br>  <span class="hljs-keyword">if</span>(iter==page_table_.<span class="hljs-built_in">end</span>())&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(pages_[iter-&gt;second].pin_count_&gt;<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-built_in">DeallocatePage</span>(page_id);<br>  <span class="hljs-keyword">frame_id_t</span> frame_id=page_table_[page_id];<br>  <span class="hljs-keyword">auto</span> page=&amp;pages_[frame_id];<br>  <span class="hljs-keyword">if</span>(page-&gt;<span class="hljs-built_in">IsDirty</span>())&#123;<br>    disk_manager_-&gt;<span class="hljs-built_in">WritePage</span>(page-&gt;page_id_,page-&gt;data_);<br>    page-&gt;is_dirty_=<span class="hljs-literal">false</span>;<br>  &#125;<br>  page-&gt;<span class="hljs-built_in">ResetMemory</span>();<br>  page-&gt;page_id_=INVALID_PAGE_ID;<br>  free_list_.<span class="hljs-built_in">push_back</span>(frame_id);<br>  page_table_.<span class="hljs-built_in">erase</span>(page_id);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="并行缓冲池管理器"><a href="#并行缓冲池管理器" class="headerlink" title="并行缓冲池管理器"></a>并行缓冲池管理器</h4><p>正如上个任务中看到的，每一个缓冲池都有一个锁来保证线程安全。这可能导致性能问题，因为每个线程在与缓冲池交互时都会争夺该锁。一个可行的解决方案是同时维护多个缓冲池，每个缓冲池都有独立的锁。</p>
<p>ParallelBufferPoolManager是一个包含多个bufferpoolmanagerinstance的类。对于每个操作，其都会选择一个实例并调用该实例。</p>
<p>我们使用给定的page_id来确实使用哪个特定的实例。如果我们有多个实例，则需要某种方法将page_id映射到[0, num_instances)中。对于本项目，我们将使用模运算，即page_id mod num_instances来将给定的page_id映射到正确的范围。</p>
<p>当ParallelBufferPoolManager初始化的时候，他的起始索引应该是0。此后每创建一个新的页面，都应从起始索引开始尝试每个实例直到某个成功。然后将起始指数加1。</p>
<p>确保当你创建单独的BufferPoolManagerInstances时，你调用的构造函数应使用uint32_t num_instances和uint32_t instance_index，来保证页面id被正确地创建。</p>
<p>上面是机器翻译的，我来总结一下：也就是说，现在我们可以在系统中搞多个缓冲池，每个缓冲池都有自己的锁，这样来实现并行。那么如何确定我们要查找的page位于哪个缓冲池呢，我们可以根据<strong>某种映射方式</strong>，也就是说，我们可以用page_id%num_instances来确定page_id是位于哪一个缓冲池实例。</p>
<p>我们还是先来看看<code>ParallelBufferPoolManager</code>类中的数据结构，如下所示：</p>
<ul>
<li><code>size_t pool_size_</code>：缓冲池的页数</li>
<li><code>uint32_t num_instances_ = 1</code>：实例的数量</li>
<li><code>uint32_t instance_index_ = 0</code>：实例的索引</li>
</ul>
<p>有了上面的讲解，那么下面两个函数的实现就很容易了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">ParallelBufferPoolManager::GetPoolSize</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// Get size of all BufferPoolManagerInstances</span><br>  <span class="hljs-keyword">return</span> pool_size_ * num_instances_;<br>&#125;<br><br><span class="hljs-function">BufferPoolManager *<span class="hljs-title">ParallelBufferPoolManager::GetBufferPoolManager</span><span class="hljs-params">(<span class="hljs-keyword">page_id_t</span> page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// Get BufferPoolManager responsible for handling given page id. You can use this method in your other methods.</span><br><br>  <span class="hljs-keyword">return</span> parallel_bmi_[page_id% num_instances_];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于缓冲区实例的操作也很简单了，我们只需要在获得page_id参数之后用<code>GetBufferPoolManager</code>，来知道是在哪一个实例当中，就可以了，代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Page *<span class="hljs-title">ParallelBufferPoolManager::FetchPgImp</span><span class="hljs-params">(<span class="hljs-keyword">page_id_t</span> page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// Fetch page for page_id from responsible BufferPoolManagerInstance</span><br>  BufferPoolManager *manager = <span class="hljs-built_in">GetBufferPoolManager</span>(page_id);<br>  <span class="hljs-keyword">return</span> manager-&gt;<span class="hljs-built_in">FetchPage</span>(page_id);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ParallelBufferPoolManager::UnpinPgImp</span><span class="hljs-params">(<span class="hljs-keyword">page_id_t</span> page_id, <span class="hljs-keyword">bool</span> is_dirty)</span> </span>&#123;<br>  <span class="hljs-comment">// Unpin page_id from responsible BufferPoolManagerInstance</span><br>  BufferPoolManager *manager = <span class="hljs-built_in">GetBufferPoolManager</span>(page_id);<br>  <span class="hljs-keyword">return</span> manager-&gt;<span class="hljs-built_in">UnpinPage</span>(page_id, is_dirty);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ParallelBufferPoolManager::FlushPgImp</span><span class="hljs-params">(<span class="hljs-keyword">page_id_t</span> page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// Flush page_id from responsible BufferPoolManagerInstance</span><br>  BufferPoolManager *manager = <span class="hljs-built_in">GetBufferPoolManager</span>(page_id);<br>  <span class="hljs-keyword">return</span> manager-&gt;<span class="hljs-built_in">FlushPage</span>(page_id);<br>&#125;<br><br><span class="hljs-function">Page *<span class="hljs-title">ParallelBufferPoolManager::NewPgImp</span><span class="hljs-params">(<span class="hljs-keyword">page_id_t</span> *page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// create new page. We will request page allocation in a round robin manner from the underlying</span><br>  <span class="hljs-comment">// BufferPoolManagerInstances</span><br>  <span class="hljs-comment">// 1.   From a starting index of the BPMIs, call NewPageImpl until either 1) success and return 2) looped around to</span><br>  <span class="hljs-comment">// starting index and return nullptr</span><br>  <span class="hljs-comment">// 2.   Bump the starting index (mod number of instances) to start search at a different BPMI each time this function</span><br>  <span class="hljs-comment">// is called</span><br>  Page *page = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">size_t</span> index = start_id_;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; num_instances_; ++i) &#123;<br>    page = parallel_bmi_[index]-&gt;<span class="hljs-built_in">NewPage</span>(page_id);<br>    <span class="hljs-keyword">if</span> (page != <span class="hljs-literal">nullptr</span>) &#123;<br>      start_id_ = (index + <span class="hljs-number">1</span>) % num_instances_;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    index = (index + <span class="hljs-number">1</span>) % num_instances_;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> page;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ParallelBufferPoolManager::DeletePgImp</span><span class="hljs-params">(<span class="hljs-keyword">page_id_t</span> page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// Delete page_id from responsible BufferPoolManagerInstance</span><br>  BufferPoolManager *manager = <span class="hljs-built_in">GetBufferPoolManager</span>(page_id);<br>  <span class="hljs-keyword">return</span> manager-&gt;<span class="hljs-built_in">DeletePage</span>(page_id);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ParallelBufferPoolManager::FlushAllPgsImp</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// flush all pages from all BufferPoolManagerInstances</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; num_instances_; i++) &#123;<br>    parallel_bmi_[i]-&gt;<span class="hljs-built_in">FlushAllPages</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/CMU-15-455/">CMU_15-455</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/02/15/CMU-15-445-PROJECT-2/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CMU_15-445_PROJECT#2</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/02/01/MIT-S081-Labs-traps/">
                        <span class="hidden-mobile">MIT_6.s081_Lab4_traps</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  





  <script  src="https://unpkg.com/mermaid@9.0.1/dist/mermaid.min.js/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>







<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
