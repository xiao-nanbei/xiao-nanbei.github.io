

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://tva1.sinaimg.cn/large/008qL1EEly1gymvh3hte4j30680680t3.jpg">
  <link rel="icon" href="https://tva1.sinaimg.cn/large/008qL1EEly1gymvh3hte4j30680680t3.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="Go map底层实现Go语言的map的底层实现基于Hash散列，Hash散列是一种著名的广义上的算法，它能将任意长度的数据映射到有限的值域当中。在实际工程中输入数据范围是无限的，而输出值域范围是有限的，因此必然存在不同的输入数据经过映射后得到相同的输出值，这种现象称为hash冲突，go底层通过链表解决hash冲突。值得注意的是：&#x3D;&#x3D;Java1.8中使用平衡树来优化局部链表过长的性能问题。&#x3D;&#x3D; 使用">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang_包解析">
<meta property="og:url" content="https://xiao-nanbei.github.io/2022/03/20/Golang-container/index.html">
<meta property="og:site_name" content="databrains">
<meta property="og:description" content="Go map底层实现Go语言的map的底层实现基于Hash散列，Hash散列是一种著名的广义上的算法，它能将任意长度的数据映射到有限的值域当中。在实际工程中输入数据范围是无限的，而输出值域范围是有限的，因此必然存在不同的输入数据经过映射后得到相同的输出值，这种现象称为hash冲突，go底层通过链表解决hash冲突。值得注意的是：&#x3D;&#x3D;Java1.8中使用平衡树来优化局部链表过长的性能问题。&#x3D;&#x3D; 使用">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-20T07:05:46.000Z">
<meta property="article:modified_time" content="2022-04-03T12:01:42.170Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  <title>Golang_包解析 - databrains</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="https://at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"xiao-nanbei.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>databrains</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://tva1.sinaimg.cn/large/008qL1EEly1gymvk0ibtcj31hc0u04qp.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Golang_包解析">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-20 15:05" pubdate>
        2022年3月20日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      11k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      96 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Golang_包解析</h1>
            
            <div class="markdown-body">
              <h3 id="Go-map"><a href="#Go-map" class="headerlink" title="Go map"></a>Go map</h3><h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><p>Go语言的map的底层实现基于Hash散列，Hash散列是一种著名的广义上的算法，它能将任意长度的数据映射到有限的值域当中。在实际工程中输入数据范围是无限的，而输出值域范围是有限的，因此必然存在不同的输入数据经过映射后得到相同的输出值，这种现象称为hash冲突，go底层通过链表解决hash冲突。值得注意的是：==Java1.8中使用平衡树来优化局部链表过长的性能问题。==</p>
<p>使用哈希表的目的就是要快速查找到目标key，然而，随着向map中添加的key越来越多，key发生碰撞的概率也越来越大，bucket中的8个cell会被逐渐塞满，插入、查找和删除key的效率也会越来越低，最理想的情况是bucket只装入一个key，这样，就能达到$O(1)$的效率，但这样空间消耗太大，代价太高。</p>
<p>底层源码如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A header for a Go map.</span><br><span class="hljs-keyword">type</span> hmap <span class="hljs-keyword">struct</span> &#123;<br>	count     <span class="hljs-keyword">int</span> <span class="hljs-comment">// # live cells == size of map.  Must be first (used by len() builtin)</span><br>	flags     <span class="hljs-keyword">uint8</span><br>	B         <span class="hljs-keyword">uint8</span>  <span class="hljs-comment">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span><br>	noverflow <span class="hljs-keyword">uint16</span> <br>	hash0     <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// hash seed</span><br><br>	buckets    unsafe.Pointer <span class="hljs-comment">// array of 2^B Buckets. may be nil if count==0.</span><br>	oldbuckets unsafe.Pointer <span class="hljs-comment">// previous bucket array of half the size, non-nil only when growing</span><br>	nevacuate  <span class="hljs-keyword">uintptr</span>        <span class="hljs-comment">// progress counter for evacuation (buckets less than this have been evacuated)</span><br><br>	extra *mapextra <span class="hljs-comment">// optional fields</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中，<code>buckets unsafe.Pointer</code>指向具体的buckets数组，这个数组是<code>bmap</code>结构，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A bucket for a Go map.</span><br><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>	tophash [bucketCnt]<span class="hljs-keyword">uint8</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在实际编译期间，Go语言的<code>bmap</code>会经过反射生成真正的<code>bmap</code>类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>  topbits  [<span class="hljs-number">8</span>]<span class="hljs-keyword">uint8</span><br>  keys     [<span class="hljs-number">8</span>]keytype<br>  values   [<span class="hljs-number">8</span>]valuetype<br>  pad      <span class="hljs-keyword">uintptr</span><br>  overflow <span class="hljs-keyword">uintptr</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>map的访问即通过给定的key在map中寻找其对应value，过程如下：</p>
<ol>
<li>原始的key通过hash函数映射成64位二进制；</li>
<li>末尾x位代表<code>bmap</code>的位置，从<code>[]bmap</code>中找到对应的<code>bmap</code>，值得注意的是，bmap的数量一般是2的幂，如果末尾x位代表<code>bmap</code>的位置就代表有$2^x$个<code>bmap</code>；</li>
<li>首8位对应key的tophash，在bmap中进行检索，首先会比较<code>bmap</code>顶层的<code>tophash</code>与原始key的<code>tophash</code>是否相同，若不相同则直接跳过比较下一个；若相同则进一步比较key是否相同。</li>
</ol>
<h3 id="container"><a href="#container" class="headerlink" title="container"></a><code>container</code></h3><p>众所周知，Go对于一些基本的数据结构封装得不是很好，在<code>container</code>中也只有三种常见的数据结构——链表、环形链表和堆。</p>
<h4 id="container-list"><a href="#container-list" class="headerlink" title="container/list"></a><code>container/list</code></h4><p>我们先来看看<code>list</code>的写入与打印：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">l := list.New()<br>l.PushBack(<span class="hljs-number">1</span>) <span class="hljs-comment">//尾插</span><br>l.PushBack(<span class="hljs-number">2</span>)<br>fmt.Println(l)<br></code></pre></td></tr></table></figure>
<p>我们看看打印结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">&amp;&#123;&#123;<span class="hljs-number">0xc00007c180</span> <span class="hljs-number">0xc00007c1b0</span> &lt;<span class="hljs-literal">nil</span>&gt; &lt;<span class="hljs-literal">nil</span>&gt;&#125; <span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure>
<p>为什么打印结果是这样的，如果我们弄懂<code>list</code>的底层结构，就能知道答案了。<code>list</code>的底层结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Element <span class="hljs-keyword">struct</span> &#123;<br>	<span class="hljs-comment">// Next and previous pointers in the doubly-linked list of elements.</span><br>	<span class="hljs-comment">// To simplify the implementation, internally a list l is implemented</span><br>	<span class="hljs-comment">// as a ring, such that &amp;l.root is both the next element of the last</span><br>	<span class="hljs-comment">// list element (l.Back()) and the previous element of the first list</span><br>	<span class="hljs-comment">// element (l.Front()).</span><br>	next, prev *Element<br><br>	<span class="hljs-comment">// The list to which this element belongs.</span><br>	list *List<br><br>	<span class="hljs-comment">// The value stored with this element.</span><br>	Value <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// List represents a doubly linked list.</span><br><span class="hljs-comment">// The zero value for List is an empty list ready to use.</span><br><span class="hljs-keyword">type</span> List <span class="hljs-keyword">struct</span> &#123;<br>	root Element <span class="hljs-comment">// sentinel list element, only &amp;root, root.prev, and root.next are used</span><br>	<span class="hljs-built_in">len</span>  <span class="hljs-keyword">int</span>     <span class="hljs-comment">// current list length excluding (this) sentinel element</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>结合上面的打印，我们可以发现，<code>&#123;0xc00007c180 0xc00007c1b0 &lt;nil&gt; &lt;nil&gt;&#125;</code> 是<code>root Element</code>，<code>2</code>是<code>len int</code>。我们接着打印：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">l := list.New()<span class="hljs-comment">//初始化</span><br>l.PushBack(<span class="hljs-number">1</span>) <span class="hljs-comment">//尾插</span><br>l.PushBack(<span class="hljs-number">2</span>)<br>fmt.Println(l.Front())<br>fmt.Println(l.Back())<br>fmt.Println(l)<br></code></pre></td></tr></table></figure>
<p>其打印结果如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">&amp;&#123;<span class="hljs-number">0xc00007c1b0</span> <span class="hljs-number">0xc00007c150</span> <span class="hljs-number">0xc00007c150</span> <span class="hljs-number">1</span>&#125;<br>&amp;&#123;<span class="hljs-number">0xc00007c150</span> <span class="hljs-number">0xc00007c180</span> <span class="hljs-number">0xc00007c150</span> <span class="hljs-number">2</span>&#125;<br>&amp;&#123;&#123;<span class="hljs-number">0xc00007c180</span> <span class="hljs-number">0xc00007c1b0</span> &lt;<span class="hljs-literal">nil</span>&gt; &lt;<span class="hljs-literal">nil</span>&gt;&#125; <span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure>
<p>从这个结果我们不难看出，<code>list</code>其实是一个环形结构。其中，<code>root</code>的next指向链表的<code>front</code>，<code>root</code>的pre指向链表的<code>back</code>，而<code>root</code>自身是不存储数据的。如果我们再加上一个数据，就会变成这样了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">l := list.New()<span class="hljs-comment">//初始化</span><br>l.PushBack(<span class="hljs-number">1</span>) <span class="hljs-comment">//尾插</span><br>l.PushBack(<span class="hljs-number">2</span>)<br>l.PushBack(<span class="hljs-number">3</span>)<br>fmt.Println(l.Front())<br>fmt.Println(l.Back())<br>fmt.Println(l)<br></code></pre></td></tr></table></figure>
<p>其打印结果如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">&amp;&#123;<span class="hljs-number">0xc00007c1b0</span> <span class="hljs-number">0xc00007c150</span> <span class="hljs-number">0xc00007c150</span> <span class="hljs-number">1</span>&#125;<br>&amp;&#123;<span class="hljs-number">0xc00007c150</span> <span class="hljs-number">0xc00007c1b0</span> <span class="hljs-number">0xc00007c150</span> <span class="hljs-number">3</span>&#125;<br>&amp;&#123;&#123;<span class="hljs-number">0xc00007c180</span> <span class="hljs-number">0xc00007c1e0</span> &lt;<span class="hljs-literal">nil</span>&gt; &lt;<span class="hljs-literal">nil</span>&gt;&#125; <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="container-heap"><a href="#container-heap" class="headerlink" title="container/heap"></a><code>container/heap</code></h4><p>我们来看看如何初始化一个heap，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>	name  <span class="hljs-keyword">string</span><br>	score <span class="hljs-keyword">int</span><br>&#125;<br>h := &amp;StudentHeap&#123;<br>	&#123;name: <span class="hljs-string">&quot;xiaoming&quot;</span>, score: <span class="hljs-number">82</span>&#125;,<br>	&#123;name: <span class="hljs-string">&quot;xiaozhang&quot;</span>, score: <span class="hljs-number">88</span>&#125;,<br>	&#123;name: <span class="hljs-string">&quot;laowang&quot;</span>, score: <span class="hljs-number">85</span>&#125;<br>&#125;<br>heap.Init(h)<br></code></pre></td></tr></table></figure>
<p>先来读读<code>Init()</code>函数，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Init</span><span class="hljs-params">(h Interface)</span></span> &#123;<br>	<span class="hljs-comment">// heapify</span><br>	n := h.Len()<br>	<span class="hljs-keyword">for</span> i := n/<span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>		down(h, i, n)<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">down</span><span class="hljs-params">(h Interface, i0, n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>	i := i0<br>	<span class="hljs-keyword">for</span> &#123;<br>		j1 := <span class="hljs-number">2</span>*i + <span class="hljs-number">1</span><br>		<span class="hljs-keyword">if</span> j1 &gt;= n || j1 &lt; <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// j1 &lt; 0 after int overflow</span><br>			<span class="hljs-keyword">break</span><br>		&#125;<br>		j := j1 <span class="hljs-comment">// left child</span><br>		<span class="hljs-keyword">if</span> j2 := j1 + <span class="hljs-number">1</span>; j2 &lt; n &amp;&amp; h.Less(j2, j1) &#123;<br>			j = j2 <span class="hljs-comment">// = 2*i + 2  // right child</span><br>		&#125;<br>		<span class="hljs-keyword">if</span> !h.Less(j, i) &#123;<br>			<span class="hljs-keyword">break</span><br>		&#125;<br>		h.Swap(i, j)<br>		i = j<br>	&#125;<br>	<span class="hljs-keyword">return</span> i &gt; i0<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到，这两个函数跟我们的堆排序很像，还是讲一下，</p>
<h4 id="container-ring"><a href="#container-ring" class="headerlink" title="container/ring"></a><code>container/ring</code></h4><blockquote>
<p>环的结构有点特殊，环的尾部就是头部，所以每个元素实际上就可以代表自身的这个环。 它不需要像 list 一样保持 list 和 element 两个结构，只需要保持一个结构就行。</p>
<p>——[1. 3.3 container — 容器数据类型：heap、list 和 ring][<a target="_blank" rel="noopener" href="https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter03/03.3.html">https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter03/03.3.html</a>]</p>
</blockquote>
<p>我觉得这句话总结得很好，</p>
<h3 id="reflect"><a href="#reflect" class="headerlink" title="reflect"></a><code>reflect</code></h3><h4 id="reflect-DeepEqual"><a href="#reflect-DeepEqual" class="headerlink" title="reflect.DeepEqual"></a><code>reflect.DeepEqual</code></h4><p><code>DeepEqual</code>函数用来判断两个值是否深度一致。这和<code>==</code>有什么不同吗？我们来看看下面例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> S <span class="hljs-keyword">struct</span>&#123;<br>	name <span class="hljs-keyword">string</span><br>    age	 <span class="hljs-keyword">int</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>     a := S&#123;<br>        name:    <span class="hljs-string">&quot;aa&quot;</span>,<br>        age:     <span class="hljs-number">1</span>,<br>    &#125;<br>    b := S&#123;<br>        name:    <span class="hljs-string">&quot;aa&quot;</span>,<br>        age:     <span class="hljs-number">1</span>,<br>    &#125;<br><br>   fmt.Println(a == b)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中<code>a==b</code>为<code>true</code>。如果我们将结构体中加入一个指针，就会返回false，这是因为指针指向的地址不一样，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> S <span class="hljs-keyword">struct</span> &#123;<br>    Name    <span class="hljs-keyword">string</span><br>    Age     <span class="hljs-keyword">int</span><br>    Address *<span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    a := S&#123;<br>        Name:    <span class="hljs-string">&quot;aa&quot;</span>,<br>        Age:     <span class="hljs-number">1</span>,<br>        Address: <span class="hljs-built_in">new</span>(<span class="hljs-keyword">int</span>),<br>    &#125;<br>    b := S&#123;<br>        Name:    <span class="hljs-string">&quot;aa&quot;</span>,<br>        Age:     <span class="hljs-number">1</span>,<br>        Address: <span class="hljs-built_in">new</span>(<span class="hljs-keyword">int</span>),<br>    &#125;<br><br>   fmt.Println(a == b)<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>这时会返回<code>false</code>。</p>
<p>值得注意的是：<code>slice</code>、<code>map</code>、<code>function</code>是不能参与比较的，如果在结构体中出现以上类型，会<code>panic</code>。在这里我们就有一个疑问？到底是什么原因导致<code>slice</code>、<code>map</code>、<code>function</code>不能进行比较，如果是因为引用类型的原因，<code>channel</code>却可以进行比较。我们先来看看比较<code>slice</code>的时候返回的错误，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">invalid operation: a == b (<span class="hljs-keyword">struct</span> containing []<span class="hljs-keyword">int</span> cannot be compared)<br></code></pre></td></tr></table></figure>
<p>有的博主说<code>slice</code>不可比较有两个原因：</p>
<ul>
<li>引用类型，比较地址没有意义。</li>
<li>切片有len，cap，比较的维度不好衡量，因此go设计的时候就不允许切片可比较。</li>
</ul>
<p>但是我们来看看这个情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> S <span class="hljs-keyword">struct</span> &#123;<br>	Name    <span class="hljs-keyword">string</span><br>	Age     <span class="hljs-keyword">int</span><br>	Ch	<span class="hljs-keyword">chan</span> []<span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	a := S&#123;<br>		Name:    <span class="hljs-string">&quot;aa&quot;</span>,<br>		Age:     <span class="hljs-number">1</span>,<br>		Ch:      <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> []<span class="hljs-keyword">int</span>),<br>	&#125;<br>	b := S&#123;<br>		Name:    <span class="hljs-string">&quot;aa&quot;</span>,<br>		Age:     <span class="hljs-number">1</span>,<br>		Ch:      <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> []<span class="hljs-keyword">int</span>),<br>	&#125;<br><br>	fmt.Println(a == b)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>但是在<code>[]int</code>的<code>channel</code>是可以比较的，这就会比较迷惑。</p>
<p>无独有偶，两个<code>interface&#123;&#125;</code>是能比较的，其规则如下：</p>
<ul>
<li>两个类型相同且值相同的接口比较结果为<code>true</code>；</li>
<li>两个类型相同且值不同的接口比较结果为<code>false</code>；</li>
<li>两个类型不同的接口比较结果为<code>false</code>；</li>
<li>如果空接口保存了上面的<code>slice</code>、<code>map</code>和<code>function</code>的值，则不能比较。</li>
</ul>
<p>总结：类型不同的空接口间的比较结果不相同，不能比较空接口中的动态值。</p>
<p>回到正题，我们来看看<code>reflect.DeepEqual</code>，<code>reflect.DeepEqual</code>在可以时（主要是基本类型）会使用<code>==</code>；但还会比较<code>array</code>、<code>slice</code>的<strong>成员</strong>，<code>map</code>的<strong>键值对</strong>，<strong>结构体字段</strong>进行深入比对。如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	m1 := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-number">1</span>: []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, <span class="hljs-number">2</span>: <span class="hljs-number">3</span>, <span class="hljs-number">3</span>: <span class="hljs-string">&quot;a&quot;</span>&#125;<br>	m2 := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-number">1</span>: []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, <span class="hljs-number">2</span>: <span class="hljs-number">3</span>, <span class="hljs-number">3</span>: <span class="hljs-string">&quot;a&quot;</span>&#125;<br>	<span class="hljs-keyword">if</span> reflect.DeepEqual(m1, m2) &#123;<br>		fmt.Println(<span class="hljs-string">&quot;相等&quot;</span>)<br>	&#125;<br>&#125;<br><span class="hljs-comment">//输出”相等”</span><br></code></pre></td></tr></table></figure>
<p>当然，我们还是要从它的源码进行分析:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeepEqual</span><span class="hljs-params">(x, y <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span> &#123;<br>	<span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> || y == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> x == y<br>	&#125;<br>	v1 := ValueOf(x)<br>	v2 := ValueOf(y)<br>	<span class="hljs-keyword">if</span> v1.Type() != v2.Type() &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> deepValueEqual(v1, v2, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[visit]<span class="hljs-keyword">bool</span>))<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>我们可以看到，如果<code>x==nil</code>或者<code>y==nil</code>，就比较二者的指针，否则比较二者的类型，如果类型相同，那么我们就用<code>deepValueEqual</code>函数进行比较。我们看到这个函数：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp">```<br><br><span class="hljs-meta">### `unsafe`</span><br><br>&gt;**Unsafe code**是一种绕过go类型安全和内存安全检查的Go代码。大多数情况，<span class="hljs-keyword">unsafe</span> code是和指针相关的。但是要记住使用<span class="hljs-keyword">unsafe</span> code有可能会损害你的程序，所以，如果你不完全确定是否需要用到<span class="hljs-keyword">unsafe</span> code就不要使用它。<br>&gt;<br>&gt;[关于go中的<span class="hljs-keyword">unsafe</span>包][https:<span class="hljs-comment">//studygolang.com/articles/22265]</span><br><br>Golang里面没有`warnning`这个说法啊，相比于C/C++，Golang里面一些危险的操作都是由`<span class="hljs-keyword">unsafe</span>`包提供。<br><br><span class="hljs-meta">#### `unsafe.Pointer`</span><br><br>我以前有一个疑问：既然指针代表的是地址，那为什么还要分类呢？原来，针区分类型是为了在通过指针访问它所指向的存储空间的时候，能够正确访问，如果通过一个<span class="hljs-built_in">char</span>类型的指针操作一个<span class="hljs-built_in">int</span>的变量，如果值的二进制数据超过<span class="hljs-number">1</span>字节，那么就造成数据错误。<br><br>我们先看如下例子：<br><br>```<span class="hljs-function">go</span><br><span class="hljs-function">func <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span> &#123;<br>	<span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> int64 = <span class="hljs-number">5</span><br>	<span class="hljs-keyword">var</span> p1 = &amp;<span class="hljs-keyword">value</span><br>	<span class="hljs-keyword">var</span> p2 = (*int32)(<span class="hljs-keyword">unsafe</span>.Pointer(p1))<br>	fmt.Println(p1)<br>	fmt.Println(p2)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">0xc00001e0d0</span><br><span class="hljs-number">0xc00001e0d0</span><br></code></pre></td></tr></table></figure>
<p>可以发现这两个指针所指向的地址是一样的，这个方法能让你创造一个<code>int32</code>的<code>p2</code>指针去指向一个<code>int64</code>的<code>value</code>变量，而这个变量是使用<code>p1</code>指针去访问的。我们通过以下例子来说明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">x := <span class="hljs-keyword">int32</span>(<span class="hljs-number">5</span>)<br><span class="hljs-keyword">var</span> p=(*<span class="hljs-keyword">byte</span>)(unsafe.Pointer(&amp;x))<br>s:=*p<br>fmt.Println(s)<br><span class="hljs-comment">//输出5</span><br></code></pre></td></tr></table></figure>
<p>但是从<code>byte</code>转换成<code>int32</code>的时候会出现问题：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">b:=<span class="hljs-string">&#x27;5&#x27;</span><br><span class="hljs-keyword">var</span> p=(*<span class="hljs-keyword">int32</span>)(unsafe.Pointer(&amp;b))<br>i:=*p<br>fmt.Println(i)<br><span class="hljs-comment">//输出53</span><br></code></pre></td></tr></table></figure>
<p>这是因为存放的<code>b</code>中存放的实际是ASCII码，故而转换成int时输出53。那么为什么转换成<code>byte</code>时就会输出5呢，我们用反射来看s的实际类型，显示是<code>uint8</code>，也就是说我们只是在这只是修改了指针类型 或者说只是修改了编译器解释他的类型。</p>
<h4 id="uintptr和unsafe-Pointer的区别"><a href="#uintptr和unsafe-Pointer的区别" class="headerlink" title="uintptr和unsafe.Pointer的区别"></a><code>uintptr</code>和<code>unsafe.Pointer</code>的区别</h4><p>uintptr本质是一个无符号的整型，它的长度可以用来保存一个指针地址。unsafe包提供的Pointer表示可以指向任意类型的指针。</p>
<p>uintptr往往用来进行指针计算，因为它是整型，所以很容易计算出下一个指针所指向的位置。</p>
<ul>
<li>unsafe.Pointer只是单纯的通用指针类型，用于转换不同类型指针，它不可以参与指针运算；</li>
<li>而uintptr是用于指针运算的，GC 不把 uintptr 当指针，也就是说 uintptr 无法持有对象， uintptr 类型的目标会被回收；</li>
<li>unsafe.Pointer 可以和 普通指针 进行相互转换；</li>
<li>unsafe.Pointer 可以和 uintptr 进行相互转换。</li>
</ul>
<h3 id="sync"><a href="#sync" class="headerlink" title="sync"></a><code>sync</code></h3><p>sync包中提供了常见的并发编程同步原语，所谓原语，一般是指由若干条指令组成的程序段，用来实现某个特定的功能，在执行过程中不可被中断，否则就会出现操作错误，造成系统混乱。</p>
<h4 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a><code>sync.Mutex</code></h4><p>sync.Mutex是sync包中使用最广泛的原语，它允许在共享资源上互斥访问。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> mutex <span class="hljs-keyword">struct</span>&#123;<br>	state	<span class="hljs-keyword">int32</span><br>	sema	<span class="hljs-keyword">uint32</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>上述是<code>mutex</code>的结构，<code>state</code>表示当前互斥锁的状态，<code>sema</code>是用于控制锁状态的信号量。在<code>state</code>中有一个标志位叫<code>mutexStarving</code>，表示当前的互斥锁是否进入了饥饿状态，在正常状态下，锁的等待者会按照先进先出的顺序获取锁；在饥饿模式下，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会切换回正常模式。</p>
<h5 id="sync-Mutex-Lock"><a href="#sync-Mutex-Lock" class="headerlink" title="sync.Mutex.Lock"></a><code>sync.Mutex.Lock</code></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span> <span class="hljs-title">Lock</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="hljs-number">0</span>, mutexLocked) &#123;<br>		<span class="hljs-keyword">return</span><br>	&#125;<br>	m.lockSlow()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这里用到原子操作CAS，常常被用于自旋机制，具体讲解在下面。当锁的状态是0时，就会将<code>mutexLocked</code>位置设置为1，如果互斥锁的状态不是0就会调用<code>lockSlow</code>尝试通过自旋等待锁的释放。</p>
<h5 id="sync-Mutex-Unlock"><a href="#sync-Mutex-Unlock" class="headerlink" title="sync.Mutex.Unlock"></a><code>sync.Mutex.Unlock</code></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span> <span class="hljs-title">Unlock</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)<br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">new</span> != <span class="hljs-number">0</span> &#123;<br>		m.unlockSlow(<span class="hljs-built_in">new</span>)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在<code>Unlock</code>中，用到了原子操作Add，这里这个原子操作的意思是：如果只是<code>mutexLocked</code>位为1，那么我们将state设置为0，return；否则，调用<code>UnlockSlow</code>进行缓慢解锁。也就是说如果有其他goroutine等待着，那么我们就会进入缓慢解锁的状态——移交锁的所有权给下一个goroutine。</p>
<h4 id="sync-RWMutex"><a href="#sync-RWMutex" class="headerlink" title="sync.RWMutex"></a><code>sync.RWMutex</code></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> RWMutex <span class="hljs-keyword">struct</span> &#123;<br>	w           Mutex  <span class="hljs-comment">// held if there are pending writers</span><br>	writerSem   <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// semaphore for writers to wait for completing readers</span><br>	readerSem   <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// semaphore for readers to wait for completing writers</span><br>	readerCount <span class="hljs-keyword">int32</span>  <span class="hljs-comment">// number of pending readers</span><br>	readerWait  <span class="hljs-keyword">int32</span>  <span class="hljs-comment">// number of departing readers</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们可以看到，<code>RWMutex</code>继承了<code>Mutex</code>，并且增加了几个成员。我们先来说说这几个成员：</p>
<ul>
<li><code>writerSem</code>：写者等待读者完成的信号量；</li>
<li><code>readerSem</code>：读者等待写者完成的信号量；</li>
<li><code>readerCount</code>：当前有几个读者共享锁；</li>
<li><code>readerWait</code>：离开的读者数。</li>
</ul>
<h5 id="Rlock-amp-RUnlock"><a href="#Rlock-amp-RUnlock" class="headerlink" title="Rlock&amp;RUnlock"></a><code>Rlock</code>&amp;<code>RUnlock</code></h5> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> &#123;<br>	<span class="hljs-comment">// A writer is pending, wait for it.</span><br>	runtime_SemacquireMutex(&amp;rw.readerSem, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如上述所示，上读锁的就是给<code>readerCount</code>+1，如果有写者占用，就</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="hljs-number">-1</span>); r &lt; <span class="hljs-number">0</span> &#123;<br>	<span class="hljs-comment">// Outlined slow-path to allow the fast-path to be inlined</span><br>	rw.rUnlockSlow(r)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如上述所示，解读锁就是给<code>readerCount</code>-1，如果有</p>
<h5 id="Lock-amp-Unlock"><a href="#Lock-amp-Unlock" class="headerlink" title="Lock&amp;Unlock"></a><code>Lock</code>&amp;<code>Unlock</code></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)<br><span class="hljs-keyword">if</span> r &gt;= rwmutexMaxReaders &#123;<br>	race.Enable()<br>	throw(<span class="hljs-string">&quot;sync: Unlock of unlocked RWMutex&quot;</span>)<br>&#125;<br><span class="hljs-comment">// Unblock blocked readers, if any.</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">int</span>(r); i++ &#123;<br>	runtime_Semrelease(&amp;rw.readerSem, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="sync-atomic"><a href="#sync-atomic" class="headerlink" title="sync/atomic"></a><code>sync/atomic</code></h4><blockquote>
<p>CPU执行一条汇编语句就是一个原子操作吗？</p>
</blockquote>
<p>原子操作是指不会被多线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会有任何context switch。原子操作是不可分割的，在执行完毕之前不会被任何其它任务或事件中断。在单处理器系统（<strong>UniProcessor</strong>）中，能够在单条指令中完成的操作都可以认为是” 原子操作”，因为中断只能发生于指令之间。</p>
<p>说到这里，我们来看看维基百科上对原子操作的判定：</p>
<blockquote>
<p>如果这个操作所处的层(layer)的更高层不能发现其内部实现与结构，那么这个操作是一个原子(atomic)操作。</p>
</blockquote>
<p>再看看其定义：</p>
<blockquote>
<p>原子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序不可以被打乱，也不可以被切割而只执行其中的一部分。将整个操作视作一个整体是原子性的核心特征。</p>
</blockquote>
<p>也就是说，绝大多数情况下，一个机器指令就是一个原子操作。在Intel的参考手册，CPU基于以下三种机制保证了多核中加锁的原子操作：</p>
<blockquote>
<p>（1）一些基本的内存读写操作是本身已经被硬件提供了原子性保证（例如读写单个字节的操作）；<br>（2）一些需要保证原子性但是没有被第（1）条机制提供支持的操作（例如read-modify-write）可以通过使用”LOCK#”来锁定总线，从而保证操作的原子性<br>（3）因为很多内存数据是已经存放在L1/L2 cache中了，对这些数据的原子操作只需要与本地的cache打交道，而不需要与总线打交道，所以CPU就提供了cache coherency机制来保证其它的那些也cache了这些数据的processor能读到最新的值。</p>
</blockquote>
<p>上面（1）就是由硬件保持的原子操作，具体来说有以下操作：</p>
<blockquote>
<p>• Reading or writing a byte（一个字节的读写）<br>• Reading or writing a word aligned on a 16-bit boundary（对齐到16位边界的字的读写）<br>• Reading or writing a doubleword aligned on a 32-bit boundary（对齐到32位边界的双字的读写）</p>
<p>• Reading or writing a quadword aligned on a 64-bit boundary（对齐到64位边界的四字的读写）<br>• 16-bit accesses to uncached memory locations that fit within a 32-bit data bus（未缓存且在32位数据总线范围之内的内存地址的访问）</p>
<p>• Unaligned 16-, 32-, and 64-bit accesses to cached memory that fit within a cache line（对单个cache line中缓存地址的未对齐的16/32/64位访问)</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/zeggpIOKJMRBmMOCRCsfhA">参考文章</a></p>
<p>下面我们再看看（2）总线锁。</p>
<h5 id="总线锁"><a href="#总线锁" class="headerlink" title="总线锁"></a>总线锁</h5><p>处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存当中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。</p>
<p>上述操作就是通过总线锁实现的，<strong>在x86 平台上，CPU提供了在指令执行期间对</strong>总线加锁的手段，这样能实现并行时的原子操作。</p>
<h5 id="Go支持的原子操作概述"><a href="#Go支持的原子操作概述" class="headerlink" title="Go支持的原子操作概述"></a>Go支持的原子操作概述</h5><p>Win32 API中常用的原子操作主要有三类，一种是加一减一操作，二是比较交换操作，三赋值操作。对于一个整数类型<code>T</code>，<code>sync/atomic</code>标准库包提供了下列原子操作函数。 其中<code>T</code>可以是内置<code>int32</code>、<code>int64</code>、<code>uint32</code>、<code>uint64</code>和<code>uintptr</code>类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddT</span><span class="hljs-params">(addr *T, delta T)</span><span class="hljs-params">(<span class="hljs-built_in">new</span> T)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadT</span><span class="hljs-params">(addr *T)</span> <span class="hljs-params">(val T)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StoreT</span><span class="hljs-params">(addr *T, val T)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SwapT</span><span class="hljs-params">(addr *T, <span class="hljs-built_in">new</span> T)</span> <span class="hljs-params">(old T)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CompareAndSwapT</span><span class="hljs-params">(addr *T, old, <span class="hljs-built_in">new</span> T)</span> <span class="hljs-params">(swapped <span class="hljs-keyword">bool</span>)</span></span><br></code></pre></td></tr></table></figure>
<p>我们看看<code>CompareAndSwap</code>的源码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><br></code></pre></td></tr></table></figure>
<p>Go语言的常量有个不同寻常之处。虽然一个常量可以有任意有一个确定的基础类型，例如int或float64，或者是类似time.Duration这样命名的基础类型，但是许多常量并没有一个明确的基础类型。编译器为这些没有明确的基础类型的数字常量提供比基础类型更高精度的算术运算；你可以认为至少有256bit的运算精度。这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。</p>
<p>panic需要等defer结束后才会向上传递。出现panic的时候，会先按照defer的**先出的顺序执行，最后才会执行panic。</p>
<h3 id="encoding-json"><a href="#encoding-json" class="headerlink" title="encoding/json"></a><code>encoding/json</code></h3><h4 id="Marshal"><a href="#Marshal" class="headerlink" title="Marshal"></a><code>Marshal</code></h4><h4 id="UnMarshal"><a href="#UnMarshal" class="headerlink" title="UnMarshal"></a><code>UnMarshal</code></h4>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/04/03/Golang%E4%B8%8EIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Golang与IO多路复用</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/12/go-map%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">
                        <span class="hidden-mobile">Go runtime</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  





  <script  src="https://unpkg.com/mermaid@9.0.1/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>







<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
