<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Golang_包解析</title>
    <link href="/2022/03/20/Golang-container/"/>
    <url>/2022/03/20/Golang-container/</url>
    
    <content type="html"><![CDATA[<h3 id="container"><a href="#container" class="headerlink" title="container"></a><code>container</code></h3><p>众所周知，Go对于一些基本的数据结构封装得不是很好，在<code>container</code>中也只有三种常见的数据结构——链表、环形链表和堆。</p><h4 id="container-list"><a href="#container-list" class="headerlink" title="container/list"></a><code>container/list</code></h4><p>我们先来看看<code>list</code>的写入与打印：</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs go">l := list.New()<br>l.PushBack(<span class="hljs-number">1</span>) <span class="hljs-comment">//尾插</span><br>l.PushBack(<span class="hljs-number">2</span>)<br>fmt.Println(l)<br></code></pre></td></tr></table></figure><p>我们看看打印结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">&amp;&#123;&#123;<span class="hljs-number">0xc00007c180</span> <span class="hljs-number">0xc00007c1b0</span> &lt;<span class="hljs-literal">nil</span>&gt; &lt;<span class="hljs-literal">nil</span>&gt;&#125; <span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure><p>为什么打印结果是这样的，如果我们弄懂<code>list</code>的底层结构，就能知道答案了。<code>list</code>的底层结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Element <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// Next and previous pointers in the doubly-linked list of elements.</span><br><span class="hljs-comment">// To simplify the implementation, internally a list l is implemented</span><br><span class="hljs-comment">// as a ring, such that &amp;l.root is both the next element of the last</span><br><span class="hljs-comment">// list element (l.Back()) and the previous element of the first list</span><br><span class="hljs-comment">// element (l.Front()).</span><br>next, prev *Element<br><br><span class="hljs-comment">// The list to which this element belongs.</span><br>list *List<br><br><span class="hljs-comment">// The value stored with this element.</span><br>Value <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// List represents a doubly linked list.</span><br><span class="hljs-comment">// The zero value for List is an empty list ready to use.</span><br><span class="hljs-keyword">type</span> List <span class="hljs-keyword">struct</span> &#123;<br>root Element <span class="hljs-comment">// sentinel list element, only &amp;root, root.prev, and root.next are used</span><br><span class="hljs-built_in">len</span>  <span class="hljs-keyword">int</span>     <span class="hljs-comment">// current list length excluding (this) sentinel element</span><br>&#125;<br></code></pre></td></tr></table></figure><p>结合上面的打印，我们可以发现，<code>&#123;0xc00007c180 0xc00007c1b0 &lt;nil&gt; &lt;nil&gt;&#125;</code> 是<code>root Element</code>，<code>2</code>是<code>len int</code>。我们接着打印：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">l := list.New()<span class="hljs-comment">//初始化</span><br>l.PushBack(<span class="hljs-number">1</span>) <span class="hljs-comment">//尾插</span><br>l.PushBack(<span class="hljs-number">2</span>)<br>fmt.Println(l.Front())<br>fmt.Println(l.Back())<br>fmt.Println(l)<br></code></pre></td></tr></table></figure><p>其打印结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">&amp;&#123;<span class="hljs-number">0xc00007c1b0</span> <span class="hljs-number">0xc00007c150</span> <span class="hljs-number">0xc00007c150</span> <span class="hljs-number">1</span>&#125;<br>&amp;&#123;<span class="hljs-number">0xc00007c150</span> <span class="hljs-number">0xc00007c180</span> <span class="hljs-number">0xc00007c150</span> <span class="hljs-number">2</span>&#125;<br>&amp;&#123;&#123;<span class="hljs-number">0xc00007c180</span> <span class="hljs-number">0xc00007c1b0</span> &lt;<span class="hljs-literal">nil</span>&gt; &lt;<span class="hljs-literal">nil</span>&gt;&#125; <span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure><p>从这个结果我们不难看出，<code>list</code>其实是一个环形结构。其中，<code>root</code>的next指向链表的<code>front</code>，<code>root</code>的pre指向链表的<code>back</code>，而<code>root</code>自身是不存储数据的。如果我们再加上一个数据，就会变成这样了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">l := list.New()<span class="hljs-comment">//初始化</span><br>l.PushBack(<span class="hljs-number">1</span>) <span class="hljs-comment">//尾插</span><br>l.PushBack(<span class="hljs-number">2</span>)<br>l.PushBack(<span class="hljs-number">3</span>)<br>fmt.Println(l.Front())<br>fmt.Println(l.Back())<br>fmt.Println(l)<br></code></pre></td></tr></table></figure><p>其打印结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">&amp;&#123;<span class="hljs-number">0xc00007c1b0</span> <span class="hljs-number">0xc00007c150</span> <span class="hljs-number">0xc00007c150</span> <span class="hljs-number">1</span>&#125;<br>&amp;&#123;<span class="hljs-number">0xc00007c150</span> <span class="hljs-number">0xc00007c1b0</span> <span class="hljs-number">0xc00007c150</span> <span class="hljs-number">3</span>&#125;<br>&amp;&#123;&#123;<span class="hljs-number">0xc00007c180</span> <span class="hljs-number">0xc00007c1e0</span> &lt;<span class="hljs-literal">nil</span>&gt; &lt;<span class="hljs-literal">nil</span>&gt;&#125; <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><h4 id="container-heap"><a href="#container-heap" class="headerlink" title="container/heap"></a><code>container/heap</code></h4><p>我们来看看如何初始化一个heap，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>name  <span class="hljs-keyword">string</span><br>score <span class="hljs-keyword">int</span><br>&#125;<br>h := &amp;StudentHeap&#123;<br>&#123;name: <span class="hljs-string">&quot;xiaoming&quot;</span>, score: <span class="hljs-number">82</span>&#125;,<br>&#123;name: <span class="hljs-string">&quot;xiaozhang&quot;</span>, score: <span class="hljs-number">88</span>&#125;,<br>&#123;name: <span class="hljs-string">&quot;laowang&quot;</span>, score: <span class="hljs-number">85</span>&#125;<br>&#125;<br>heap.Init(h)<br></code></pre></td></tr></table></figure><p>先来读读<code>Init()</code>函数，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Init</span><span class="hljs-params">(h Interface)</span></span> &#123;<br><span class="hljs-comment">// heapify</span><br>n := h.Len()<br><span class="hljs-keyword">for</span> i := n/<span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>down(h, i, n)<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">down</span><span class="hljs-params">(h Interface, i0, n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>i := i0<br><span class="hljs-keyword">for</span> &#123;<br>j1 := <span class="hljs-number">2</span>*i + <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> j1 &gt;= n || j1 &lt; <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// j1 &lt; 0 after int overflow</span><br><span class="hljs-keyword">break</span><br>&#125;<br>j := j1 <span class="hljs-comment">// left child</span><br><span class="hljs-keyword">if</span> j2 := j1 + <span class="hljs-number">1</span>; j2 &lt; n &amp;&amp; h.Less(j2, j1) &#123;<br>j = j2 <span class="hljs-comment">// = 2*i + 2  // right child</span><br>&#125;<br><span class="hljs-keyword">if</span> !h.Less(j, i) &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>h.Swap(i, j)<br>i = j<br>&#125;<br><span class="hljs-keyword">return</span> i &gt; i0<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这两个函数跟我们的堆排序很像，还是讲一下，</p><h4 id="container-ring"><a href="#container-ring" class="headerlink" title="container/ring"></a><code>container/ring</code></h4><blockquote><p>环的结构有点特殊，环的尾部就是头部，所以每个元素实际上就可以代表自身的这个环。 它不需要像 list 一样保持 list 和 element 两个结构，只需要保持一个结构就行。</p><p>——[1. 3.3 container — 容器数据类型：heap、list 和 ring][<a href="https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter03/03.3.html">https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter03/03.3.html</a>]</p></blockquote><p>我觉得这句话总结得很好，</p><h3 id="reflect"><a href="#reflect" class="headerlink" title="reflect"></a><code>reflect</code></h3><h4 id="reflect-DeepEqual"><a href="#reflect-DeepEqual" class="headerlink" title="reflect.DeepEqual"></a><code>reflect.DeepEqual</code></h4><p><code>DeepEqual</code>函数用来判断两个值是否深度一致。这和<code>==</code>有什么不同吗？我们来看看下面例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> S <span class="hljs-keyword">struct</span>&#123;<br>name <span class="hljs-keyword">string</span><br>    age <span class="hljs-keyword">int</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>     a := S&#123;<br>        name:    <span class="hljs-string">&quot;aa&quot;</span>,<br>        age:     <span class="hljs-number">1</span>,<br>    &#125;<br>    b := S&#123;<br>        name:    <span class="hljs-string">&quot;aa&quot;</span>,<br>        age:     <span class="hljs-number">1</span>,<br>    &#125;<br><br>   fmt.Println(a == b)<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>a==b</code>为<code>true</code>。如果我们将结构体中加入一个指针，就会返回false，这是因为指针指向的地址不一样，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> S <span class="hljs-keyword">struct</span> &#123;<br>    Name    <span class="hljs-keyword">string</span><br>    Age     <span class="hljs-keyword">int</span><br>    Address *<span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    a := S&#123;<br>        Name:    <span class="hljs-string">&quot;aa&quot;</span>,<br>        Age:     <span class="hljs-number">1</span>,<br>        Address: <span class="hljs-built_in">new</span>(<span class="hljs-keyword">int</span>),<br>    &#125;<br>    b := S&#123;<br>        Name:    <span class="hljs-string">&quot;aa&quot;</span>,<br>        Age:     <span class="hljs-number">1</span>,<br>        Address: <span class="hljs-built_in">new</span>(<span class="hljs-keyword">int</span>),<br>    &#125;<br><br>   fmt.Println(a == b)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这时会返回<code>false</code>。</p><p>值得注意的是：<code>slice</code>、<code>map</code>、<code>function</code>是不能参与比较的，如果在结构体中出现以上类型，会<code>panic</code>。在这里我们就有一个疑问？到底是什么原因导致<code>slice</code>、<code>map</code>、<code>function</code>不能进行比较，如果是因为引用类型的原因，<code>channel</code>却可以进行比较。我们先来看看比较<code>slice</code>的时候返回的错误，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">invalid operation: a == b (<span class="hljs-keyword">struct</span> containing []<span class="hljs-keyword">int</span> cannot be compared)<br></code></pre></td></tr></table></figure><p>有的博主说<code>slice</code>不可比较有两个原因：</p><ul><li>引用类型，比较地址没有意义。</li><li>切片有len，cap，比较的维度不好衡量，因此go设计的时候就不允许切片可比较。</li></ul><p>但是我们来看看这个情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> S <span class="hljs-keyword">struct</span> &#123;<br>Name    <span class="hljs-keyword">string</span><br>Age     <span class="hljs-keyword">int</span><br>Ch<span class="hljs-keyword">chan</span> []<span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := S&#123;<br>Name:    <span class="hljs-string">&quot;aa&quot;</span>,<br>Age:     <span class="hljs-number">1</span>,<br>Ch:      <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> []<span class="hljs-keyword">int</span>),<br>&#125;<br>b := S&#123;<br>Name:    <span class="hljs-string">&quot;aa&quot;</span>,<br>Age:     <span class="hljs-number">1</span>,<br>Ch:      <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> []<span class="hljs-keyword">int</span>),<br>&#125;<br><br>fmt.Println(a == b)<br>&#125;<br></code></pre></td></tr></table></figure><p>但是在<code>[]int</code>的<code>channel</code>是可以比较的，这就会比较迷惑。</p><p>回到正题，我们来看看<code>reflect.DeepEqual</code>，<code>reflect.DeepEqual</code>在可以时（主要是基本类型）会使用<code>==</code>；但还会比较<code>array</code>、<code>slice</code>的<strong>成员</strong>，<code>map</code>的<strong>键值对</strong>，<strong>结构体字段</strong>进行深入比对。如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m1 := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-number">1</span>: []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, <span class="hljs-number">2</span>: <span class="hljs-number">3</span>, <span class="hljs-number">3</span>: <span class="hljs-string">&quot;a&quot;</span>&#125;<br>m2 := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-number">1</span>: []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, <span class="hljs-number">2</span>: <span class="hljs-number">3</span>, <span class="hljs-number">3</span>: <span class="hljs-string">&quot;a&quot;</span>&#125;<br><span class="hljs-keyword">if</span> reflect.DeepEqual(m1, m2) &#123;<br>fmt.Println(<span class="hljs-string">&quot;相等&quot;</span>)<br>&#125;<br>&#125;<br><span class="hljs-comment">//输出”相等”</span><br></code></pre></td></tr></table></figure><p>当然，我们还是要从它的源码进行分析:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeepEqual</span><span class="hljs-params">(x, y <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> || y == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> x == y<br>&#125;<br>v1 := ValueOf(x)<br>v2 := ValueOf(y)<br><span class="hljs-keyword">if</span> v1.Type() != v2.Type() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">return</span> deepValueEqual(v1, v2, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[visit]<span class="hljs-keyword">bool</span>))<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们可以看到，如果<code>x==nil</code>或者<code>y==nil</code>，就比较二者的指针，否则比较二者的类型，如果类型相同，那么我们就用<code>deepValueEqual</code>函数进行比较。我们看到这个函数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp">```<br><br><span class="hljs-meta">### `unsafe`</span><br><br>&gt;**Unsafe code**是一种绕过go类型安全和内存安全检查的Go代码。大多数情况，<span class="hljs-keyword">unsafe</span> code是和指针相关的。但是要记住使用<span class="hljs-keyword">unsafe</span> code有可能会损害你的程序，所以，如果你不完全确定是否需要用到<span class="hljs-keyword">unsafe</span> code就不要使用它。<br>&gt;<br>&gt;[关于go中的<span class="hljs-keyword">unsafe</span>包][https:<span class="hljs-comment">//studygolang.com/articles/22265]</span><br><br><span class="hljs-meta">#### `unsafe.Pointer`</span><br><br>我以前有一个疑问：既然指针代表的是地址，那为什么还要分类呢？原来，针区分类型是为了在通过指针访问它所指向的存储空间的时候，能够正确访问，如果通过一个<span class="hljs-built_in">char</span>类型的指针操作一个<span class="hljs-built_in">int</span>的变量，如果值的二进制数据超过<span class="hljs-number">1</span>字节，那么就造成数据错误。<br><br>我们先看如下例子：<br><br>```<span class="hljs-function">go</span><br><span class="hljs-function">func <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> int64 = <span class="hljs-number">5</span><br><span class="hljs-keyword">var</span> p1 = &amp;<span class="hljs-keyword">value</span><br><span class="hljs-keyword">var</span> p2 = (*int32)(<span class="hljs-keyword">unsafe</span>.Pointer(p1))<br>fmt.Println(p1)<br>fmt.Println(p2)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">0xc00001e0d0</span><br><span class="hljs-number">0xc00001e0d0</span><br></code></pre></td></tr></table></figure><p>可以发现这两个指针所指向的地址是一样的，这个方法能让你创造一个<code>int32</code>的<code>p2</code>指针去指向一个<code>int64</code>的<code>value</code>变量，而这个变量是使用<code>p1</code>指针去访问的。我们通过以下例子来说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">x := <span class="hljs-keyword">int32</span>(<span class="hljs-number">5</span>)<br><span class="hljs-keyword">var</span> p=(*<span class="hljs-keyword">byte</span>)(unsafe.Pointer(&amp;x))<br>s:=*p<br>fmt.Println(s)<br><span class="hljs-comment">//输出5</span><br></code></pre></td></tr></table></figure><p>但是从<code>byte</code>转换成<code>int32</code>的时候会出现问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">b:=<span class="hljs-string">&#x27;5&#x27;</span><br><span class="hljs-keyword">var</span> p=(*<span class="hljs-keyword">int32</span>)(unsafe.Pointer(&amp;b))<br>i:=*p<br>fmt.Println(i)<br><span class="hljs-comment">//输出53</span><br></code></pre></td></tr></table></figure><p>这是因为存放的<code>b</code>中存放的实际是ASCII码，故而转换成int时输出53。那么为什么转换成<code>byte</code>时就会输出5呢，我们用反射来看s的实际类型，显示是<code>uint8</code>，也就是说我们只是在这只是修改了指针类型 或者说只是修改了编译器解释他的类型。</p><h4 id="uintptr和unsafe-Pointer的区别"><a href="#uintptr和unsafe-Pointer的区别" class="headerlink" title="uintptr和unsafe.Pointer的区别"></a><code>uintptr</code>和<code>unsafe.Pointer</code>的区别</h4><p>uintptr本质是一个无符号的整型，它的长度可以用来保存一个指针地址。unsafe包提供的Pointer表示可以指向任意类型的指针。</p><p>uintptr往往用来进行指针计算，因为它是整型，所以很容易计算出下一个指针所指向的位置。</p><ul><li>unsafe.Pointer只是单纯的通用指针类型，用于转换不同类型指针，它不可以参与指针运算；</li><li>而uintptr是用于指针运算的，GC 不把 uintptr 当指针，也就是说 uintptr 无法持有对象， uintptr 类型的目标会被回收；</li><li>unsafe.Pointer 可以和 普通指针 进行相互转换；</li><li>unsafe.Pointer 可以和 uintptr 进行相互转换。</li></ul><h3 id="sync"><a href="#sync" class="headerlink" title="sync"></a><code>sync</code></h3><p>sync包中提供了常见的并发编程同步原语，所谓原语，一般是指由若干条指令组成的程序段，用来实现某个特定的功能，在执行过程中不可被中断，否则就会出现操作错误，造成系统混乱。</p><h4 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a><code>sync.Mutex</code></h4><p>sync.Mutex是sync包中使用最广泛的原语，它允许在共享资源上互斥访问。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> mutex <span class="hljs-keyword">struct</span>&#123;<br>state<span class="hljs-keyword">int32</span><br>sema<span class="hljs-keyword">uint32</span><br>&#125;<br></code></pre></td></tr></table></figure><p>state表示当前互斥锁的状态，sema是用于控制锁状态的信号量。</p><h4 id="sync-atomic"><a href="#sync-atomic" class="headerlink" title="sync/atomic"></a><code>sync/atomic</code></h4><blockquote><p>CPU执行一条汇编语句就是一个原子操作吗？</p></blockquote><p>原子操作是指不会被多线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会有任何context switch。原子操作是不可分割的，在执行完毕之前不会被任何其它任务或事件中断。在单处理器系统（<strong>UniProcessor</strong>）中，能够在单条指令中完成的操作都可以认为是” 原子操作”，因为中断只能发生于指令之间。</p><p>说到这里，我们来看看维基百科上对原子操作的判定：</p><blockquote><p>如果这个操作所处的层(layer)的更高层不能发现其内部实现与结构，那么这个操作是一个原子(atomic)操作。</p></blockquote><p>再看看其定义：</p><blockquote><p>原子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序不可以被打乱，也不可以被切割而只执行其中的一部分。将整个操作视作一个整体是原子性的核心特征。</p></blockquote><p>也就是说，绝大多数情况下，一个机器指令就是一个原子操作。</p><h5 id="总线锁"><a href="#总线锁" class="headerlink" title="总线锁"></a>总线锁</h5><p>处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存当中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。</p><p>上述操作就是通过总线锁实现的，<strong>在x86 平台上，CPU提供了在指令执行期间对</strong>总线加锁的手段，这样能实现并行时的原子操作。</p><h5 id="Go支持的原子操作概述"><a href="#Go支持的原子操作概述" class="headerlink" title="Go支持的原子操作概述"></a>Go支持的原子操作概述</h5><p>Win32 API中常用的原子操作主要有三类，一种是加一减一操作，二是比较交换操作，三赋值操作。对于一个整数类型<code>T</code>，<code>sync/atomic</code>标准库包提供了下列原子操作函数。 其中<code>T</code>可以是内置<code>int32</code>、<code>int64</code>、<code>uint32</code>、<code>uint64</code>和<code>uintptr</code>类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddT</span><span class="hljs-params">(addr *T, delta T)</span><span class="hljs-params">(<span class="hljs-built_in">new</span> T)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadT</span><span class="hljs-params">(addr *T)</span> <span class="hljs-params">(val T)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StoreT</span><span class="hljs-params">(addr *T, val T)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SwapT</span><span class="hljs-params">(addr *T, <span class="hljs-built_in">new</span> T)</span> <span class="hljs-params">(old T)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CompareAndSwapT</span><span class="hljs-params">(addr *T, old, <span class="hljs-built_in">new</span> T)</span> <span class="hljs-params">(swapped <span class="hljs-keyword">bool</span>)</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>go map源码分析</title>
    <link href="/2022/03/12/go-map%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2022/03/12/go-map%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h3 id="Go-map"><a href="#Go-map" class="headerlink" title="Go map"></a>Go map</h3><h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><p>Go语言的map的底层实现基于Hash散列，Hash散列是一种著名的广义上的算法，它能将任意长度的数据映射到有限的值域当中。在实际工程中输入数据范围是无限的，而输出值域范围是有限的，因此必然存在不同的输入数据经过映射后得到相同的输出值，这种现象称为hash冲突，go底层通过链表解决hash冲突。值得注意的是：==Java1.8中使用平衡树来优化局部链表过长的性能问题。==</p><p>使用哈希表的目的就是要快速查找到目标key，然而，随着向map中添加的key越来越多，key发生碰撞的概率也越来越大，bucket中的8个cell会被逐渐塞满，插入、查找和删除key的效率也会越来越低，最理想的情况是bucket只装入一个key，这样，就能达到$O(1)$的效率，但这样空间消耗太大，代价太高。</p><p>底层源码如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A header for a Go map.</span><br><span class="hljs-keyword">type</span> hmap <span class="hljs-keyword">struct</span> &#123;<br>count     <span class="hljs-keyword">int</span> <span class="hljs-comment">// # live cells == size of map.  Must be first (used by len() builtin)</span><br>flags     <span class="hljs-keyword">uint8</span><br>B         <span class="hljs-keyword">uint8</span>  <span class="hljs-comment">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span><br>noverflow <span class="hljs-keyword">uint16</span> <br>hash0     <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// hash seed</span><br><br>buckets    unsafe.Pointer <span class="hljs-comment">// array of 2^B Buckets. may be nil if count==0.</span><br>oldbuckets unsafe.Pointer <span class="hljs-comment">// previous bucket array of half the size, non-nil only when growing</span><br>nevacuate  <span class="hljs-keyword">uintptr</span>        <span class="hljs-comment">// progress counter for evacuation (buckets less than this have been evacuated)</span><br><br>extra *mapextra <span class="hljs-comment">// optional fields</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>buckets unsafe.Pointer</code>指向具体的buckets数组，这个数组是<code>bmap</code>结构，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A bucket for a Go map.</span><br><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>tophash [bucketCnt]<span class="hljs-keyword">uint8</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在实际编译期间，Go语言的<code>bmap</code>会经过反射生成真正的<code>bmap</code>类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>  topbits  [<span class="hljs-number">8</span>]<span class="hljs-keyword">uint8</span><br>  keys     [<span class="hljs-number">8</span>]keytype<br>  values   [<span class="hljs-number">8</span>]valuetype<br>  pad      <span class="hljs-keyword">uintptr</span><br>  overflow <span class="hljs-keyword">uintptr</span><br>&#125;<br></code></pre></td></tr></table></figure><p>map的访问即通过给定的key在map中寻找其对应value，过程如下：</p><ol><li>原始的key通过hash函数映射成64位二进制；</li><li>末尾x位代表<code>bmap</code>的位置，从<code>[]bmap</code>中找到对应的<code>bmap</code>，值得注意的是，bmap的数量一般是2的幂，如果末尾x位代表<code>bmap</code>的位置就代表有$2^x$个<code>bmap</code>；</li><li>首8位对应key的tophash，在bmap中进行检索，首先会比较<code>bmap</code>顶层的<code>tophash</code>与原始key的<code>tophash</code>是否相同，若不相同则直接跳过比较下一个；若相同则进一步比较key是否相同。</li></ol><h3 id="Go-panic"><a href="#Go-panic" class="headerlink" title="Go panic"></a>Go panic</h3><p>大多数编程语言都提供了异常处理机制，恰恰相反，Go延续了C语言的风格，并未提供异常处理机制。但在Go中，提供了panic异常，从某种意义上说，它也非常接近其他语言的异常处理。</p><p>Go语言在编译期间就能捕获大量异常，但是有些异常只能发生在运行期间，比如运行期间的除以0的异常，数组越界错误等。</p><p>除了程序本身的问题导致panic异常外，也可以直接在程序里调用panic函数引发panic异常。panic函数原型如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">panic</span><span class="hljs-params">(v <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br></code></pre></td></tr></table></figure><p>当我们直接调用panic函数时就会引发程序panic异常。如下面例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;f(%d)\n&quot;</span>, x+<span class="hljs-number">0</span>/x) <span class="hljs-comment">// 当参数为 0 时，引发 panic 异常</span><br>    <span class="hljs-keyword">defer</span> fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, x)<br>    f(x - <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    f(<span class="hljs-number">3</span>)<br>    fmt.Println(<span class="hljs-string">&quot;end&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>当程序panic异常发生时，程序会中断运行，并执行panic异常中的所有deferred函数。例如，当程序窒息你个f(0)时，引发除0错误，此时外层调用f(0)的函数f(1)里会执行defer，当然，panic异常会向外传递，知道所有的deferred函数全部执行完。</p>]]></content>
    
    
    <categories>
      
      <category>Go语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT_6.s081_Lab6_Copy-on-Write Fork for xv6</title>
    <link href="/2022/02/24/6-s081-Lab6-Copy-on-Write-Fork-for-xv6/"/>
    <url>/2022/02/24/6-s081-Lab6-Copy-on-Write-Fork-for-xv6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>早期的fork()实现较为“简单粗暴”，会将父进程的物理内存完整拷贝一份，并映射到子进程的内存空间中，这种方式在很多情况下是不必要的，一部分虚拟内存是只读的，对他们进行拷贝是一种浪费，其次，由于进程有时会在调用fork函数之后立即调用exec以载入新的可执行文件，重置地址空间，之前的内存拷贝就完全失去了意义。因此可以用写时拷贝技术来对fork的实现进行优化。对于本来就是只读的虚拟页，父进程和子进程可以共享这些页，减少了拷贝的开销。但对于容易发生变化的虚拟页，如果出现了写操作，就会触发写时拷贝。</p><p>——陈海波《现代操作系统：原理与实现》</p></blockquote><p>当两个进程拥有很多相同的内存数据，如果把这些数据相同的内存页在物理内存中仅存储一份，然后以只读的方式映射给两个应用程序，那么就能显著地节约物理内存资源。如下图所示：</p><p><img src="https://tvax1.sinaimg.cn/large/008qL1EEly1h05xrbw45dj30jd0733zx.jpg" alt=""></p><p><img src="https://tva2.sinaimg.cn/large/008qL1EEly1h06gliq9t9j30kr08owgq.jpg" alt=""></p><p>PTE除了记录物理页号，还记录了别的信息，我们回忆实验3里面讲的，PTE中有一些标志位，用来表示虚拟页的权限的权限位。写时拷贝正是利用表示“是否可写”的权限位来实现的。</p><p><code>COW fork()</code>只为孩子创建一个页表，用户内存的 PTE 指向父级的物理页面。<code>COW fork()</code>将 parent 和 child 中的所有用户 PTE 标记为不可写。当任一进程尝试写入这些 COW 页之一时，CPU 将强制发生页错误。内核页面错误处理程序检测到这种情况，为出错进程分配物理内存页面，将原始页面复制到新页面中，并修改出错进程中的相关 PTE 以引用新页面，这次使用PTE 标记为可写。当页面错误处理程序返回时，用户进程将能够写入它的页面副本。</p><p>值得注意的是：<font color=#FF0000>当多个用户进程的虚拟内存都指向相同的物理内存page，父进程退出的时候我们要更加小心，因为我们要判断是否能立即释放相应的物理page，因为子进程可能同样会用到这个物理内存所存储的数据。</font>这个时候我们要引入引用计数器<code>count</code>，当物理内存的引用数为0的时候，我们就能释放这个物理页表了。</p><hr><p>值得注意的是，在linux中有一个<code>vfork()</code>，可以用来解决创建子进程后又马上调用<code>exec()</code>函数的情况，与<code>fork</code>函数一样，<code>vfork</code>函数也是用来创建子进程的。且该函数创建出的子进程与父进程共用一个地址空间。</p><hr><p>我们需要修改<code>uvmcopy()</code>，在复制副进程的内存到子进程的时候，不立即进行复制数据，而是建立指向原物理页的映射，并将父子两端的页表项都设置为不可写。</p><p>我们首先看到<code>sys_fork</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">sys_fork</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> fork();<br>&#125;<br></code></pre></td></tr></table></figure><p>这个<code>fork</code>函数如下所示，我将自己的理解写在了注释中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">fork</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, pid;<br>  <span class="hljs-comment">//新建proc</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">np</span>;</span><br>  <span class="hljs-comment">//准备好当前的proc,用来复制</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-comment">// Allocate process.</span><br>  <span class="hljs-keyword">if</span>((np = allocproc()) == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Copy user memory from parent to child.</span><br>  <span class="hljs-comment">//分配内存</span><br>  <span class="hljs-keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="hljs-number">0</span>)&#123;<br>    freeproc(np);<br>    release(&amp;np-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  np-&gt;sz = p-&gt;sz;<br><br>  <span class="hljs-comment">// copy saved user registers.</span><br>  *(np-&gt;trapframe) = *(p-&gt;trapframe);<br><br>  <span class="hljs-comment">// Cause fork to return 0 in the child.</span><br>  np-&gt;trapframe-&gt;a0 = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// increment reference counts on open file descriptors.</span><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; NOFILE; i++)<br>    <span class="hljs-keyword">if</span>(p-&gt;ofile[i])<br>      np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);<br>  np-&gt;cwd = idup(p-&gt;cwd);<br>  <br>  safestrcpy(np-&gt;name, p-&gt;name, <span class="hljs-keyword">sizeof</span>(p-&gt;name));<br>  <br>  pid = np-&gt;pid;<br><br>  release(&amp;np-&gt;lock);<br>  <span class="hljs-comment">//获取锁</span><br>  acquire(&amp;wait_lock);<br>  <br>  np-&gt;parent = p;<br>  release(&amp;wait_lock);<br><br>  acquire(&amp;np-&gt;lock);<br>  np-&gt;state = RUNNABLE;<br>  <br>  release(&amp;np-&gt;lock);<br>  <span class="hljs-comment">//返回进程id</span><br>  <span class="hljs-keyword">return</span> pid;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们先来说说进程的<code>state</code>字段：</p><p>A question about the <code>fork</code> function</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">procstate</span> &#123;</span> UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;<br><span class="hljs-comment">//未运行、已运行（终止）、阻塞、就绪、运行、僵死</span><br></code></pre></td></tr></table></figure><blockquote><p>英文术语<em>zombie process</em>源自丧尸——不死之人，隐喻子进程已死但仍然没有被回收。与正常进程不同，<code>kill</code>命令对僵尸进程无效。</p></blockquote><p>在类Unix系统中，僵死进程是指完成执行，但在操作系统进程表中仍然存在其进程控制块，处于”终止状态“的进程。</p><p>下面是一个进程僵死的例子，解释在注释中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">pid_t</span> pids[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">int</span> i;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">9</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>pids[i] = fork();<br><span class="hljs-keyword">if</span> (pids[i] == <span class="hljs-number">0</span>) &#123;<br>sleep(i+<span class="hljs-number">1</span>);<br>_exit(<span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">9</span>; i &gt;= <span class="hljs-number">0</span>; --i)<br>waitpid(pids[i], <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>kernel/proc.c</code>的<code>fork</code>函数中，我们会将子进程设置为<code>RUNNABLE</code>状态，也就是拿到当前的就绪队列中，等待调度了，值得注意的是，在对<code>np</code>的状态进行状态赋值的时候我们会上锁，为什么呢？</p><p>我们来看看<code>kernel/proc.c</code>中的<code>proc</code>函数，调用了<code>uvmcopy</code>函数，将父进程的页表以及内存拷贝到子进程，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Copy user memory from parent to child.</span><br><span class="hljs-keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//将副进程的页表拷贝</span><br>  freeproc(np);<span class="hljs-comment">//释放一个proc结构和挂在它上面的数据</span><br>  release(&amp;np-&gt;lock);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>np-&gt;sz = p-&gt;sz;<br></code></pre></td></tr></table></figure><p><code>uvmcopy</code>函数如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">uvmcopy</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> old, <span class="hljs-keyword">pagetable_t</span> <span class="hljs-keyword">new</span>, uint64 sz)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">pte_t</span> *pte;<br>  uint64 pa, i;<br>  uint flags;<br>  <span class="hljs-keyword">char</span> *mem;<br><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; sz; i += PGSIZE)&#123;<br>    <span class="hljs-keyword">if</span>((pte = walk(old, i, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 如果一个页不存在，则认为是懒加载的页，忽略即可</span><br>    <span class="hljs-keyword">if</span>((*pte &amp; PTE_V) == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 如果一个页不存在，则认为是懒加载的页，忽略即可</span><br>    pa = PTE2PA(*pte);<br>    flags = PTE_FLAGS(*pte);<br>    <span class="hljs-comment">//if((mem = kalloc()) == 0)</span><br>      <span class="hljs-comment">//goto err;</span><br>    <span class="hljs-comment">//memmove(mem, (char*)pa, PGSIZE);</span><br>    <span class="hljs-keyword">if</span>(mappages(<span class="hljs-keyword">new</span>, i, PGSIZE, (uint64)mem, flags) != <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-comment">//kfree(mem);</span><br>      <span class="hljs-keyword">goto</span> err;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br> err:<br>  uvmunmap(<span class="hljs-keyword">new</span>, <span class="hljs-number">0</span>, i / PGSIZE, <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT_s.081_Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT_6.s081_Lab5_lazy page allocation</title>
    <link href="/2022/02/21/MIT-6-s081-Lab5-lazy-page-allocation/"/>
    <url>/2022/02/21/MIT-6-s081-Lab5-lazy-page-allocation/</url>
    
    <content type="html"><![CDATA[<h4 id="Eliminate-allocation-from-sbrk"><a href="#Eliminate-allocation-from-sbrk" class="headerlink" title="Eliminate allocation from sbrk()"></a>Eliminate allocation from sbrk()</h4><p>我们知道，sbrk()分配物理内存并将其映射到进程的虚拟地址空间，内核为大型请求分配和映射内存可能需要很长时间。</p><p>本实验你的任务是修改 <code>sys_sbrk()</code>使得其只增加/减少进程地址空间大小，而不真正地分配页面。sbrk是xv6提供的系统调用，它使得用户应用程序能扩大自己的heap。当一个应用程序启动的时候，<code>sbrk</code>指向的是heap的最底端，同时也是stack的最顶端，这也正是我们proc结构中的<code>p-&gt;sz</code>(详情见xv6实验参考书)。我们都知道stack是从下往上的，所以当调用<code>sbrk</code>函数的时候，<code>sbrk</code>会扩展stack的上边界。</p><p>在xv6中，<code>sbrk</code>的实现默认是eager allocation，一旦调用了<code>sbrk</code>，内核就会立即分配物理内存给进程。但这样有点浪费，我们可以利用lazy allocation来做，<code>sbrk</code>基本不做任何事，只是改变<code>p-&gt;se</code>的大小，将<em>p-&gt;sz</em>增加n，其中n是需要新分配的内存page数量。但是内核在这个时间点并不会分配任何物理内存。</p><p>我们先来看看原版本：</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">sys_sbrk</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> addr;<br>  <span class="hljs-keyword">int</span> n;<br><br>  <span class="hljs-keyword">if</span>(argint(<span class="hljs-number">0</span>, &amp;n) &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">//检测传入的参数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  addr = myproc()-&gt;sz;<span class="hljs-comment">//uint64 sz,Size of process memory (bytes)</span><br>  <span class="hljs-keyword">if</span>(growproc(n) &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">//分配n个bytes</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">return</span> addr;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看看growproc函数，就知道为什么要这么做了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Grow or shrink user memory by n bytes.</span><br><span class="hljs-comment">// Return 0 on success, -1 on failure.</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">growproc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  uint sz;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  sz = p-&gt;sz;<br>  <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>((sz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span>)&#123;<br>    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);<br>  &#125;<br>  p-&gt;sz = sz;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>大家看，在上述函数中，使用uvmalloc函数是会为这个进程的虚拟地址分配实际的物理内存的。</p><p>在sys_sbrk()函数中，用来分配页面的是growproc函数，我们直接修改这部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">uint new_addr=addr+n;<span class="hljs-comment">//直接把地址+n，分配虚拟地址</span><br>myproc()-&gt;sz=newaddr;<br></code></pre></td></tr></table></figure><p>然后对new_addr控制在合理的范围之内范围：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(newaddr&gt;=MAXVA||newaddr&lt;=<span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">return</span> addr;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Lazy-allocation"><a href="#Lazy-allocation" class="headerlink" title="Lazy allocation"></a>Lazy allocation</h4><p>本实验中，你的目标是修改trap.c和其他地方的代码，使得在你的代码能够在缺页时分配一块新的内存并建立映射。</p><p>page fault可以让地址映射关系变得动态起来，这也是我们实现lazy allocation的关键。当发生page fault的时候，xv6内核会打印出错的虚拟地址，并且会将这个地址保存在STVAL寄存器中，所以，当一个用户应用程序出发了page fault，程序会切换到内核，同时将出错的地址存放在STVAL寄存器中。</p><p>对于不同的场景page falut有不同的响应，比如，13表示是因为load引起的page fault；15表示是因为store引起的page fault；12表示是因为指令执行引起的page fault。</p><h5 id="缺页处理"><a href="#缺页处理" class="headerlink" title="缺页处理"></a>缺页处理</h5><p>我们可以先检查是否为缺页错误。当我们看到了一个page fault，相应的虚拟地址小于当前<em>p-&gt;sz</em>，同时大于stack，那么我们就知道这是一个来自于heap的地址，但是内核还没有分配任何物理内存。所以对于这个page fault的响应也理所当然的直接明了：在page fault handler中，通过kalloc函数分配一个内存page；初始化这个page内容为0；将这个内存page映射到user page table中；最后重新执行指令。比方说，如果是load指令，或者store指令要访问属于当前进程但是还未被分配的内存，在我们映射完新申请的物理内存page之后，重新执行指令应该就能通过了。</p><p>在usertrap函数中，我们可以为缺页异常添加检测，如果缺页异常，且其原因是我们的lazy alloction的话，我们就可以为其分配物理内存，并在页表建立映射，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>((r_scause() == <span class="hljs-number">13</span> || r_scause() == <span class="hljs-number">15</span>) &amp;&amp; trap_by_lazyllocation)&#123; <span class="hljs-comment">// 缺页异常，并且发生异常的地址进行过懒分配</span><br>      <span class="hljs-comment">// 分配物理内存，并在页表创建映射</span><br>   &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果不是缺页异常，或者是在非懒加载地址上发生缺页异常，则抛出错误并杀死进程</span><br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);<br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());<br>     p-&gt;killed = <span class="hljs-number">1</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>那么我们如何检测是否是lazy allocation导致的错误呢？我们需要定义一个函数<code>trap_by_lazyallocation</code>，其实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64 va = r_stval();<span class="hljs-comment">//获取栈指针</span><br><span class="hljs-keyword">if</span>(va&lt;p-&gt;sz)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说，当我们的这个要访问的页面小于进程的整个逻辑内存的页面的数量时，说明是缺页的。但是测试之后发现不对，我们再次修改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">((pte = walk(p-&gt;pagetable, va, <span class="hljs-number">0</span>))==<span class="hljs-number">0</span>) || ((*pte &amp; PTE_V)==<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>我们还要va映射不能进入pagetable，这样才能做到检验。那么我们怎样分配呢？</p><p>我们可以通过<code>uvmalloc</code>函数来做到分配物理页面，先来看看<code>uvmalloc</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">uvmalloc</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> *mem;<br>  uint64 a;<br><br>  <span class="hljs-keyword">if</span>(newsz &lt; oldsz)<br>    <span class="hljs-keyword">return</span> oldsz;<br><br>  oldsz = PGROUNDUP(oldsz);<br>  <span class="hljs-keyword">for</span>(a = oldsz; a &lt; newsz; a += PGSIZE)&#123;<br>    mem = kalloc();<br>    <span class="hljs-keyword">if</span>(mem == <span class="hljs-number">0</span>)&#123;<br>      uvmdealloc(pagetable, a, oldsz);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(mem, <span class="hljs-number">0</span>, PGSIZE);<br>    <span class="hljs-keyword">if</span>(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="hljs-number">0</span>)&#123;<br>      kfree(mem);<br>      uvmdealloc(pagetable, a, oldsz);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> newsz;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们仿照上述的<code>uvmalloc</code>函数来编写下面的<code>uvm_lazy</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">memset</span>(mem, <span class="hljs-number">0</span>, PGSIZE);<br>mappages(p-&gt;pagetable, PGROUNDDOWN(va), PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U)<br></code></pre></td></tr></table></figure><p>这样就差不多了。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT_s.081_Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU_15-445_PROJECT#2</title>
    <link href="/2022/02/15/CMU-15-445-PROJECT-2/"/>
    <url>/2022/02/15/CMU-15-445-PROJECT-2/</url>
    
    <content type="html"><![CDATA[<p>这个实验2真的是折磨死我了。</p><h4 id="Tree-Index"><a href="#Tree-Index" class="headerlink" title="Tree Index"></a>Tree Index</h4><p>索引是对数据库表中一个或多个列进行排序的结构，是帮助数据库高效查询数据的数据结构。</p><p>与hash table相比，hash table的时间复杂度是$O(1)$，最坏的时间复杂度是$O(n)$。在B+ Tree中，因为它是平衡的，所以它的时间复杂度始终是$O(log n)$，也就是说，对于一个叶子结点上的任何key来说，不管它距离根节点有多远，时间复杂度始终是$O(logn)$，不管我们删除多少次，插入多少次，修改周围的东西，它始终是$O(logn)$。对于一个多路查找树（M-way search tree）而言，在树中的每个节点处，它可以通过$&gt;=M$条不同的路线到达其他节点，它是完美平衡的，当我在对树进行修改时，该数据结构会始终保持平衡性，也就是说任何叶子节点到根节点始终是$O(logn)$，我们还要维护的一件事是，保证每个节点至少都是半满的状态。</p><h5 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h5><p>B树是一种多路平衡查找树，其定义如下：</p><ul><li>每个节点最多有m-1个关键字</li><li>根节点最少可以只有1个关键字</li><li>非根节点至少有m/2个关键字</li><li>每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它</li><li>所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同</li><li>每个节点都存有索引和数据，也就是对应的key和value</li></ul><p>所以，根节点的关键字数量范围：$1&lt;=k&lt;=m-1$，非根节点的关键字数量范围：$m/2&lt;=k&lt;=m-1$，其中m为阶数，表示了一个节点最多有多少个孩子节点。比如有一个5阶的B树，根节点数量范围：$1&lt;=k&lt;=4$，非根节点数量范围：$2&lt;=k&lt;=4$。</p><h6 id="B树插入操作"><a href="#B树插入操作" class="headerlink" title="B树插入操作"></a>B树插入操作</h6><p>插入的时候，我们需要记住一个规则：判断当前节点key的个数是否小于等于m-1，如果满足，直接插入即可，如果不满足，用节点的中间key将这个节点分为左右两部分，中间的节点放到父节点中即可。如下例子（例子来源于<a href="https://segmentfault.com/a/1190000020416577">博客</a>)：</p><p>在5阶B树中，节点最多有4个key，最少有2个key。</p><ul><li><p>插入18，70，50，40</p><p><img src="http://tvax4.sinaimg.cn/large/008qL1EEly1gzgq69nxvwj309h02nwel.jpg" alt=""></p></li><li><p>插入22</p><p><img src="http://tvax4.sinaimg.cn/large/008qL1EEly1gzgqdxtu0ij309t02tglt.jpg" alt=""></p></li></ul><p>插入22时，发现这个节点的关键字已经大于4了，所以需要进行分裂，分裂的规则在上面已经讲了。分裂之后如下：</p><p><img src="http://tva3.sinaimg.cn/large/008qL1EEly1gzgq69sd1nj30cj05zaau.jpg" alt=""></p><ul><li><p>接着插入23，25，39</p><p><img src="http://tva1.sinaimg.cn/large/008qL1EEly1gzgqivcxnhj30g605egmn.jpg" alt=""></p></li><li><p>分裂之后如下：</p><p><img src="http://tva4.sinaimg.cn/large/008qL1EEly1gzgqf9hz9xj30fv07mjss.jpg" alt=""></p></li></ul><h6 id="B树删除操作"><a href="#B树删除操作" class="headerlink" title="B树删除操作"></a>B树删除操作</h6><p>B树的删除操作相对于一个插入操作是相对复杂一些的，如下面例子：</p><ul><li><p>现在有一个初始状态是下面这样的B树，然后进行删除操作：</p><p><img src="http://tva3.sinaimg.cn/large/008qL1EEly1gzgqkj96wuj30kc09z777.jpg" alt=""></p></li><li><p>删除15，这种情况是删除叶子节点的元素，如果删除之后，节点数还是大于m/2，这种情况只要直接删除即可。</p><p><img src="http://tvax3.sinaimg.cn/large/008qL1EEly1gzgqkj96wuj30kc09z777.jpg" alt=""></p></li></ul><p>​    <img src="http://tvax1.sinaimg.cn/large/008qL1EEly1gzgqn1jtv6j30kc097wh4.jpg" alt=""></p><ul><li><p>接着，我们把22删除，这种情况的规则，22是非叶子节点，对于非叶子节点的删除，我们需要用后继key（元素）覆盖要删除的key，然后在后续key所在的子支中删除该后继key。对于删除22，需要将后继元素24移动到被删除的22所在的节点。对于删除22,需要将后继元素24移到被删除的22所在的节点。</p><p><img src="http://tvax3.sinaimg.cn/large/008qL1EEly1gzgqngoe2bj30kc0bdwi0.jpg" alt=""></p><p><img src="http://tvax2.sinaimg.cn/large/008qL1EEly1gzgqngtxitj30kc092dij.jpg" alt=""></p></li><li><p>此时我们发现26所在的节点只有一个元素，小于2（m/2)个，这个节点不符合要求，这时候的规则就是向兄弟节点借元素，如下图所示：</p><p><img src="http://tva2.sinaimg.cn/large/008qL1EEly1gzgqot9ctcj30kc092q5y.jpg" alt=""></p></li><li><p>移动之后，跟兄弟节点合并</p><p><img src="http://tvax4.sinaimg.cn/large/008qL1EEly1gzgqotdmt2j30kc09476w.jpg" alt=""></p></li></ul><h5 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h5><p>B+树其实和B树是非常相似的，我们可以看看相同点。</p><ul><li>根节点至少一个元素</li><li>非跟节点元素范围：$m/2&lt;=k&lt;=m-1$</li></ul><h6 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h6><ul><li>B+树有两种类型的节点：内部节点和叶子节点，内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。</li><li>内部节点的key都按照从小到大的顺序排列，对于内部节点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子节点中的记录也按照key的大小排列。</li><li>每个叶子节点都存有相邻叶子节点的指针，叶子节点本身依关键字的大小自小而大顺序链接。</li><li>父节点存有右孩子第一个元素的索引。</li></ul><p>如下图所示：</p><p><img src="http://tva3.sinaimg.cn/large/008qL1EEly1gzgqqllp4vj30hg09y411.jpg" alt=""></p><h6 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h6><p>对于插入操作很简单，只需要记住一个技巧即可：当节点元素数量大于m-1的时候，按中间元素分裂成左右两部分，中间元素分裂到父节点当作索引存储，但是，本身中间元素还是分裂右边这一部分。</p><p>下面以一颗5阶B+树的插入过程为例，5阶B+树的节点最少2个元素，最多4个元素。</p><ul><li><p>插入5，10，15，20</p><p><img src="http://tva2.sinaimg.cn/large/008qL1EEly1gzgqqlox85j309s04a0t2.jpg" alt=""></p></li><li><p>插入25，此时元素数量大于4个了，分裂</p><p><img src="http://tva3.sinaimg.cn/large/008qL1EEly1gzgqqmspi7j30f206qab4.jpg" alt=""></p></li><li><p>接着插入26，30，继续分裂</p><p><img src="http://tvax3.sinaimg.cn/large/008qL1EEly1gzgqqo09usj30gq065my9.jpg" alt=""></p></li></ul><p>​    <img src="http://tvax1.sinaimg.cn/large/008qL1EEly1gzgqqpbi2yj30j306x75u.jpg" alt=""></p><h6 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h6><p>对于删除操作是比B树简单一些的，因为叶子节点有指针的存在，向兄弟节点借元素时，不需要通过父节点了，而是可以通过兄弟节点移动即可（前提是兄弟节点的元素大于m/2），然后更新父节点的索引；如果兄弟节点的元素不大于m/2（兄弟节点也没有多余的元素），则将当前节点和兄弟节点合并，并且删除父节点中的key，下面我们看看具体的实现：</p><ul><li><p>初始状态</p><p><img src="http://tvax3.sinaimg.cn/large/008qL1EEly1gzgqqqrlisj30kc06rdi1.jpg" alt=""></p></li><li><p>删除10，删除后，不满足要求，发现左边兄弟节点有多余的元素，所以去借元素，最后，修改父节点索引。</p><p><img src="http://tvax1.sinaimg.cn/large/008qL1EEly1gzgqqs09qyj30kc06sq54.jpg" alt=""></p></li><li><p>删除元素5，发现不满足要求，并且发现左右兄弟节点都没有多余的元素，所以，可以选择和兄弟节点合并，最后修改父节点索引。</p><p><img src="http://tva1.sinaimg.cn/large/008qL1EEly1gzgqqtk9yvj30kc07wmzg.jpg" alt=""></p></li><li><p>发现父节点索引也不满足条件，所以，需要做跟上面一步一样的操作</p><p><img src="http://tva1.sinaimg.cn/large/008qL1EEly1gzgqqvn3nkj30kc080wgw.jpg" alt=""></p></li></ul><p>B+树相对于B树有一些优势，如下：</p><ul><li>单一节点存储的元素更多，使得查询的IO次数更多，所以也就使得它更适合作为数据库MySQL的底层数据结构。</li><li>所有的查询都要查找到叶子节点，查询性能是稳定的，而B树每个节点都可以查找到数据，所以不稳定。</li><li>所有的叶子节点形成了一个有序链表，更便于查找。</li><li>B+树的空间利用率更高，可减少I/O次数，磁盘读写代价更低。</li><li>增删文件时，效率更高，因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可以很好的增删效率。</li></ul><h5 id="PostgreSQL中的B-树"><a href="#PostgreSQL中的B-树" class="headerlink" title="PostgreSQL中的B+树"></a>PostgreSQL中的B+树</h5><p>现在几乎所有有关PostgreSQL的文档描述PostgreSQL底层结构都是用的B-树这个名词。但我们学了Andy教授的课程都知道，其实这里的B-树是指的B+树。</p><h5 id="InnoDB中的B-树"><a href="#InnoDB中的B-树" class="headerlink" title="InnoDB中的B+树"></a>InnoDB中的B+树</h5><p>存储引擎（Storage engine）：MySQL中的数据，索引以及其他对象是如何存储的，是一套文件系统的实现。</p><p>在InnoDB引擎中，提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。</p><p>让我们把视角放到宏观，InnoDB会通过index来实现行锁，如：</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs c">select * from tab_with_index where id = <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> update;<br></code></pre></td></tr></table></figure><p>id是有索引的列，如果id不是索引键那么InnoDB将完成表锁。</p><hr><p>在这里插入红黑树：</p><p>要理解红黑树，我觉得还是要和二叉搜索树、AVL树结合起来理解。</p><p>我们都知道，二叉搜索树的性质是顺序存储，缺点是不平衡，在极端情况下会变成链表；AVL树的性质是平衡，如果我们将二者的性质结合起来，就成了红黑树的雏形，红黑树按照顺序存储，还可以保持一定的平衡（放弃了AVL树绝对平衡的性质，而是根据自身红黑的性质保持相对平衡，插入与删除时会比AVL树更方便），这样就稳定了查询时间。</p><p>红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质：</p><p>性质1：每个节点要么是黑色，要么是红色。</p><p>性质2：根节点是黑色。</p><p>性质3：每个叶子节点（NIL）是黑色。 </p><p>性质4：每个红色结点的两个子结点一定都是黑色。</p><p>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。（保证这棵树尽量是平衡的。）</p><hr><h5 id="TASK-1-B-TREE-PAGES"><a href="#TASK-1-B-TREE-PAGES" class="headerlink" title="TASK #1 - B+TREE PAGES"></a>TASK #1 - B+TREE PAGES</h5><p>我们首先要了解B+树中的key-value映射，key是我们要找的关键字，value指向下一个节点。内部节点的key都按照从小到大的顺序排列，对于内部节点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子节点中的记录也按照key的大小排列。父节点存有右孩子第一个元素的索引。</p><h6 id="B-TREE-PARENT-PAGE"><a href="#B-TREE-PARENT-PAGE" class="headerlink" title="B+TREE PARENT PAGE"></a>B+TREE PARENT PAGE</h6><p>这是内部页和叶页都继承的父类，它只包含两个子类共享的信息。<strong>即所有的节点都复用一个header数据域类，其定义在b_plus_tree_page.h中</strong>，我们先来看看如下定义：</p><div class="table-container"><table><thead><tr><th>Variable Name</th><th>Size</th><th>Description</th></tr></thead><tbody><tr><td>page<em>type</em></td><td>4</td><td>Page Type (internal or leaf)//页面类型，内部页或者叶子页</td></tr><tr><td>lsn_</td><td>4</td><td>Log sequence number (Used in Project 4)//日志序列号？</td></tr><tr><td>size_</td><td>4</td><td>Number of Key &amp; Value pairs in page//页面键值对的数量</td></tr><tr><td>max<em>size</em></td><td>4</td><td>Max number of Key &amp; Value pairs in page//键值对最大数</td></tr><tr><td>parent<em>page_id</em></td><td>4</td><td>Parent Page Id//父页面ID</td></tr><tr><td>page<em>id</em></td><td>4</td><td>Self Page Id//页面ID</td></tr></tbody></table></div><p>在这里我们要实现一些简单的set和get函数，因为非常简单，所以就不列举出来了，但是有一个函数不太简单，那就是<code>GetMinSize</code>函数，正如我们在前面所说的，根节点可以拥有少于半数的元素，而且根节点也有可能是叶节点。我们知道，内部节点的array中的第一个键值对中的键是不可用的，正如下图所示：</p><p><img src="http://tvax1.sinaimg.cn/large/008qL1EEly1gzgqqs09qyj30kc06sq54.jpg" alt=""></p><p>我们发现键总是比值少一个。所以说，如果是根节点且根节点是内部节点，那么可以拥有最少2个数组项，其中第0项是无效key的那个；如果是根节点且根节点是叶子节点，那么最少有1个数组项。</p><p>在这种情况下，要想实现就很难了，所以我一开始直接简单粗暴的用内部节点来编写这个函数，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">BPlusTreePage::GetMinSize</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> max_size_/<span class="hljs-number">2</span>;&#125;<br></code></pre></td></tr></table></figure><p>不出意外是会在后续的测试中出错，所以我们改一下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">BPlusTreePage::GetMinSize</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">IsRootPage</span>())&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">IsLeafPage</span>()?<span class="hljs-number">1</span>:<span class="hljs-number">2</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">IsLeafPage</span>())&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ceil</span>(max_size_);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">ceil</span>(max_size_<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="B-TREE-INTERNAL-PAGE"><a href="#B-TREE-INTERNAL-PAGE" class="headerlink" title="B+TREE INTERNAL PAGE"></a>B+TREE INTERNAL PAGE</h6><p>我们可以先了解一下内部节点的声明，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Store n indexed keys and n+1 child pointers (page_id) within internal page.</span><br><span class="hljs-comment"> * Pointer PAGE_ID(i) points to a subtree in which all keys K satisfy:</span><br><span class="hljs-comment"> * K(i) &lt;= K &lt; K(i+1).</span><br><span class="hljs-comment"> * <span class="hljs-doctag">NOTE:</span> since the number of keys does not equal to number of child pointers,</span><br><span class="hljs-comment"> * the first key always remains invalid. That is to say, any search/lookup</span><br><span class="hljs-comment"> * should ignore the first key.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Internal page format (keys are stored in increasing order):</span><br><span class="hljs-comment"> *  --------------------------------------------------------------------------</span><br><span class="hljs-comment"> * | HEADER | KEY(1)+PAGE_ID(1) | KEY(2)+PAGE_ID(2) | ... | KEY(n)+PAGE_ID(n) |</span><br><span class="hljs-comment"> *  --------------------------------------------------------------------------</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>在这个声明当中，我们可以得知，内部节点会有n个key和n+1个page_id，所以，为了使得key和value对应，第一个key是无效的，任何的search/lookup必须忽略第一个key。其实啊，这第一个key我们可以理解为header，父节点的指针就是指向这里。</p><ul><li><p>获取/设置key的函数，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="hljs-function">KeyType <span class="hljs-title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::KeyAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>  <span class="hljs-comment">// replace with your own code</span><br>  KeyType key=array_[index].first;<br>  <span class="hljs-keyword">return</span> key;<br>&#125;<br><br><span class="hljs-function">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::SetKeyAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">const</span> KeyType &amp;key)</span> </span>&#123;<br>  array_[index].first=key;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>接着是通过value获取index和通过index获取value，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::ValueIndex</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ValueType &amp;value)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span>(array_[index].second!=value)&#123;<br>    index++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> index;<br>&#125;<br><br><span class="hljs-function">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="hljs-function">ValueType <span class="hljs-title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::ValueAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>  ValueType value=array_[index].second;<br>  <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>接着是通过key从当前节点查找下一节点，如下所示（具体实现看代码注释）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="hljs-function">ValueType <span class="hljs-title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::Lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> KeyType &amp;key, <span class="hljs-keyword">const</span> KeyComparator &amp;comparator)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>  <span class="hljs-comment">//采用二分查找</span><br>  <span class="hljs-keyword">int</span> left=<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">int</span> right=<span class="hljs-built_in">GetSize</span>()<span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">int</span> mid;<br>  <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>    mid=left+(right-left)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> res=<span class="hljs-built_in">comparator</span>(array_[mid].first,key);<br>    <span class="hljs-keyword">if</span>(res==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//如果找到直接返回</span><br>      <span class="hljs-keyword">return</span> array_[mid].second;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(res&lt;<span class="hljs-number">0</span>)&#123;<br>      left=mid+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(res&gt;<span class="hljs-number">0</span>)&#123;<br>      right=mid<span class="hljs-number">-1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">int</span> target=left;<br>  <span class="hljs-comment">//如果key比array中的所有key都大，就返回最后一个key的value</span><br>  <span class="hljs-keyword">if</span>(target&gt;=<span class="hljs-built_in">GetSize</span>())&#123;<br>    <span class="hljs-keyword">return</span> array_[<span class="hljs-built_in">GetSize</span>()<span class="hljs-number">-1</span>].second;<br>  &#125;<br>  <span class="hljs-comment">//否则返回target-1的value</span><br>  <span class="hljs-keyword">return</span> array_[target<span class="hljs-number">-1</span>].second;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>我们先来实现<code>CopyNFrom</code>函数，这个函数的意思就是最简单的插入操作，至于其他更复杂的操作则在其他函数实现。那么这就很简单了，我们可以直接将key-value插入进去。在这里我们用到了copy函数，我们来说一说:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::<span class="hljs-built_in">copy</span>(iterator source_first, iterator source_end, iterator target_start);<br></code></pre></td></tr></table></figure><p>在这里，我们设置<code>source_first=items</code>，设置<code>source_end=items+size</code>，设置目标迭代器为array_，这样我们就将items到items+size的元素复制到了array。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::CopyNFrom</span><span class="hljs-params">(MappingType *items, <span class="hljs-keyword">int</span> size, BufferPoolManager *buffer_pool_manager)</span> </span>&#123;<br>  std::<span class="hljs-built_in">copy</span>(items,items+size,array_);<br>  <span class="hljs-built_in">IncreaseSize</span>(size);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>然后是<code>PopulateNewRoot</code>函数，这里模拟的是新建一个root页面，在上面我们已经将过了，直接贴代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::PopulateNewRoot</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ValueType &amp;old_value, <span class="hljs-keyword">const</span> KeyType &amp;new_key,<span class="hljs-keyword">const</span> ValueType &amp;new_value)</span> </span>&#123;<br>  <span class="hljs-comment">//oldvalue为第一个值</span><br>  array_[<span class="hljs-number">0</span>].second=old_value;<br>  <span class="hljs-comment">//后面一对键值对</span><br>  <span class="hljs-built_in">SetKeyAt</span>(<span class="hljs-number">1</span>,new_key);<br>  array_[<span class="hljs-number">1</span>].second=new_value;<br>  <span class="hljs-built_in">IncreaseSize</span>(<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>InsertNodeAfter</code>函数，在old_value后面加入新的key-value对，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::InsertNodeAfter</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ValueType &amp;old_value, <span class="hljs-keyword">const</span> KeyType &amp;new_key,<span class="hljs-keyword">const</span> ValueType &amp;new_value)</span> </span>&#123;<br>  <span class="hljs-comment">//在旧的value之后插入新的key-value</span><br>  <span class="hljs-keyword">int</span> index= <span class="hljs-built_in">ValueIndex</span>(old_value);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-built_in">GetSize</span>()<span class="hljs-number">-1</span>;i&gt;index;i--)&#123;<br>    array_[i+<span class="hljs-number">1</span>]=array_[i];<br>  &#125;<br>  array_[index+<span class="hljs-number">1</span>]=&#123;new_key,new_value&#125;;<br>  <span class="hljs-built_in">IncreaseSize</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">GetSize</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>然后我们来实现分裂操作，也就是节点中元素数量大于Max_Size时，我们需要做的操作，如下图所示。</p><p><img src="http://tva3.sinaimg.cn/large/008qL1EEly1gzgqqmspi7j30f206qab4.jpg" alt=""></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::MoveHalfTo</span><span class="hljs-params">(BPlusTreeInternalPage *recipient,BufferPoolManager *buffer_pool_manager)</span> </span>&#123;<br>  <span class="hljs-comment">// 拷贝</span><br>  <span class="hljs-keyword">int</span> last_index = <span class="hljs-built_in">GetSize</span>() - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">int</span> start = last_index / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> j = start;<br>  <span class="hljs-keyword">while</span> (j &lt;= last_index) &#123;<br>    recipient-&gt;array_[i].first = array_[j].first;<br>    recipient-&gt;array_[i].second = array_[j].second;<br>    i++;<br>    j++;<br>  &#125;<br><br>  <span class="hljs-comment">// 维护size</span><br>  <span class="hljs-built_in">SetSize</span>(start);<br>  recipient-&gt;<span class="hljs-built_in">SetSize</span>(last_index - start + <span class="hljs-number">1</span>);<br><br>  <span class="hljs-comment">// 维护孩子节点的parent_page_id</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; recipient-&gt;<span class="hljs-built_in">GetSize</span>(); i++) &#123;<br>    <span class="hljs-keyword">auto</span> page_id = recipient-&gt;<span class="hljs-built_in">ValueAt</span>(i);<br>    <span class="hljs-keyword">auto</span> page = buffer_pool_manager-&gt;<span class="hljs-built_in">FetchPage</span>(page_id);<br>    BPlusTreePage *bp = <span class="hljs-keyword">reinterpret_cast</span>&lt;BPlusTreePage *&gt;(page-&gt;<span class="hljs-built_in">GetData</span>());<br>    bp-&gt;<span class="hljs-built_in">SetParentPageId</span>(recipient-&gt;<span class="hljs-built_in">GetPageId</span>());<br>    buffer_pool_manager-&gt;<span class="hljs-built_in">UnpinPage</span>(page_id, <span class="hljs-literal">true</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>对于删除操作，我们首先要实现<code>Remove</code>函数，利用<code>copy</code>函数实现，这里就不贴代码了。</p></li><li><p>接下来我们重点要实现的就是这几个Move函数，对于这几个函数，我们会用到第一个实验中的buffer_pool_manager，我们挑一个函数进行讲解。</p><p>对于<code>MoveAllTo</code>函数，我们要将节点中的所有键值对删除到“收件人”节点。此外我们还要将孩子节点的父节点转化为recipient，如下图所示：</p><p><img src="http://tvax4.sinaimg.cn/large/008qL1EEly1gzngf1wxepj30yp0zkaeb.jpg" alt=""></p></li></ul><p>​        除此之外，我们还要将该节点的父节点的子节点换成recipient。代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::MoveAllTo</span><span class="hljs-params">(BPlusTreeInternalPage *recipient, <span class="hljs-keyword">const</span> KeyType &amp;middle_key,</span></span><br><span class="hljs-params"><span class="hljs-function">                                               BufferPoolManager *buffer_pool_manager)</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> parent_page = <span class="hljs-keyword">reinterpret_cast</span>&lt;B_PLUS_TREE_INTERNAL_PAGE_TYPE *&gt;<br>  (buffer_pool_manager-&gt;<span class="hljs-built_in">FetchPage</span>(<span class="hljs-built_in">GetParentPageId</span>())-&gt;<span class="hljs-built_in">GetData</span>());<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt; <span class="hljs-built_in">GetSize</span>(); i++)&#123;<br>    <span class="hljs-comment">//获取孩子节点页面</span><br>    <span class="hljs-keyword">auto</span> page = buffer_pool_manager-&gt;<span class="hljs-built_in">FetchPage</span>(array_[i].second);<br>    <span class="hljs-keyword">auto</span> child_page = <span class="hljs-keyword">reinterpret_cast</span>&lt;BPlusTreePage *&gt;(page-&gt;<span class="hljs-built_in">GetData</span>());<br>    <span class="hljs-comment">//将孩子节点页面的父节点转换为recipient</span><br>    child_page-&gt;<span class="hljs-built_in">SetParentPageId</span>(recipient-&gt;<span class="hljs-built_in">GetPageId</span>());<br>    buffer_pool_manager-&gt;<span class="hljs-built_in">UnpinPage</span>(child_page-&gt;<span class="hljs-built_in">GetPageId</span>(), <span class="hljs-literal">true</span>);<br>  &#125;<br><br><br>  <span class="hljs-keyword">int</span> prior_size = recipient-&gt;<span class="hljs-built_in">GetSize</span>();<br>  recipient-&gt;<span class="hljs-built_in">SetKeyAt</span>(prior_size, middle_key);<br>  recipient-&gt;<span class="hljs-built_in">SetValueAt</span>(prior_size, <span class="hljs-built_in">ValueAt</span>(<span class="hljs-number">0</span>));<br>  recipient-&gt;<span class="hljs-built_in">IncreaseSize</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//注意别忘了更新</span><br><br>  recipient-&gt;<span class="hljs-built_in">CopyNFrom</span>(array_+<span class="hljs-number">1</span>, <span class="hljs-built_in">GetSize</span>()<span class="hljs-number">-1</span>, buffer_pool_manager);<br>  <span class="hljs-built_in">SetSize</span>(<span class="hljs-number">0</span>);<br>  buffer_pool_manager-&gt;<span class="hljs-built_in">UnpinPage</span>(parent_page-&gt;<span class="hljs-built_in">GetPageId</span>(), <span class="hljs-literal">true</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="B-TREE-LEAF-PAGE"><a href="#B-TREE-LEAF-PAGE" class="headerlink" title="B+TREE LEAF PAGE"></a>B+TREE LEAF PAGE</h6><p>在这里leafpage的value是RID，什么是RID呢？RID=page_id + slot number。</p><ul><li><p>一些简单的set/get函数，代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="hljs-function"><span class="hljs-keyword">page_id_t</span> <span class="hljs-title">B_PLUS_TREE_LEAF_PAGE_TYPE::GetNextPageId</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> next_page_id_; &#125;<br><br><span class="hljs-function">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">B_PLUS_TREE_LEAF_PAGE_TYPE::SetNextPageId</span><span class="hljs-params">(<span class="hljs-keyword">page_id_t</span> next_page_id)</span> </span>&#123;<br>  next_page_id_=next_page_id;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>KeyIndex函数要求我们找到第一个大于key的元素的索引，我们还是可以用二分法进行查找，代码如下所示，这里就不写注释了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">B_PLUS_TREE_LEAF_PAGE_TYPE::KeyIndex</span><span class="hljs-params">(<span class="hljs-keyword">const</span> KeyType &amp;key, <span class="hljs-keyword">const</span> KeyComparator &amp;comparator)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> right=<span class="hljs-built_in">GetSize</span>()<span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>    <span class="hljs-keyword">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> res=<span class="hljs-built_in">comparator</span>(key,array_[mid].first);<br>    <span class="hljs-keyword">if</span>(res==<span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(res&gt;<span class="hljs-number">0</span>)&#123;<br>      left=mid+<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      right=mid<span class="hljs-number">-1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>返回index对应的key，以及返回index对应的key-value对，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="hljs-function">KeyType <span class="hljs-title">B_PLUS_TREE_LEAF_PAGE_TYPE::KeyAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>  <span class="hljs-comment">// replace with your own code</span><br>  KeyType key = array[index].first;<br>  <span class="hljs-keyword">return</span> key;<br>&#125;<br><br><span class="hljs-function">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="hljs-function"><span class="hljs-keyword">const</span> MappingType &amp;<span class="hljs-title">B_PLUS_TREE_LEAF_PAGE_TYPE::GetItem</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> array[index];<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>leafpage的插入操作，我们用上文中的<code>KeyIndex</code>函数找到相应的index，然后插入进去，代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">B_PLUS_TREE_LEAF_PAGE_TYPE::Insert</span><span class="hljs-params">(<span class="hljs-keyword">const</span> KeyType &amp;key, <span class="hljs-keyword">const</span> ValueType &amp;value, <span class="hljs-keyword">const</span> KeyComparator &amp;comparator)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> index=<span class="hljs-built_in">KeyIndex</span>(key,comparator);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-built_in">GetSize</span>()<span class="hljs-number">-1</span>;i&gt;=index;i--)&#123;<br>    array_[i+<span class="hljs-number">1</span>]=array_[i];<br>  &#125;<br>  array_[index].first=key;<br>  array_[index].second=value;<br>  <span class="hljs-built_in">IncreaseSize</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>MoveFirstToEndOf</code>函数：将此页面中的第一个键值对删除到recipient页面。</p><p>在这个函数中要调用<code>CopyLastFrom</code>函数，我们将第一个键值读取出来用<code>CopyLastFrom</code>函数写入recipient中，然后用copy函数将当前page array向右边移动一格。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">B_PLUS_TREE_LEAF_PAGE_TYPE::MoveFirstToEndOf</span><span class="hljs-params">(BPlusTreeLeafPage *recipient)</span> </span>&#123;<br>  MappingType item=array_[<span class="hljs-number">0</span>];<br>  recipient-&gt;<span class="hljs-built_in">CopyLastFrom</span>(item);<br>  std::<span class="hljs-built_in">copy</span>(array_+<span class="hljs-number">1</span>, array_+<span class="hljs-built_in">GetSize</span>(), array_);<span class="hljs-comment">//当前page元素均向右移动一格</span><br>  <span class="hljs-built_in">IncreaseSize</span>(<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>相同的道理，<code>MoveLastToFrontOf</code>如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">B_PLUS_TREE_LEAF_PAGE_TYPE::MoveLastToFrontOf</span><span class="hljs-params">(BPlusTreeLeafPage *recipient)</span> </span>&#123;<br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">      * 更新recipient page的信息</span><br><span class="hljs-comment">      */</span><br>  MappingType item=array_[<span class="hljs-built_in">GetSize</span>()<span class="hljs-number">-1</span>];<br>  recipient-&gt;<span class="hljs-built_in">CopyFirstFrom</span>(item);<br>  <span class="hljs-built_in">IncreaseSize</span>(<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="TASK-2-A-B-TREE-DATA-STRUCTURE-INSERTION-amp-POINT-SEARCH"><a href="#TASK-2-A-B-TREE-DATA-STRUCTURE-INSERTION-amp-POINT-SEARCH" class="headerlink" title="TASK #2.A - B+TREE DATA STRUCTURE (INSERTION &amp; POINT SEARCH)"></a>TASK #2.A - B+TREE DATA STRUCTURE (INSERTION &amp; POINT SEARCH)</h5><p>在这个任务中我们要实现<code>b_plus_tree.cpp</code>中的函数，才能完成一个完整的b+树结构。</p><p>我们还是先来分析一下给定的<code>b_plus_tree</code>类中的数据结构，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// member variable</span><br>std::string index_name_;<span class="hljs-comment">//</span><br><span class="hljs-keyword">page_id_t</span> root_page_id_;<span class="hljs-comment">//root_page_id,用来引导整个b+树</span><br>BufferPoolManager *buffer_pool_manager_;<span class="hljs-comment">//</span><br>KeyComparator comparator_;<br><span class="hljs-keyword">int</span> leaf_max_size_;<span class="hljs-comment">//b+树的叶子节点的最大容量</span><br><span class="hljs-keyword">int</span> internal_max_size_;<span class="hljs-comment">//中间节点的最大容量</span><br></code></pre></td></tr></table></figure><ul><li><p>首先是<code>IsEmpty</code>函数，对于该函数，我们只要判断root_page_id是否有效就可以判断b+树是否为空，代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">BPLUSTREE_TYPE::IsEmpty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> root_page_id_==INVALID_PAGE_ID;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>IsEmpty</code>函数往往与<code>StartNewTree</code>函数一起调用，对于<code>StartNewTree</code>函数来说，我们首先将root_page_id对应的页面写到buffer pool，然后然后对其进行初始化，将key-value插入进去，最后unpin。关键代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">Page *new_page = buffer_pool_manager_-&gt;<span class="hljs-built_in">NewPage</span>(&amp;root_page_id_)<span class="hljs-comment">//to buffer pool</span><br>LeafPage *leaf_page = <span class="hljs-keyword">reinterpret_cast</span>&lt;LeafPage *&gt;(new_page);<br>leaf_page-&gt;<span class="hljs-built_in">Init</span>(root_page_id_,INVALID_PAGE_ID,leaf_max_size_);<span class="hljs-comment">//初始化</span><br>leaf_page-&gt;<span class="hljs-built_in">Insert</span>(key, value, comparator_);<span class="hljs-comment">//insert</span><br>buffer_pool_manager_-&gt;<span class="hljs-built_in">UnpinPage</span>(root_page_id_, <span class="hljs-literal">true</span>);  <span class="hljs-comment">// unpin</span><br></code></pre></td></tr></table></figure></li><li><p><code>InsertIntoLeaf</code>函数，将常量键值对插入叶页，用户需要先找到正确的叶子页面作为插入目标，然后再看通过叶子页面查看插入键是否存在。 如果存在，返回，否则插入条目。 如有必要，请记住处理拆分。因为我们只支持唯一键，如果用户尝试插入重复键返回 false，否则返回 true。注意，我们这里判断是否分裂用的是<code>if (leaf_page-&gt;GetSize() == maxSize(leaf_page) + 1)</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//如果需要新建树</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsEmpty</span>()) &#123;<br>    <span class="hljs-built_in">StartNewTree</span>(key, value);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-comment">// 1. if insert key is exist</span><br>  <span class="hljs-keyword">if</span> (leaf_page-&gt;<span class="hljs-built_in">Lookup</span>(key, <span class="hljs-literal">nullptr</span>, comparator_)) &#123;<br>    buffer_pool_manager_-&gt;<span class="hljs-built_in">UnpinPage</span>(leaf_page-&gt;<span class="hljs-built_in">GetPageId</span>(), <span class="hljs-literal">false</span>); <span class="hljs-comment">// unpined page</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-comment">// 1. if insert key is exist</span><br>  <span class="hljs-keyword">if</span> (leaf_page-&gt;<span class="hljs-built_in">Lookup</span>(key, <span class="hljs-literal">nullptr</span>, comparator_)) &#123;<br>    buffer_pool_manager_-&gt;<span class="hljs-built_in">UnpinPage</span>(leaf_page-&gt;<span class="hljs-built_in">GetPageId</span>(), <span class="hljs-literal">false</span>); <span class="hljs-comment">// unpined page</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>   <span class="hljs-comment">// 2. insert entry</span><br>  leaf_page-&gt;<span class="hljs-built_in">Insert</span>(key, value, comparator_);<br>  <br>   <span class="hljs-keyword">if</span> (leaf_page-&gt;<span class="hljs-built_in">GetSize</span>() == <span class="hljs-built_in">maxSize</span>(leaf_page) + <span class="hljs-number">1</span>) &#123;<br>    LeafPage *new_leaf = <span class="hljs-built_in">Split</span>(leaf_page);<br>    <span class="hljs-built_in">InsertIntoParent</span>(leaf_page, new_leaf-&gt;<span class="hljs-built_in">KeyAt</span>(<span class="hljs-number">0</span>), new_leaf, transaction);<br>  &#125;<br></code></pre></td></tr></table></figure></li><li><p>我们在<code>Split</code>函数中有可能用到<code>InsertIntoParent</code>，我们用下面两幅图来解释这个过程：</p><p><img src="http://tvax3.sinaimg.cn/large/008qL1EEly1gzgqqo09usj30gq065my9.jpg" alt=""></p><p><img src="http://tvax1.sinaimg.cn/large/008qL1EEly1gzgqqpbi2yj30j306x75u.jpg" alt=""></p><p>在这里，如果说old_node是根节点，那么整棵树直接升高一层，我们创建一个新节点R作为根节点，其关键字为key，左右孩子分别为old_node和new_node，如上图所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (old_node-&gt;<span class="hljs-built_in">IsRootPage</span>()) &#123;  <span class="hljs-comment">// old node为根结点</span><br>   <span class="hljs-keyword">page_id_t</span> new_page_id = INVALID_PAGE_ID;<br>   <span class="hljs-comment">//拿一个新的页面到buffer pool，最为新的根节点写入</span><br>   Page *new_page = buffer_pool_manager_-&gt;<span class="hljs-built_in">NewPage</span>(&amp;new_page_id);<br>   root_page_id_ = new_page_id;<br><span class="hljs-comment">// 注意初始化parent page id和max_size</span><br>   InternalPage *new_root_node = <span class="hljs-keyword">reinterpret_cast</span>&lt;InternalPage *&gt;(new_page-&gt;<span class="hljs-built_in">GetData</span>());<br>   new_root_node-&gt;<span class="hljs-built_in">Init</span>(new_page_id, INVALID_PAGE_ID, internal_max_size_);  <br>   <span class="hljs-comment">// 修改新的根结点的孩子指针，即array[0].second指向old_node，array[1].second指向new_node；对于array[1].first则赋值为key</span><br>   new_root_node-&gt;<span class="hljs-built_in">PopulateNewRoot</span>(old_node-&gt;<span class="hljs-built_in">GetPageId</span>(), key, new_node-&gt;<span class="hljs-built_in">GetPageId</span>());<br>   <span class="hljs-comment">// 修改old_node和new_node的父指针</span><br>   old_node-&gt;<span class="hljs-built_in">SetParentPageId</span>(new_page_id);<br>   new_node-&gt;<span class="hljs-built_in">SetParentPageId</span>(new_page_id);<br><span class="hljs-comment">// dirty置为true</span><br>   buffer_pool_manager_-&gt;<span class="hljs-built_in">UnpinPage</span>(new_page-&gt;<span class="hljs-built_in">GetPageId</span>(), <span class="hljs-literal">true</span>);  <br>  <br>   <span class="hljs-built_in">UpdateRootPageId</span>(<span class="hljs-number">0</span>); <br>   <span class="hljs-keyword">return</span>; <br> &#125;<br></code></pre></td></tr></table></figure><p>如果说old_node不是根结点，我们找到old_node的父节点进行操作，先直接插入<code>(key,new_node-&gt;page_id)</code>到父节点，如果插入后父节点满了，则需要对父结点再进行拆分(Split)，并继续递归。</p></li><li><p><code>Split</code>函数中，用户拆分输入页面并返回新创建的页面。使用模板 N 表示内部页面或叶子页面。用户需要首先向缓冲池管理器请求新页面（注意：抛出如果返回值为 nullptr，则会出现“内存不足”异常），然后从输入页面移动一半键值对到新创建页面。</p><ul><li>这里说的抛出很好理解：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">Page *new_page = buffer_pool_manager_-&gt;<span class="hljs-built_in">NewPage</span>(&amp;root_page_id_);<br>  <span class="hljs-keyword">if</span> (new_page == <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;out of memory&quot;</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><ul><li><p>对于叶子节点来说，我们除了要<code>movehalfto</code>绑定相应的父节点，还要对叶子节点链表进行更新，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">new_leaf_node-&gt;<span class="hljs-built_in">SetNextPageId</span>(leaf_node-&gt;<span class="hljs-built_in">GetNextPageId</span>());<br>leaf_node-&gt;<span class="hljs-built_in">SetNextPageId</span>(new_leaf_node-&gt;<span class="hljs-built_in">GetPageId</span>());<br></code></pre></td></tr></table></figure></li><li><p>对于内部节点，我们则只进行<code>movehalfto</code>和绑定相应的父节点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">new_internal_node-&gt;<span class="hljs-built_in">Init</span>(new_page_id, internal_node-&gt;<span class="hljs-built_in">GetParentPageId</span>(),internal_max_size_);<br>   internal_node-&gt;<span class="hljs-built_in">MoveHalfTo</span>(new_internal_node,buffer_pool_manager_);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>实现GET，分为3步，第一步找到那个叶子的page，在叶子page里找这个key，找到这个key之后放入result中，用完最后unpin 这个page。</p></li><li><p>对于Insert函数，如果树里面还没有数据，调用StartNewTree函数新建，否则调用InsertIntoLeaf函数插入。</p></li><li><p>对于FindLeafPage函数，他的参数为key和leftmost，我们要找到包含key的节点，如果leftmost为true，那么就不管key，而去找到最左边的叶子节点，否则，找到包含key的叶子节点。</p><p>这里我们就可以分成true和false两种情况，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">page_id_t</span> next_page_id = leftMost ? internal_node-&gt;<span class="hljs-built_in">ValueAt</span>(<span class="hljs-number">0</span>) : internal_node-&gt;<span class="hljs-built_in">Lookup</span>(key, comparator_);<br></code></pre></td></tr></table></figure></li></ul><h5 id="TASK-2-B-B-TREE-DATA-STRUCTURE-DELETION"><a href="#TASK-2-B-B-TREE-DATA-STRUCTURE-DELETION" class="headerlink" title="TASK #2.B - B+TREE DATA STRUCTURE (DELETION)"></a>TASK #2.B - B+TREE DATA STRUCTURE (DELETION)</h5><p>如果删除导致某些页面低于占用率阈值，您的 B+Tree 索引应该正确执行合并或重新分配。</p><ul><li><code>Coalesce</code>函数，将所有键值对从一个页面移动到其兄弟页面，并通知缓冲池管理器删除此页。 父页面必须调整为<ul><li>考虑删除信息。 记得处理 coalesce 或</li><li>必要时递归重新分配。</li><li>使用模板 N 表示内部页面或叶子页面。</li><li>@param neighbor_node 输入“节点”的兄弟页面</li><li>@param 来自方法 coalesceOrRedistribute() 的节点输入</li><li>@param parent 输入“节点”的父页面</li><li>@return true 表示要删除父节点，false 表示不删除</li><li>发生</li></ul></li></ul><h5 id="TASK-3-INDEX-ITERATOR"><a href="#TASK-3-INDEX-ITERATOR" class="headerlink" title="TASK #3 - INDEX ITERATOR"></a>TASK #3 - INDEX ITERATOR</h5><p>我们都知道，在B+树中，叶子节点link起来，可以实现快速range scan。在这个任务中，我们要构建一个通用索引迭代器来有效地检索所有叶子页面。其中，Begin函数返回一个状态为初始化的迭代器对象，End返回一个指向结束的迭代器对象。</p><ul><li><p>对于Begin函数，我们先直接用FindLeafPage找到最左边的节点，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">Page *leaf_page = <span class="hljs-built_in">FindLeafPage</span>(<span class="hljs-built_in">KeyType</span>(), <span class="hljs-literal">true</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">INDEXITERATOR_TYPE</span>(buffer_pool_manager_, leaf_page, <span class="hljs-number">0</span>);  <br></code></pre></td></tr></table></figure></li><li><p>对于End函数，入参为void，构造一个代表结束的索引迭代器，叶节点中的键/值对，return : 索引迭代器。我们先找到最左边的叶子节点，然后从最左边移动到最右边。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">Page *leaf_page = <span class="hljs-built_in">FindLeafPage</span>(<span class="hljs-built_in">KeyType</span>(), <span class="hljs-literal">true</span>);<br>LeafPage *leaf_node = <span class="hljs-keyword">reinterpret_cast</span>&lt;LeafPage *&gt;(leaf_page-&gt;<span class="hljs-built_in">GetData</span>());<br><br><span class="hljs-keyword">while</span> (leaf_node-&gt;<span class="hljs-built_in">GetNextPageId</span>() != INVALID_PAGE_ID) &#123;<br>    <span class="hljs-keyword">page_id_t</span> next_page_id = leaf_node-&gt;<span class="hljs-built_in">GetNextPageId</span>();<br>    buffer_pool_manager_-&gt;<span class="hljs-built_in">UnpinPage</span>(leaf_node-&gt;<span class="hljs-built_in">GetPageId</span>(), <span class="hljs-literal">false</span>);  <span class="hljs-comment">// page unpinned</span><br><br>    Page *next_page = buffer_pool_manager_-&gt;<span class="hljs-built_in">FetchPage</span>(next_page_id);  <span class="hljs-comment">// next_page pinned</span><br>    leaf_node = <span class="hljs-keyword">reinterpret_cast</span>&lt;LeafPage *&gt;(next_page-&gt;<span class="hljs-built_in">GetData</span>());<br>  &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">INDEXITERATOR_TYPE</span>(buffer_pool_manager_, leaf_page, leaf_node-&gt;<span class="hljs-built_in">GetSize</span>());<br></code></pre></td></tr></table></figure></li><li><p>重载++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">index_++;  <br><span class="hljs-keyword">if</span> (index_ == leaf_-&gt;<span class="hljs-built_in">GetSize</span>() &amp;&amp; leaf_-&gt;<span class="hljs-built_in">GetNextPageId</span>() != INVALID_PAGE_ID) &#123;<span class="hljs-comment">//如果index等于节点的长度，且节点不是最后一个节点，那么我们就要跳到下一个节点</span><br>    Page *next_page = buffer_pool_manager_-&gt;<span class="hljs-built_in">FetchPage</span>(leaf_-&gt;<span class="hljs-built_in">GetNextPageId</span>());  <span class="hljs-comment">// pin next leaf page</span><br>    buffer_pool_manager_-&gt;<span class="hljs-built_in">UnpinPage</span>(page_-&gt;<span class="hljs-built_in">GetPageId</span>(), <span class="hljs-literal">false</span>);  <span class="hljs-comment">//unpin当前page</span><br>    <br>    page_ = next_page;<br>    leaf_ = <span class="hljs-keyword">reinterpret_cast</span>&lt;LeafPage *&gt;(page_-&gt;<span class="hljs-built_in">GetData</span>());  <span class="hljs-comment">// 更新到下一个节点</span><br>    index_ = <span class="hljs-number">0</span>;                                              <span class="hljs-comment">// 重置index</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br></code></pre></td></tr></table></figure></li><li><p>重载*</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">return</span> leaf_-&gt;<span class="hljs-built_in">GetItem</span>(index_);<span class="hljs-comment">//这个没啥好说的，返回相应的key-value就行</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="TASK-4-CONCURRENT-INDEX"><a href="#TASK-4-CONCURRENT-INDEX" class="headerlink" title="TASK #4 - CONCURRENT INDEX"></a>TASK #4 - CONCURRENT INDEX</h5><p>在这部分，您需要更新您原来的单线程 B+Tree 索引，使其能够支持并发操作。我们将使用课堂和教科书中描述的闩锁技术。</p><h6 id="如何实现并发"><a href="#如何实现并发" class="headerlink" title="如何实现并发"></a>如何实现并发</h6><p>我们来看看Andy在lab中怎么说的（机器翻译）：</p><ul><li>搜索：从根页面开始，抓住子页面上的读取（R）闩锁，然后在您登陆子页面后立即释放父页面上的闩锁。</li><li>插入：从根页面开始，抓住子页面的写（W）锁存器。一旦孩子被锁定，检查它是否安全，在这种情况下，不是满的。如果孩子是安全的，则释放祖先的所有锁。</li><li>删除：从根页面开始，抓住子页面的写（W）锁存器。一旦孩子被锁定，检查它是否安全，在这种情况下，至少半满。 （注意：对于根页面，我们需要用不同的标准检查）如果孩子是安全的，释放所有祖先的锁。</li></ul><hr><p>我们来填一下之前的坑，锁（lock）和闩（latch）的区别：</p><ul><li>Locks<ul><li>从其它事务中保护数据库的逻辑内容</li><li>在事务执行期间保留</li><li>需要能够回滚之前的改变</li></ul></li><li>Latches<ul><li>从多线程中保护DBMS关键的数据结构</li><li>在操作期间保留</li><li>不需要回滚的能力</li></ul></li></ul><p>操作缓冲池汇总的LRU列表，删除、添加、移动LRU列表中的元素，为了保证一致性，必须有锁的介入，这就是latch锁。latch一般称为闩锁（轻量级别的锁），因为其要求锁定的时间必须非常短。若持续的时间长，则应用的性能会非常差。latch的一个例子：</p><blockquote><p>当我们在执行select时，数据是缓存在buffer pool中的，多个线程并发访问或者修改这个数据必然需要一个并发控制机制，这个就是latch。</p></blockquote><p>而lock对象是事务，用来锁定的是数据库中的对象，如表、行、页。</p><hr><p>我们在B+树的并发控制中要保证以下结果的正确性：</p><ul><li><strong>逻辑正确性</strong>：能否看到应该看到的结果？</li><li><strong>物理正确性</strong>：内部的数据结构表示是否被保护？（比如，在对B+树索引遍历时，当一个线程需要跳转到下一节点时，其它线程有可能会改变B+树的结构，使得指针指向为无效地址）</li></ul><h6 id="LATCH-CRABBING-COUPLING"><a href="#LATCH-CRABBING-COUPLING" class="headerlink" title="LATCH CRABBING / COUPLING"></a>LATCH CRABBING / COUPLING</h6><p>这是一个允许多线程同时访问/修改B+树的协议。其基本思想为：</p><ul><li>获得父节点的latch</li><li>获得子节点的latch</li><li>当安全的情况下才释放父节点的latch</li></ul><p>在读写锁中，当有一个 线程获得写锁定，其它无论是读锁定还是写锁定都将阻塞直到写解锁；当有一个线程获得读锁定，其它读锁定仍然可以继续；当有一个或任意多个读锁定，写锁定将等待所有读锁定解锁之后才能够进行写锁定。</p><ol><li>同时只能有一个线程能够获得写锁定。</li><li>同时可以有任意多个线程获得读锁定。</li><li>同时只能存在写锁定或读锁定（读和写互斥）。</li><li>加入<code>MaxReader</code>，来防止写进程饥饿，也就是读进程太多以至于等待时间过长而对写进程造成明显影响。</li></ol><hr><p>补充个go面经，互斥锁和读写锁。</p><h6 id="互斥锁Mutex"><a href="#互斥锁Mutex" class="headerlink" title="互斥锁Mutex"></a>互斥锁Mutex</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">type Mutex <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>state int32<br>sema  uint32<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，state采用不同位表示不同含义的方式作为状态位：</p><ol><li>第一位表示加锁状态：0表示未加锁，1表示已加锁</li><li>第二位表示唤醒状态：0表示未设置被唤醒状态，1表示已设置被唤醒状态</li><li>第三位表示运行状态：0表示正常状态，1表示饥饿状态</li><li>第四位以及其他字节位：表示等待获取锁的数目</li></ol><p>另外的sema为信号量，通过P/V操作实现锁的等待和唤醒。</p><h6 id="读写锁RWMutex"><a href="#读写锁RWMutex" class="headerlink" title="读写锁RWMutex"></a>读写锁RWMutex</h6><p>当有一个 goroutine 获得写锁定，其它无论是读锁定还是写锁定都将阻塞直到写解锁；当有一个 goroutine 获得读锁定，其它读锁定仍然可以继续；当有一个或任意多个读锁定，写锁定将等待所有读锁定解锁之后才能够进行写锁定。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rw *RWMutex)</span> <span class="hljs-title">RLock</span><span class="hljs-params">()</span>//读锁，当有写锁时，无法加载读锁，当只有读锁或者没有锁时，可以加载读锁，读锁可以加载多个，所以适用于“读多写少”的场景。</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rw *RWMutex)</span> <span class="hljs-title">RUnlock</span><span class="hljs-params">()</span>//读锁解锁，<span class="hljs-title">RUnlock</span> 撤销单次<span class="hljs-title">RLock</span>调用，它对于其它同时存在的读取器则没有效果。若<span class="hljs-title">rw</span>并没有为读取而锁定，调用<span class="hljs-title">RUnlock</span>就会引发一个运行时错误。</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rw *RWMutex)</span> <span class="hljs-title">Lock</span><span class="hljs-params">()</span>//写锁，如果在添加写锁之前已经有其他的读锁和写锁，则<span class="hljs-title">Lock</span>就会阻塞直到该锁可用，为确保该锁最终可用，已阻塞的<span class="hljs-title">Lock</span>调用会从获得的锁中排除新的读取锁，即写锁权限高于读锁，有写锁时优先进行写锁定。</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rw *RWMutex)</span> <span class="hljs-title">Unlock</span><span class="hljs-params">()</span>//写锁解锁，如果没有进行写锁定，则就会引起一个运行时错误。</span><br></code></pre></td></tr></table></figure><hr><p>我们来看读写锁在B+树中的具体表现：</p><p>查找38，给根节点上读锁：</p><p><img src="https://img-blog.csdnimg.cn/20201012221558584.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0luZ3N1aWZvbg==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p>当我们来到下一个B节点，给B上了读锁，确保已经安全，释放A的读锁。</p><p><img src="https://img-blog.csdnimg.cn/20201012221656748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0luZ3N1aWZvbg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201012221749942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0luZ3N1aWZvbg==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p>以此类推，找到38。</p><p><img src="https://img-blog.csdnimg.cn/20201012221919398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0luZ3N1aWZvbg==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p><img src="https://img-blog.csdnimg.cn/20201012221956330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0luZ3N1aWZvbg==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p>当我们要删除时，因为我们有可能修改了叶子节点之后会修改内部节点甚至是根节点，因此我们给每一个访问的节点都上写锁。</p><p><img src="https://img-blog.csdnimg.cn/20201012222108813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0luZ3N1aWZvbg==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p>子节点并没超过半满，所以是不安全的，不能释放父节点的锁。</p><p><img src="https://img-blog.csdnimg.cn/20201012222151930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0luZ3N1aWZvbg==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p>我们发现此时节点已经超过半满，可以释放祖先节点。</p><p><img src="https://img-blog.csdnimg.cn/20201012222350984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0luZ3N1aWZvbg==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p>以此类推，直到删除数据并释放所有写锁。</p><p><img src="https://img-blog.csdnimg.cn/20201012222504107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0luZ3N1aWZvbg==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p><img src="https://img-blog.csdnimg.cn/20201012222542426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0luZ3N1aWZvbg==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p>插入操作同理，我们如果发现节点没有半满，就可以释放祖先节点的写锁。</p><p>值得注意的是，<strong>释放锁时，我们应当从上往下释放，这样可以让等待的线程尽早执行</strong>。</p><p>这样做可以实现并发，但是实现不了高并发，要实现高并发还是得优化算法：</p><hr><p>在上面介绍的操作过程中我们发现：</p><p>我们只有在知道了子孙节点是满足特定条件的情况下才能释放祖先节点的写锁，这样可能会造成不必要的阻塞。</p><p>我们可以一开始就使用读锁，如果找到一个满足状态的节点就说明该节点的所有祖先节点都不用使用写锁，否则就要使用写锁。</p><p>可以使用一个队列，将每次访问的节点入队，给每个节点设置一个标志位，即它的儿子节点是否满足条件。访问完叶子节点之后，我们根据标志位将节点出队。</p><p>我们看到上面那副图，我们依次访问ABDH节点，A的儿子节点B不满足条件，将A的标志位设置为0，B的儿子节点满足条件，将B的标志位设置为0，D的儿子节点满足条件，将D的标志位设置为1，叶子节点H的标志位始终为0。这样我们就得到了序列0110（从叶子节点到根节点），我们再搜索一次，找到离叶子节点最近的那个1，设置一个计数器safe_count，这个1和之前的节点都是安全的，然后我们根据计数器再次从根节点访问，就像上面那副图，其实ABD都不用上写锁，我们直接就把队列中110对应的节点DBA都上读锁且访问下一个节点之前马上释放，这样我们就只给最后一个叶子节点上了写锁。</p><hr><p>改进：</p><p>我们可以设置一个缓冲队列，将节点的指针放进去，比如A通过A-&gt;array[1].second访问B节点，我们就把这个指针放进去，然后，一旦遇到节点安全，我怕们就把访问这个节点的指针之前入队的指针出队，只留下这个访问这个节点的指针，我们搜索完一遍之后直接通过这个指针搜索这个节点，从这个节点开始上写锁，这样也达到了相同的目的，且开销更小。</p><hr><p>这样看似操作更多，但是我们上的是读锁，只是为了防止被其他进程写入，比第一种方案一直上写锁要更好我觉得，特别是在数据量很大和读进程更多的时候。</p><p>如果我们存储的数据量足够大，我觉得我这个相较于Andy讲的基础算法算是实现了高并发的。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMU_15-455</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU_15-445_PROJECT#0&amp;1</title>
    <link href="/2022/02/03/CMU-15-445-PROJECT-0-1/"/>
    <url>/2022/02/03/CMU-15-445-PROJECT-0-1/</url>
    
    <content type="html"><![CDATA[<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>正如CMU 15-445的主讲教授所说，这门课并不会教你如何使用数据库去构建应用程序或网站，也不是教你如何去部署和管理数据库的课，这门课的核心课程是有关数据库管理系统的设计与实现。</p><h3 id="PROJECT-0-C-PRIMER"><a href="#PROJECT-0-C-PRIMER" class="headerlink" title="PROJECT #0 - C++ PRIMER"></a>PROJECT #0 - C++ PRIMER</h3><p>这个热身实验只是让我们把项目文件下载到本地，配置好相关的git，检验一下自己的C++能力，因此对其简要说明。</p><p>在这个项目中，您将实现三个类：<code>Matrix</code>、<code>RowMatrix</code>和<code>RowMatrixOperations</code>。这些矩阵是简单的二维矩阵，必须支持加法、矩阵乘法和简化的<a href="https://en.wikipedia.org/wiki/General_matrix_multiply">通用矩阵乘法</a>(GEMM) 运算（我们只要修改一个文件：p0_starter.h）。</p><p>这个就不多说了。</p><h3 id="PROJECT-1-BUFFER-POOL"><a href="#PROJECT-1-BUFFER-POOL" class="headerlink" title="PROJECT #1 - BUFFER POOL"></a>PROJECT #1 - BUFFER POOL</h3><hr><p>以前我从来没思考过buffer和cache的区别，为什么叫buffer pool而不叫cache pool，在做这个实验时，突然想到这个问题了，现记录如下（与实验无太大关系）：</p><ol><li>buffer与cache操作的对象不一样<ul><li>buffer（缓冲）是为了提高内存和硬盘之间的数据交互的速度而设计的。</li><li>cache（缓存）是为了提高CPU和内存之间的数据交互速度设计的，也就是平常见到的一级缓存、二级缓存等。</li><li>CPU在执行程序所用的指令和读取数据都是针对内存的，也就是从内存中取得的。由于内存读写速度慢，为了提高cpu和内存之间数据交换的速度，在cpu和内存之间增加了cache，它的速度比内存快。</li><li>缓冲是根据磁盘的读写设计的，把分散的写操作集中进行，减少磁盘碎片和磁盘的反复寻道，从而提高系统性能。</li></ul></li><li>或者可以这样说，buffer是系统两端处理速度平衡时使用的，而cache是系统两端不匹配时的一种折衷策略。我们在组原中学习过TLB（translation lookaside buffer），这玩意名字虽然叫buffer，但其实是一种cache。</li></ol><p>所以说，这里之所以叫buffer，那是因为它直接和磁盘进行数据交互。</p><p>在Free命令中显示的buffer和cache，它们都是占用内存：</p><ul><li><p>buffer : 作为buffer cache的内存，是块设备的读写缓冲区，更靠近存储设备，或者直接就是disk的缓冲区。</p></li><li><p>cache: 作为page cache的内存, 文件系统的cache，是memory的缓冲区 。</p></li></ul><p>补充，linux中buffer cache和page cache的概念和二者的区别：</p><p>Page cache在linux读写文件时，它用于缓存文件的逻辑内容，从而加快对磁盘上映像和数据的访问。具体说是加速对文件内容的访问，buffer cache缓存文件的具体内容——物理磁盘上的磁盘块，这是加速对磁盘的访问。</p><p>简单说来，page cache用来缓存文件数据，buffer cache用来缓存磁盘数据。在有文件系统的情况下，对文件操作，那么数据会缓存到page cache，如果直接采用dd等工具对磁盘进行读写，那么数据会缓存到buffer cache。</p><p>由于我对文件系统所知甚少，后面再继续补充。</p><hr><p>在传统的数据库管理系统中，数据的存储介质是磁盘，文件是以page的形式存储在磁盘上的。对于结构化数据来说，一条记录会被保存在磁盘上的某个数据块中。在对某条记录进行处理时，可以通过代表该记录地址的page_id从磁盘上获取该记录，随后系统会把存储有该条记录的数据块从磁盘读到缓冲区，缓冲区分为多个frame，每个frame可以保存一个磁盘块，再从缓冲区将该条记录读到线程或事务的工作区进行处理，处理结束后将更新的记录写回缓冲区中的数据块，再由数据库管理系统将修改过的数据块写回到磁盘上。</p><p>在buffer pool中，有一个又一个的chunk块，我们称之为frame，我们可以将page放置在其中，一个frame对应一个page，这就是很简单的一对一拷贝，page可以以它们想要的任何顺序放置在frame中，如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/008qL1EEly1gzci8busaxj30go05stai.jpg" alt=""></p><p>在此之上，我们需要一个额外的indirection层，如果我想要某个特定的page，通过这个indirection层我就知道它在哪个frame中——也就是pagetable，pagetable就是一个hash表（与其说是hash表，不如说是map我感觉，实验中也是用的map实现的，<code>std::unordered_map&lt;page_id_t, frame_id_t&gt; page_table_</code>，但Andy讲的是hash表），它用来跟踪内存中有哪些page，如果我们想找一个特定的page，通过page表和page id，我们就可以知道这个page在哪个frame中。数据库系统必须维护一些额外的元数据，以此来跟踪当前buffer池中发生了什么。下面是对这些元数据的详解：</p><p>dirty_page——这个数据告诉我们当我们从磁盘中读取到这个page后，这个page是否被修改过。</p><p>pin_count——引用计数，它用来跟踪想要使用该page的当前线程数量或者是正在查询该page的数量，这意味着我们并不想该page写出到磁盘上，因为我可能回去对它进行更新。从该page被放入内存到我对它进行更新这段时间内，我不想让该page被移除或者是交换回磁盘，这也将阻止我们去移除那些还未被安全写回磁盘的page。这也是我们后面的Pin函数想要表达的意思。</p><p>基本上来说，就是管理我们自己的内存，但我们也要去跟踪事务或查询是如何修改page的，在我们想做任何事之前，我们必须保护pagetable免受其他人污染或者是被其他人覆盖里面的东西。因此我们会用到Latches，下面是Locks和Latches的区别。</p><hr><blockquote><p>在数据库的世界中，lock是某种更高级的逻辑原语，它会去保护数据库中的逻辑内容，例如，tuple、表、以及数据库，事物会在运行的时候去持有这个lock，这就意味着可以有多个查询，数据库系统可以为我们提供这些东西，它能将这些暴露给我们这些开发人员。</p><p>Latch是一种底层保护原语，我们使用它来保护数据库系统内部的关键部分，比如，保护数据结构和保护内存区域，我们在执行操作的期间内，会持有这些Latch,用来保护某些东西，比如说，如果我去更新我的pagetable，我会在我要去修改的地方加上一个latch，修改完后，我会将它释放。</p></blockquote><p>后面教授就讲得很绕了，甚至spin mutex都讲出来了，我先去查查资料，后面填坑。</p><hr><p>另一个我们需要去区分的就是page目录和pagetable，二者之间的区别我在MIT6.S081 labs的博客里面也说过，我们还是来听听Andy教授怎么说：</p><blockquote><p>page目录的作用是用来找到page在我们数据库文件中的位置，比如我们想要找到page_no_1，它会告诉我们要找的那个page在这些数据库文件中的什么地方，page中的offset值有哪些，所以我们将page目录写在磁盘上，如果系统崩溃了，恢复后我们想知道该在哪里可以找到我么拥有的page，就可以访问page目录找到。</p><p>pagetable是内存中的映射，它将page_id映射到它们在buffer池中frame的位置。</p></blockquote><hr><p>当我们想将一个page放到内存中，但是内存中没有位置了应该怎么办呢？在替换策略中，我们最关心的就是正确性，如果说某个数据我们并没有真正地使用完，那么我们不想将它写出或移除，我们要确保我们所移除的page是在未来不太会被用到的那些page。</p><p>总而言之，为什么要使用buffer pool manager呢？</p><ol><li>如果没有缓冲池，那么数据都位于磁盘上，每次访问数据都要将其从磁盘读取到内存，下一次访问相同的数据时，还需要从磁盘读取，非常耗时。</li><li>现实中内存是有限的，如果我们在内存中缓存了page 1，2，3，已经存满内存了现在想访问page4，就要用到buffer pool manager，通过LRU机制进行替换。</li></ol><h5 id="CLOCK算法（了解）"><a href="#CLOCK算法（了解）" class="headerlink" title="CLOCK算法（了解）"></a>CLOCK算法（了解）</h5><hr><p>clock算法会给每个page设置一个标志位，唯一需要跟踪的就是每个page的标志位（referrence bit），它会告诉你自上次检查过该page之后，这个page是否被访问了。我们用环形队列来组织page，就像是一个clock，用一个能够旋转的指针去检查标志位是被设置为1还是0，如果是0，我们就可以知道从上次检查过之后该page就没有被访问过，因此我们就可以将该page从环形buffer中移除。</p><hr><p>我们将为BusTub DBMS构建一个面向磁盘的存储管理器。这样的存储管理器假定数据库的主要存储位置在磁盘上，project_1的任务是在存储管理器中实现缓冲池，缓冲池负责将物理页面从主存移动到磁盘，值的注意的是，DBMS需要支持大于系统可用内存量的数据库；多个线程将同时访问内部数据结构，因此我们需要确保他们的关键部分受到锁存器的保护。</p><p>我们可以维护一个单独的数据结构，比如队列，它根据page的时间戳进行排序，在某个时刻，有人对一个page进行读和写，我们只需要把该page从队列中拿出来，然后处理完放到队列的末尾，因为队列是先进先出的。</p><p>一句话，实验一的目标便在于主动管理磁盘中的页在内存中的缓存，从而最小化磁盘访问次数、最大化相关数据连续。</p><p>我们需要在存储管理器中实现以下组件：</p><ul><li>LRU更换策略</li><li>缓冲池管理器实例</li><li>并行缓冲池管理器</li></ul><h4 id="LRU更换策略"><a href="#LRU更换策略" class="headerlink" title="LRU更换策略"></a>LRU更换策略</h4><p>LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。也就是说我们这里定义一个<code>lru_list</code>，我们把pin_count为0的frame_id存放在lru_list，然后每次按照顺序出队（victim），如果在队列中的时候，这个frame_id被访问了，那么我们就从队列中删除它，直到它的pin_count再次为0，再次将它入队，循环往复。这样就达到了LRU的机制。</p><p>我们先来分析一下<code>include/buffer/replacer.h</code>中定义的父类Replacer。Replacer 是一个跟踪页面使用情况的抽象类。我们要实现以下方法：</p><ol><li>Victim(frame_id_t*)：Replacer跟踪与所有元素相比最近访问次数最少的对象并删除，将其删除页号存储在输出参数中，并返回 True。如果 Replacer 为空则返回 False。</li><li>Pin(frame_id_t)：在将page固定到BufferPoolManager中的frame后，应调用此方法。它应该从LRUReplacer中删除包含固定page的frame。</li><li>Unpin(frame_id_t)：当页面的引用计数变为 0 时，应该调用此方法。这个方法应该将未包含固定 page 的 frame 添加到 LRUReplacer，表示可能会被替换掉。（注意，需要判断是否超出了内存大小，如果超过了，则删除较新的页面，然后再添加。）</li><li>Size()：此方法返回当前在LRUReplacer中的页面数。</li></ol><p>在LRUReplacer中我们要实现一个队列<code>std::list&lt;frame_id_t&gt; lru_list_;</code>，这个队列用来维护page写入frame。我们可以将LRUReplacer当作是一个替换器，在初始状态下，LRUReplacer应当被初始化为不包含任何frames。当page加入到buffer pool的某个frame后，调用Pin删除在LRU队列中的frame<em>id，表示该frame已经不应该成为victim；Unpin则将未固定page的frame加入到LRU队列，表示该frame使用情况比较差（页面的引用计数变为0）；victim方法则是将LRU队列中最后一名frame_id弹出（在另外的对应的函数中会删除对应页面）。LRUReplacer的最大页数与缓冲池的大小相同（这样做是为了管理缓冲池中的所有frames），因此我们在LRUReplacer的构造函数中将capacity</em>的大小设置为参数num_pages，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs c++">LRUReplacer::<span class="hljs-built_in">LRUReplacer</span>(<span class="hljs-keyword">size_t</span> num_pages) &#123;<br>  capacity_ = num_pages;  <span class="hljs-comment">// Initialization the capacity</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当我们将page加入到BufferPoolManager中的frame后，需要从LRUReplacer中删除相应的frame。Pin函数如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LRUReplacer::Pin</span><span class="hljs-params">(<span class="hljs-keyword">frame_id_t</span> frame_id)</span> </span>&#123;<br>  <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(latch_)</span></span>;<br>  <span class="hljs-keyword">if</span> (map_.<span class="hljs-built_in">count</span>(frame_id) == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><span class="hljs-comment">//</span><br>  <span class="hljs-keyword">auto</span> iter = map_[frame_id];<br>  lru_list_.<span class="hljs-built_in">erase</span>(iter);<br>  map_.<span class="hljs-built_in">erase</span>(frame_id);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>值得注意的是，我们在对LRUReplacer进行操作时应该上锁，以避免内存中特定的数据结构不会因为并发访问而导致错误。</strong>其实我们在每个函数前面用unique_lock是最稳妥的，既不会死锁，也保证安全。</p><p>当页面的引用计数为0时，应该调用Unpin，这个方法应该将未固定 page 的 frame 添加到 LRUReplacer，表示有被victim的风险。代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LRUReplacer::Unpin</span><span class="hljs-params">(<span class="hljs-keyword">frame_id_t</span> frame_id)</span> </span>&#123;<br>  <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(latch_)</span></span>;<br>  <span class="hljs-keyword">if</span> (map_.<span class="hljs-built_in">count</span>(frame_id) != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (lru_list_.<span class="hljs-built_in">size</span>() == capacity_) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  lru_list_.<span class="hljs-built_in">push_front</span>(frame_id);<br>  map_.<span class="hljs-built_in">emplace</span>(frame_id, lru_list_.<span class="hljs-built_in">begin</span>());<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Replacer跟踪与所有元素相比最近访问次数最少的对象并删除，将其删除页号存储在输出参数中，并返回 True。如果 Replacer 为空则返回 False。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">LRUReplacer::Victim</span><span class="hljs-params">(<span class="hljs-keyword">frame_id_t</span> *frame_id)</span> </span>&#123;<br>  <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(latch_)</span></span>;<br><br>  <span class="hljs-keyword">if</span> (map_.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><span class="hljs-comment">//将需要删除的frame_id写入参数</span><br>  *frame_id = lru_list_.<span class="hljs-built_in">back</span>();<br>  map_.<span class="hljs-built_in">erase</span>(*frame_id);<br>  lru_list_.<span class="hljs-built_in">pop_back</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="缓冲池管理器实例"><a href="#缓冲池管理器实例" class="headerlink" title="缓冲池管理器实例"></a>缓冲池管理器实例</h4><p>接下来，需要在系统中实现缓冲池管理器实例，该BufferPoolManagerInstance负责从DiskManager中读取数据库页并将它们存储在内存中。</p><p>我们来看看该类的数据结构：</p><ul><li><code>pages_</code>，保存在buffer pool中的page数组；</li><li><code>disk_manager</code>，磁盘管理器；</li><li><code>log_manager</code></li><li><code>page_table_</code>，页表，保存了page_id到frame_id的映射；</li><li><code>replacer</code>，查找未固定的页面进行替换；</li><li><code>free_list_</code>，没有被page填充的frame list。</li></ul><p>刚看到这个任务的时候无从下手，还是一个函数一个函数分析。</p><ul><li><code>FlushPgImp</code>函数，我们要将在内存中的page内容刷新到磁盘。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">BufferPoolManagerInstance::FlushPgImp</span><span class="hljs-params">(<span class="hljs-keyword">page_id_t</span> page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// Make sure you call DiskManager::WritePage</span><br>  <span class="hljs-comment">//在这里也是一样，每个函数前面加上unique_lock</span><br>  <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(latch_)</span></span>;<br>  <span class="hljs-comment">//如果page id不合法，或者page_id不存在于页表中，直接返回</span><br>  <span class="hljs-keyword">if</span>(page_id==INVALID_PAGE_ID||page_table_.<span class="hljs-built_in">count</span>(page_id)==<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-comment">//找到之后获取frame_id</span><br>  <span class="hljs-keyword">auto</span> iter=page_table_.<span class="hljs-built_in">find</span>(page_id);<br>  <span class="hljs-keyword">frame_id_t</span> frame_id=iter-&gt;second;<br>  <span class="hljs-comment">//获取相应的page</span><br>  Page *page=&amp;pages_[frame_id];<br>  <span class="hljs-comment">//将page写入磁盘</span><br>  disk_manager_-&gt;<span class="hljs-built_in">WritePage</span>(page-&gt;page_id_, page-&gt;data_);<span class="hljs-comment">//这里的page-&gt;page_id_就是参数page_id</span><br>  <span class="hljs-comment">//写回磁盘之后将page设置为不是脏页</span><br>  page-&gt;is_dirty_ = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>FlushAllPgsImp</code>函数，刷新所有页面到磁盘。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BufferPoolManagerInstance::FlushAllPgsImp</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// You can do it!</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; pool_size_; ++i) &#123;<span class="hljs-comment">//遍历整个buffer pool</span><br>    Page *page = &amp;pages_[i];<br>    <span class="hljs-keyword">if</span> (page-&gt;page_id_ != INVALID_PAGE_ID &amp;&amp; page-&gt;<span class="hljs-built_in">IsDirty</span>()) &#123;<span class="hljs-comment">//如果是脏页且id有效，就将其写回磁盘</span><br>      disk_manager_-&gt;<span class="hljs-built_in">WritePage</span>(page-&gt;page_id_, page-&gt;data_);<br>      <span class="hljs-comment">//写回磁盘之后将page设置为不是脏页</span><br>      page-&gt;is_dirty_ = <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>NewPgImp</code>函数：在缓冲池创建一个新页面。</p><ol><li>确保你调用<code>allocatepage</code>函数；</li><li>如果所有在buffer pool的page都pinned，那么返回nullptr；</li><li>从空闲列表或替换器中选择一个受害者页面 P。 始终首先从免费列表中选择。</li></ol><p>在搞懂这个函数之前我们先要搞懂<code>AllocatePage</code>函数，<code>allocatepage</code>函数在磁盘分配一个页面，或者说取出一个页面，返回被分配页面的id，其代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">page_id_t</span> <span class="hljs-title">BufferPoolManagerInstance::AllocatePage</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">//按照磁盘中的排列</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">page_id_t</span> next_page_id = next_page_id_;<br>  <span class="hljs-comment">//一旦拿出一个next_page_id，就加上num_instances，到下一个next_page_id</span><br>  next_page_id_ += num_instances_;<br>  <span class="hljs-built_in">ValidatePageId</span>(next_page_id);<br>  <span class="hljs-keyword">return</span> next_page_id;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么我们看具体的代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Page *<span class="hljs-title">BufferPoolManagerInstance::NewPgImp</span><span class="hljs-params">(<span class="hljs-keyword">page_id_t</span> *page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// 0.   Make sure you call AllocatePage!</span><br>  <span class="hljs-comment">// 1.   If all the pages in the buffer pool are pinned, return nullptr.</span><br>  <span class="hljs-comment">// 2.   Pick a victim page P from either the free list or the replacer. Always pick from the free list first.</span><br>  <span class="hljs-comment">// 3.   Update P&#x27;s metadata, zero out memory and add P to the page table.</span><br>  <span class="hljs-comment">// 4.   Set the page ID output parameter. Return a pointer to P.</span><br>  <span class="hljs-comment">//std::unique_lock&lt;std::mutex&gt; lck(latch_);</span><br>  <span class="hljs-comment">//如果缓冲池中的所有page都被锁定了，注意这里的buffer pool满了，里面的page也全部被锁定了，那么这个时候就肯定没有空闲的空间给我们使用，所以直接返回nullptr</span><br>  <span class="hljs-keyword">bool</span> all_pinned = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; pool_size_; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (pages_[i].pin_count_ &lt;= <span class="hljs-number">0</span>) &#123;<br>      all_pinned = <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//直接返回</span><br>  <span class="hljs-keyword">if</span> (all_pinned) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>  <span class="hljs-comment">//让我们看到hint3，我们可以在replacer或者freelist中找到空闲的frame，优先freelist，如果都没有，直接返回。</span><br>  <span class="hljs-keyword">frame_id_t</span> frame_id = <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">if</span>(!free_list_.<span class="hljs-built_in">empty</span>())&#123;<br>    frame_id=free_list_.<span class="hljs-built_in">front</span>();<br>    free_list_.<span class="hljs-built_in">pop_front</span>();<br>  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">FindVictimPage</span>(&amp;frame_id)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>  <span class="hljs-comment">//找到之后我们就可以把frame_id和page_id组合，然后pin</span><br>  *page_id = <span class="hljs-built_in">AllocatePage</span>();<br>  Page *page = &amp;pages_[frame_id];<br>  <span class="hljs-built_in">UpdatePage</span>(page, *page_id, frame_id);<br>  replacer_-&gt;<span class="hljs-built_in">Pin</span>(frame_id);<br>  page-&gt;pin_count_ = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> page;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>FetchPgImp</code>函数，从缓冲池中获取请求的页面，我们可以从官方注释中具体了解这个方法要实现的任务：</p><ol><li>在页表中寻找请求页面P；<ul><li>如果页面P存在，调用Pin方法后返回；</li><li>如果页面P不存在，则从空闲列表或替换其中查找替换页R；</li></ul></li><li>将脏页写回磁盘；</li><li>从页表中删除R，插入P；</li><li>更新P的元数据，从磁盘读入页面内容，返回一个指向P的指针。</li></ol></li></ul><p>​        代码如下，具体解析在注释中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Page *<span class="hljs-title">BufferPoolManagerInstance::FetchPgImp</span><span class="hljs-params">(<span class="hljs-keyword">page_id_t</span> page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// 1.     Search the page table for the requested page (P).</span><br>  <span class="hljs-comment">// 1.1    If P exists, pin it and return it immediately.</span><br>  <span class="hljs-comment">// 1.2    If P does not exist, find a replacement page (R) from either the free list or the replacer.</span><br>  <span class="hljs-comment">//        Note that pages are always found from the free list first.</span><br>  <span class="hljs-comment">// 2.     If R is dirty, write it back to the disk.</span><br>  <span class="hljs-comment">// 3.     Delete R from the page table and insert P.</span><br>  <span class="hljs-comment">// 4.     Update P&#x27;s metadata, read in the page content from disk, and then return a pointer to P.</span><br>  <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(latch_)</span></span>;<br>  <br>  Page *tar = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-comment">//寻找page_id对应的frame_id</span><br>  <span class="hljs-keyword">auto</span> iter = page_table_.<span class="hljs-built_in">find</span>(page_id);<br>  <span class="hljs-comment">//如果该page_id存在于页表中</span><br>  <span class="hljs-keyword">if</span> (iter != page_table_.<span class="hljs-built_in">end</span>()) &#123;<br>    <br>    <span class="hljs-keyword">frame_id_t</span> frame_id = iter-&gt;second;<br>    <span class="hljs-comment">//找到相应的page</span><br>    tar = &amp;pages_[frame_id];<br>    <span class="hljs-comment">//将frame_id移除lru队列</span><br>    replacer_-&gt;<span class="hljs-built_in">Pin</span>(frame_id);<br>    <span class="hljs-comment">//根据lru机制，将该page引用计数+1</span><br>    tar-&gt;pin_count_++;<br>    <span class="hljs-comment">//返回指向P的指针</span><br>    <span class="hljs-keyword">return</span> tar;<br>  &#125;<br>  <span class="hljs-comment">//如果replacer中没有可用的页面，并且其他所有页面当前都被固定，则应该返回NULL</span><br>  <span class="hljs-keyword">frame_id_t</span> frame_id = <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">FindVictimPage</span>(&amp;frame_id)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>  <span class="hljs-comment">//否则，我们将我们请求的页面从disk中拿出来放到buffer pool中，然后执行相应的操作</span><br>  tar = &amp;pages_[frame_id];<br>  <span class="hljs-built_in">UpdatePage</span>(tar, page_id, frame_id);<br>  disk_manager_-&gt;<span class="hljs-built_in">ReadPage</span>(page_id, tar-&gt;data_);<br>  replacer_-&gt;<span class="hljs-built_in">Pin</span>(frame_id);<br>  tar-&gt;pin_count_ = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> tar;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>UnpinPgImp函数</code>：这个函数就是完成对该页面操作之后，进行Unpin操作。<ol><li>如果一开始<code>pin_couter==0</code>，直接返回。</li><li>如果这个页面的<code>pin_couter&gt;0</code>，我们直接返回。</li><li>如果这个页面的<code>pin_couter==0</code>，我们需要给它加入到LRU_Replacer中。<strong>因为没有人引用它，所以它可以成为被替换的候选人</strong>。</li></ol></li></ul><p>​        其代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">BufferPoolManagerInstance::UnpinPgImp</span><span class="hljs-params">(<span class="hljs-keyword">page_id_t</span> page_id, <span class="hljs-keyword">bool</span> is_dirty)</span> </span>&#123;<br>  <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(latch_)</span></span>;<br>  <span class="hljs-comment">//如果page id不合法，或者page_id不存在于页表中，直接返回</span><br>  <span class="hljs-keyword">if</span>(page_id==INVALID_PAGE_ID||page_table_.<span class="hljs-built_in">count</span>(page_id)==<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-comment">//找到之后获取frame_id</span><br>  <span class="hljs-keyword">auto</span> iter=page_table_.<span class="hljs-built_in">find</span>(page_id);<br><br>  <span class="hljs-keyword">frame_id_t</span> frame_id = iter-&gt;second;<br>  Page *page = &amp;pages_[frame_id];<br>  <span class="hljs-comment">//如果直接是等于0的，说明不需要unpin操作，直接返回</span><br>  <span class="hljs-keyword">if</span> (page-&gt;pin_count_ == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-comment">//如果之前被调用过，执行下列操作</span><br>  page-&gt;pin_count_--;<br>  <span class="hljs-keyword">if</span> (page-&gt;pin_count_ == <span class="hljs-number">0</span>) &#123;<br>    replacer_-&gt;<span class="hljs-built_in">Unpin</span>(frame_id);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (is_dirty) &#123;<br>    page-&gt;is_dirty_ = <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>DeletePgImp</code>函数：从缓冲池删除一个页面，如果页面存在但无法删除，则返回 false，如果页面不存在或删除成功，则返回 true。</p><ol><li>Make sure you call DeallocatePage!</li><li>Search the page table for the requested page (P).</li><li>If P des not exist, return true.</li><li>If P exists, but has a non-zero pin-count, return fale. Someone is using the page.</li><li>Otherwise, P can be deleted. Remove P from the page table, reset its metadata and return it to the free list.</li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">BufferPoolManagerInstance::DeletePgImp</span><span class="hljs-params">(<span class="hljs-keyword">page_id_t</span> page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// 0.   Make sure you call DeallocatePage!</span><br>  <span class="hljs-comment">// 1.   Search the page table for the requested page (P).</span><br>  <span class="hljs-comment">// 1.   If P does not exist, return true.</span><br>  <span class="hljs-comment">// 2.   If P exists, but has a non-zero pin-count, return false. Someone is using the page.</span><br>  <span class="hljs-comment">// 3.   Otherwise, P can be deleted. Remove P from the page table, reset its metadata and return it to the free list.</span><br>  <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(latch_)</span></span>;<br> <span class="hljs-keyword">if</span>(page_id==INVALID_PAGE_ID||page_table_.<span class="hljs-built_in">count</span>(page_id)==<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">auto</span> iter=page_table_.<span class="hljs-built_in">find</span>(page_id);<br>  <span class="hljs-keyword">frame_id_t</span> frame_id = iter-&gt;second;<br>  Page *page = &amp;pages_[frame_id];<br>  <span class="hljs-keyword">if</span> (page-&gt;pin_count_ &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-built_in">DeallocatePage</span>(page_id);<br>  <span class="hljs-built_in">UpdatePage</span>(page, INVALID_PAGE_ID, frame_id);<br>  free_list_.<span class="hljs-built_in">push_back</span>(frame_id);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="并行缓冲池管理器"><a href="#并行缓冲池管理器" class="headerlink" title="并行缓冲池管理器"></a>并行缓冲池管理器</h4><p>正如上个任务中看到的，每一个缓冲池都有一个锁来保证线程安全。这可能导致性能问题，因为每个线程在与缓冲池交互时都会争夺该锁。一个可行的解决方案是同时维护多个缓冲池，每个缓冲池都有独立的锁。</p><p>ParallelBufferPoolManager是一个包含多个bufferpoolmanagerinstance的类。对于每个操作，其都会选择一个实例并调用该实例。</p><p>我们使用给定的page_id来确实使用哪个特定的实例。如果我们有多个实例，则需要某种方法将page_id映射到[0, num_instances)中。对于本项目，我们将使用模运算，即page_id mod num_instances来将给定的page_id映射到正确的范围。</p><p>当ParallelBufferPoolManager初始化的时候，他的起始索引应该是0。此后每创建一个新的页面，都应从起始索引开始尝试每个实例直到某个成功。然后将起始指数加1。</p><p>确保当你创建单独的BufferPoolManagerInstances时，你调用的构造函数应使用uint32_t num_instances和uint32_t instance_index，来保证页面id被正确地创建。</p><p>上面是机器翻译的，我来总结一下：也就是说，现在我们可以在系统中搞多个缓冲池，每个缓冲池都有自己的锁，这样来实现并行。那么如何确定我们要查找的page位于哪个缓冲池呢，我们可以根据<strong>某种映射方式</strong>，也就是说，我们可以用page_id%num_instances来确定page_id是位于哪一个缓冲池实例。</p><p>我们还是先来看看<code>ParallelBufferPoolManager</code>类中的数据结构，如下所示：</p><ul><li><code>size_t pool_size_</code>：缓冲池的页数</li><li><code>uint32_t num_instances_ = 1</code>：实例的数量</li><li><code>uint32_t instance_index_ = 0</code>：实例的索引</li></ul><p>有了上面的讲解，那么下面两个函数的实现就很容易了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">ParallelBufferPoolManager::GetPoolSize</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// Get size of all BufferPoolManagerInstances</span><br>  <span class="hljs-keyword">return</span> pool_size_ * num_instances_;<br>&#125;<br><br><span class="hljs-function">BufferPoolManager *<span class="hljs-title">ParallelBufferPoolManager::GetBufferPoolManager</span><span class="hljs-params">(<span class="hljs-keyword">page_id_t</span> page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// Get BufferPoolManager responsible for handling given page id. You can use this method in your other methods.</span><br><br>  <span class="hljs-keyword">return</span> parallel_bmi_[page_id% num_instances_];<br>&#125;<br></code></pre></td></tr></table></figure><p>对于缓冲区实例的操作也很简单了，我们只需要在获得page_id参数之后用<code>GetBufferPoolManager</code>，来知道是在哪一个实例当中，就可以了，代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Page *<span class="hljs-title">ParallelBufferPoolManager::FetchPgImp</span><span class="hljs-params">(<span class="hljs-keyword">page_id_t</span> page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// Fetch page for page_id from responsible BufferPoolManagerInstance</span><br>  BufferPoolManager *manager = <span class="hljs-built_in">GetBufferPoolManager</span>(page_id);<br>  <span class="hljs-keyword">return</span> manager-&gt;<span class="hljs-built_in">FetchPage</span>(page_id);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ParallelBufferPoolManager::UnpinPgImp</span><span class="hljs-params">(<span class="hljs-keyword">page_id_t</span> page_id, <span class="hljs-keyword">bool</span> is_dirty)</span> </span>&#123;<br>  <span class="hljs-comment">// Unpin page_id from responsible BufferPoolManagerInstance</span><br>  BufferPoolManager *manager = <span class="hljs-built_in">GetBufferPoolManager</span>(page_id);<br>  <span class="hljs-keyword">return</span> manager-&gt;<span class="hljs-built_in">UnpinPage</span>(page_id, is_dirty);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ParallelBufferPoolManager::FlushPgImp</span><span class="hljs-params">(<span class="hljs-keyword">page_id_t</span> page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// Flush page_id from responsible BufferPoolManagerInstance</span><br>  BufferPoolManager *manager = <span class="hljs-built_in">GetBufferPoolManager</span>(page_id);<br>  <span class="hljs-keyword">return</span> manager-&gt;<span class="hljs-built_in">FlushPage</span>(page_id);<br>&#125;<br><br><span class="hljs-function">Page *<span class="hljs-title">ParallelBufferPoolManager::NewPgImp</span><span class="hljs-params">(<span class="hljs-keyword">page_id_t</span> *page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// create new page. We will request page allocation in a round robin manner from the underlying</span><br>  <span class="hljs-comment">// BufferPoolManagerInstances</span><br>  <span class="hljs-comment">// 1.   From a starting index of the BPMIs, call NewPageImpl until either 1) success and return 2) looped around to</span><br>  <span class="hljs-comment">// starting index and return nullptr</span><br>  <span class="hljs-comment">// 2.   Bump the starting index (mod number of instances) to start search at a different BPMI each time this function</span><br>  <span class="hljs-comment">// is called</span><br>  Page *page = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">size_t</span> index = start_id_;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; num_instances_; ++i) &#123;<br>    page = parallel_bmi_[index]-&gt;<span class="hljs-built_in">NewPage</span>(page_id);<br>    <span class="hljs-keyword">if</span> (page != <span class="hljs-literal">nullptr</span>) &#123;<br>      start_id_ = (index + <span class="hljs-number">1</span>) % num_instances_;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    index = (index + <span class="hljs-number">1</span>) % num_instances_;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> page;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ParallelBufferPoolManager::DeletePgImp</span><span class="hljs-params">(<span class="hljs-keyword">page_id_t</span> page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// Delete page_id from responsible BufferPoolManagerInstance</span><br>  BufferPoolManager *manager = <span class="hljs-built_in">GetBufferPoolManager</span>(page_id);<br>  <span class="hljs-keyword">return</span> manager-&gt;<span class="hljs-built_in">DeletePage</span>(page_id);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ParallelBufferPoolManager::FlushAllPgsImp</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// flush all pages from all BufferPoolManagerInstances</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; num_instances_; i++) &#123;<br>    parallel_bmi_[i]-&gt;<span class="hljs-built_in">FlushAllPages</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMU_15-455</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT_6.s081_Lab4_traps</title>
    <link href="/2022/02/01/MIT-S081-Labs-traps/"/>
    <url>/2022/02/01/MIT-S081-Labs-traps/</url>
    
    <content type="html"><![CDATA[<h4 id="先来说说trap"><a href="#先来说说trap" class="headerlink" title="先来说说trap"></a>先来说说trap</h4><p>我们知道，用户态切换到内核态的有两种情况：一种是系统调用（syscall），另一种是异常（trap）或中断（interruption），在前面的实验中我们学习了系统调用。</p><p>我们先来回忆一下在lab1中做过的<code>sleep</code>任务。在进入内核后，会调用<code>sys_sleep</code>函数，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">sys_sleep</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> n;<br>  uint ticks0;<br><br>  <span class="hljs-keyword">if</span>(argint(<span class="hljs-number">0</span>, &amp;n) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  acquire(&amp;tickslock);<br>  ticks0 = ticks;<br>  <span class="hljs-keyword">while</span>(ticks - ticks0 &lt; n)&#123;<br>    <span class="hljs-keyword">if</span>(myproc()-&gt;killed)&#123;<br>      release(&amp;tickslock);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    sleep(&amp;ticks, &amp;tickslock);<br>  &#125;<br>  release(&amp;tickslock);<br>  backtrace();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于用户态转到内核态我们在lab2中已经讲过了，在<code>acquire</code>函数中，这个函数不断自旋获取锁。</p><h5 id="trap机制"><a href="#trap机制" class="headerlink" title="trap机制"></a>trap机制</h5><p>在x86中我们常常说中断，但是在xv6中我们都是使用trap来代表他们，因为trap是传统的Unix术语。trap是由在CPU上运行的当前进程导致的；而中断是由设备导致的，可能与当前进程毫无关系。但是他们都<strong>依赖相同的硬件机制在用户模式和内核模式之间进行切换</strong>。</p><p>在从用户态转到内核态的时候，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的。其具体过程如下：</p><ol><li>将CPU的字段改为内核态（硬件标志位），这个过程在xv6中其实就是<code>ecall</code>，将对应的用户栈的寄存器信息保存起来（xv6中是保存在内核栈），方便后续内核方法调用完毕后，恢复用户方法执行的现场。</li><li>将内核段对应的代码地址写入到PC寄存器中，设置堆栈指针寄存器的内容为内核栈的地址，用户页表切换到内核页表，然后开始执行内核方法。</li><li>当内核方法执行完毕后，会将CPU的字段改为用户态，然后利用之前用户态的信息来恢复用户栈的执行。</li></ol><hr><p>我们在实验2中知道，用户态在进入内核态的时候调用了一个entry，如下所示：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">fork:<br> li a7, SYS_fork<br> ecall<br> ret<br>.global <span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure><p>ecall是什么呢？ecall就是将CPU中的mode标志位设置为supervisor，并且设置程序计数器的值为STVEC寄存器的值。内核会将trampoline page的地址存在STVEC寄存器中，所以ecall的下一条指令的位置是STVEC指向的地址，也就是trampoline page的其实地址。</p><h5 id="kernel-trampoline-S"><a href="#kernel-trampoline-S" class="headerlink" title="kernel/trampoline.S"></a><code>kernel/trampoline.S</code></h5><p>trampoline.S从user space过渡到kernel space，kernel space返回到user space。STVEC寄存器中存储的是 trampoline page 的起始位置。<strong>进入内核前，首先需要在该位置处执行一些初始化的操作。例如，切换页表、切换栈指针等操作</strong>。cpu 从 trampoline page 处开始进行取指执行。接下来需要<strong>保存所有寄存器的值</strong>，寄存器的值是如何保存的呢？当寄存器里面的还都是用户程序的数据的时候，我们需要非常小心，我们在这个时间点不能使用任何寄存器，否则我们是没法恢复寄存器数据的。如果内核在这个时间点使用了任何一个寄存器，内核会覆盖寄存器内的用户数据，如果我们要尝试恢复用户数据，我们就不能恢复寄存器中的正确数据，用户程序的执行也会相应的出错。比如说，trampoline里面有个csrrw指令，这是trampoline page的第一条指令，这条指令的意思是交换a0和sscratch中的内容，在这之后内核就可以任意使用a0寄存器了。</p><p>以便在系统调用后恢复调用前的状态。然后我们要根据中断的原因执行相应的处理：产生中断的原因有很多，比如<strong>系统调用、运算时除以0、使用了一个未被映射的虚拟地址、或者是设备中断等等</strong>。这里是因为系统调用，所以以系统调用的方式进行处理。然后才是内核态执行系统调用函数，将ecall指令时保存在a7的参数取出来，完成相应的系统调用函数，系统调用完成之后将寄存器的值取出来，从该地址存储的指令处开始执行，恢复到用户态。</p><h4 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h4><p>源文件<code>call.c</code>代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/param.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> x+<span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> g(x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, f(<span class="hljs-number">8</span>)+<span class="hljs-number">1</span>, <span class="hljs-number">13</span>);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们先编译一下源文件得到<code>call.asm</code>，部分代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">void main(void) &#123;<br>  1c:1141                addisp,sp,-16<br>  1e:e406                sdra,8(sp)<br>  20:e022                sds0,0(sp)<br>  22:0800                addis0,sp,16<br>  printf(&quot;%d %d\n&quot;, f(8)+1, 13);<br>  24:4635                lia2,13<br></code></pre></td></tr></table></figure><ol><li><p>Q:Which registers contain arguments to functions? For example, which register holds 13 in main’s call to <code>printf</code>?</p><p>A:a0-a7.A2 holds 13 in main’s call to printf.</p></li><li><p>Q:Where is the call to function <code>f</code> in the assembly code for main? Where is the call to <code>g</code>? (Hint: the compiler may inline functions.)</p><p>A:nowhere, compiler optimization by inline function.</p><p>其实是没有这样的代码。 g(x) 被内联到 f(x) 中，然后 f(x) 又被进一步内联到 main() 中。所以看到的不是函数跳转，而是优化后的内联函数。</p></li><li><p>Q:At what address is the function <code>printf</code> located?</p></li></ol><h4 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h4><p>使用这些帧指针向上遍历堆栈并在每个堆栈帧中打印保存的返回地址。</p><p>我们知道x86使用函数参数压栈的方式来保护函数参数，而xv6使用寄存器的方式保存参数。无论是x86还是xv6,函数调用时，都需要将返回地址和父函数的栈帧起始地址压入栈中。即被调用函数的栈帧中保存着这两个值，在xv6中，fp为当前函数的栈顶指针，sp为栈底指针。fp-8存放返回地址，fp-16存放原栈帧。</p><p>我们看如下这幅图：</p><p><img src="https://pic4.zhimg.com/80/v2-d7a2b1baeaf71d7e0c2cf306d80c49d7_720w.jpg" alt=""></p><p>我们根据提示，将backtrace的原型添加到<code>kernel/defs.h</code>中，代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// printf.c</span><br><span class="hljs-function"><span class="hljs-keyword">void</span>            <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-keyword">char</span>*, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span>            <span class="hljs-title">panic</span><span class="hljs-params">(<span class="hljs-keyword">char</span>*)</span> __<span class="hljs-title">attribute__</span><span class="hljs-params">((noreturn))</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span>            <span class="hljs-title">printfinit</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span>            <span class="hljs-title">backtrace</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>GCC 编译器将当前执行函数的帧顶指针存储在寄存器<code>s0</code>中。因此我们通过<code>r_fp</code>函数可以知道当前函数的栈顶指针fp：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">kernel/riscv.h:<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> uint64</span><br><span class="hljs-function"><span class="hljs-title">r_fp</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  uint64 x;<br>  <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;mv %0, s0&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span> (x) )</span></span>;<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>backtrace</code>函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">backtrace</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;<br>  uint64 fp = <span class="hljs-built_in">r_fp</span>(), top = <span class="hljs-built_in">PGROUNDUP</span>(fp);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;backtrace:\n&quot;</span>);<br>  <span class="hljs-keyword">for</span>(; fp &lt; top; fp = *((uint64*)(fp<span class="hljs-number">-16</span>))) &#123;<span class="hljs-comment">//我们知道，每个fp-16就是原栈帧，我们通过*(fp-16)得到原栈帧，保存在fp中，然后打印*(fp-8)</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, *((uint64*)(fp<span class="hljs-number">-8</span>)));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h4><p>在本练习中，您将向xv6添加一项功能，该功能会在使用CPU时间的情况下定期向进程发出警报。这对于想要限制消耗多少CPU时间的计算密集型进程，或者对于想要进行计算但还希望采取一些定期操作的进程很有用。</p><p>您应该添加一个新的<code>sigalarm(interval,handler)</code>系统调用。 如果应用程序调用<code>sigalarm(n,fn)</code>，则在程序每消耗n个“ tick” CPU时间之后，内核应导致调用应用程序函数fn。 当fn返回时，应用程序应从中断处恢复。</p><h6 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h6><p>我们首先看到测试函数，代码解析在注释中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">test0</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;test0 start\n&quot;</span>);<span class="hljs-comment">//开始测试</span><br>  count = <span class="hljs-number">0</span>;<span class="hljs-comment">//计数器为0</span><br>  sigalarm(<span class="hljs-number">2</span>, periodic);<span class="hljs-comment">//在消耗2个cpu时间之后，调用periodic函数</span><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>*<span class="hljs-number">500000</span>; i++)&#123;<br>    <span class="hljs-keyword">if</span>((i % <span class="hljs-number">1000000</span>) == <span class="hljs-number">0</span>)<br>      write(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  sigalarm(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">//停止生成定期警报调用</span><br>  <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;test0 passed\n&quot;</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\ntest0 failed: the kernel never called the alarm handler\n&quot;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">periodic</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  count = count + <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;alarm!\n&quot;</span>);<span class="hljs-comment">//打印&quot;alarm&quot;</span><br>  sigreturn();<span class="hljs-comment">//调用sigreturn函数</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在<code>user/user.h</code>，我们需要做如下声明：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sigalarm</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ticks, <span class="hljs-keyword">void</span> (*handler)())</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sigreturn</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>在 user/usys.pl 添加 entry：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">entry(<span class="hljs-string">&quot;sigalarm&quot;</span>);<br>entry(<span class="hljs-string">&quot;sigreturn&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>在 kernel/syscall.h 中添加函数调用码：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_sigalarm  22</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_sigreturn 23</span><br></code></pre></td></tr></table></figure><ul><li>在 kernel/syscall.c 添加函数调用代码：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_sigalarm</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_sigreturn</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br>[SYS_sigalarm]  sys_sigalarm,<br>[SYS_sigreturn] sys_sigreturn,<br></code></pre></td></tr></table></figure><p>我们需要在proc结构体中添加字段，用于记录进程的滴答数——<code>uint64 ticks</code>；还需要一个<code>uint64 interval</code>，ticks达到interval便中断；当然，还需要一个函数指针<code>alarm_pointer</code>，用来中断时的调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span>) &#123;<span class="hljs-comment">//which_dev为2说明是因为定时引起的</span><br>    <span class="hljs-keyword">if</span>(p-&gt;interval) &#123;<br>      <span class="hljs-keyword">if</span>(p-&gt;ticks == p-&gt;interval) &#123;<span class="hljs-comment">//当alarm_interval==0 &amp;&amp; alarm_handler==0时，内核应该停止产生周期性的报警调用</span><br>        p-&gt;ticks = <span class="hljs-number">0</span>;  <br>        p-&gt;trapframe-&gt;epc = p-&gt;handler;<br>      &#125;<br>      p-&gt;ticks++;<br>    &#125;<br>    yield();<br>  &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT_s.081_Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT_6.s081_lab3_pagetables</title>
    <link href="/2022/01/19/MIT-6-s081-labs-pages/"/>
    <url>/2022/01/19/MIT-6-s081-labs-pages/</url>
    
    <content type="html"><![CDATA[<blockquote><p>当我第一次学习它，还是一个学生的时候，我想它是很直接的，能有多难，就是一个表要将虚拟地址映射到物理地址。或许有点复杂，但不是那么复杂。只有当用它编程时，我才知道虚拟内存是巧妙的，迷人的，非常强大。</p></blockquote><p>在本次实验中，您将探索页表并修改它们以简化将数据从用户空间复制到内核空间的函数。在讲解实验之前，我们先要了解页表结构。</p><p>页表（pagetable）是用来干什么的？页表的作用是地址翻译，从Virtual Address(VA)到Physical Address(PA)，CPU将VA传递给MMU，MMU通过查询页表得到PA，实现地址翻译。也就是说页表是一个实现了key-value功能的数组，索引表示的是虚拟地址，数组的值表示物理地址。值得注意的是，页表存储在什么地方呢？页表存储在内存中，只需要告诉MMU页表的内存地址，这个地址应当是物理地址，我们不能让地址翻译依赖于另一个翻译，否则可能会陷入递归的无限循环中。</p><p>如何解决页表占用内存过大呢？</p><ul><li>不要为每个地址创建一个表单条目，而是为每个page创建一条表单条目</li><li><strong>多级页表</strong></li></ul><p>我们首先来了解一下pagetable是如何实现的：</p><h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><h5 id="页表的实现"><a href="#页表的实现" class="headerlink" title="页表的实现"></a>页表的实现</h5><p><img src="https://pic2.zhimg.com/v2-2635bdb5168de78ce3ad23f9857fd7e9_b.jpg" alt=""></p><p>假设一个page的大小为4kb,对于虚拟地址，将它划分为两部分，index和offset，index用来查找page，offset对应的是一个page中的哪个字节。当MMU在做地址翻译的时候，通过读取虚拟内存地址中的index可以知道物理内存中的page号，这个page号对应了物理内存中的4096个字节。之后虚拟内存地址中的offset指向了page中的4096个字节中的某一个，假设offset是12，那么page中的第12个字节被使用了。将offset加上page的起始地址，就可以得到物理内存地址。</p><p>以上图为例，每个页表仍然需要2^27个条目，每个条目占8个字节，每个页表占内存1GB，而且每个进程都会有一个页表，这仍然是不能接受的。到目前位置，最大的问题是即使应用程序所引用的只是虚拟地址空间中很小的一部分，也总是需要一个完整的页表驻留在内存中。（上述例子来源于<a href="https://wjrsbu.smartapps.cn/zhihu/article?id=369660512&amp;isShared=1&amp;_swebfr=1&amp;_swebFromHost=baiduboxapp">博客</a>)</p><h5 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h5><p><img src="https://pic1.zhimg.com/v2-3eaf43267f882245cc176d23274c1978_b.jpg" alt=""></p><p>以xv6使用的RISC-V框架为例，使用三级页表。我们之前所说的VA中的27bit的index，实际上是由3个9bit的数字组成（L2，L1，L0）。对于L2，其被用来索引最高级的page directory，directory中的一个条目被称为PTE(Page Table Entry)是64bit，而一个page directory是4KB，这样的话，一个PT中就有512个PTE，也就是说我们的L2的9bit可以对应一个page directory的PTE，而PTE的组成部分是PPN+Flags，这个PPN指向中间级的page directory。同理，我们使用L1找到中间级page directory的PPN，在最低级的pagedirectory，我们可以得到对应于虚拟内存地址的物理内存地址。</p><p>多级页表相较于一级页表，能大大减少pagetable的大小，优化空间。</p><h5 id="x86页表的实现"><a href="#x86页表的实现" class="headerlink" title="x86页表的实现"></a>x86页表的实现</h5><p>x86页表在物理内存中像一棵两层的树，也就是两级页表。树的根是一个4096字节的页目录，其中包含1024个PTE的条目（每个条目占4字节），每个条目是指向一个页表页，每个页表页包含1024个32位PTE的数组（PTE就是虚拟地址到物理地址映射的条目），如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/008qL1EEly1gyqkb8nus2j30fw0bajtb.jpg" alt=""></p><p>如上图所示，一个虚拟地址有32位，10位Dir，10位table，10位offset。首先，要用10位Dir找到相应的页表页，然后使用10位table找到相应页表页中对应的PTE，然后将虚拟地址的前20位（即dir+table）变成PPN，这样就得到了32位PPN+Offset，即物理地址。</p><h4 id="xv6对页表的使用"><a href="#xv6对页表的使用" class="headerlink" title="xv6对页表的使用"></a>xv6对页表的使用</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/493f49ab5868db801f35592c0434adda.png" alt=""></p><p>这个是xv6中PTE的结构，其中，53-10位是PPN，余下几位是flag位，弄懂标志位的含义对本实验至关重要，第0位V表示该PTE是否可用，第1位R表示该PTE是否可读；第2位W表示该PTE是否可写；第3位X表示是否可执行的。</p><p>虚拟内存有两个主要的优点：</p><ul><li>隔离性：虚拟内存使得操作系统可以为每个应用程序提供属于他们自己的地址空间，所以一个应用程序不可能有意无意修改另一个应用程序的内存数据。虚拟内存同时也提供了用户空间和内核空间隔离性。</li><li>提供了一层抽象：处理器和所有的指令都可以使用虚拟地址，而内核会定义从虚拟地址到物理地址的映射关系。</li></ul><h4 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h4><p>该任务是编写一个打印页表内容的函数，定义一个名为<code>vmprint()</code>的函数。</p><p><code>在 exec.c 中的return argc</code>之前插入<code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code>，以打印第一个进程的页表。也就是说</p><p>这个pagetable_t参数指的就是进程的页表号，或者说对应的页表中的首地址（暂时来看这是最好的理解）。</p><p>在riscv.h中定义了如下所示的宏，也就是说pagetable_t参数是一个uint64类型的指针，一个页表有512个PTE。</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> uint64 *<span class="hljs-keyword">pagetable_t</span>; <span class="hljs-comment">// 512 PTEs</span><br></code></pre></td></tr></table></figure><p>1.我们在exec.c的<code>return argc</code>前加入下列代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(p-pid==<span class="hljs-number">1</span>)&#123;<br>vmprint(p-&gt;pagetable);<br>&#125;<br></code></pre></td></tr></table></figure><p>2.我们在defs.h中定义vmprint函数的原型，以便在exec.c中调用它：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span>            <span class="hljs-title">vmprint</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span>)</span></span><br></code></pre></td></tr></table></figure><p>3.编写vmprint函数如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> </span><br><span class="hljs-function"><span class="hljs-title">printwalk</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable, uint level)</span> </span>&#123;<br>  <span class="hljs-keyword">char</span>* prefix;<br>  <span class="hljs-comment">//不同级别的页表打印不同的..</span><br>  <span class="hljs-keyword">if</span> (level == <span class="hljs-number">2</span>) prefix = <span class="hljs-string">&quot;..&quot;</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (level == <span class="hljs-number">1</span>) prefix = <span class="hljs-string">&quot;.. ..&quot;</span>;<br>  <span class="hljs-keyword">else</span> prefix = <span class="hljs-string">&quot;.. .. ..&quot;</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">512</span>; i++)&#123; <span class="hljs-comment">// 每级页表有512项</span><br>    <span class="hljs-keyword">pte_t</span> pte = pagetable[i];<br>    <span class="hljs-keyword">if</span>(pte &amp; PTE_V)&#123; <span class="hljs-comment">// 该页表项有效</span><br>      uint64 pa = PTE2PA(pte); <span class="hljs-comment">// 将pte中转化为pa</span><br>      <span class="hljs-comment">//打印PTE对应的PA</span><br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s%d: pte %p pa %p\n&quot;</span>, prefix, i, pte, pa);<br>      <span class="hljs-keyword">if</span>((pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 如果有下一级页表</span><br>         printwalk((<span class="hljs-keyword">pagetable_t</span>)pa, level - <span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">vmprint</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable)</span> </span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;page table %p\n&quot;</span>, pagetable);<br>  printwalk(pagetable, <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果PTE_V==1，则说明该页表项有效。如果pte中的PTE_R、PTE_W和PTE_X位都是0，则说明有下一级页表，可以通过递归进入下一级页表。</p><h4 id="A-kernel-page-table-per-process"><a href="#A-kernel-page-table-per-process" class="headerlink" title="A kernel page table per process"></a>A kernel page table per process</h4><p>xv6为每个进程的用户地址空间提供一个单独的页表，然而从用户态进入内核态中，多个进程使用的是一个内核页表。这个任务的目标是让每一个进程进入内核态后，都能有自己的独立内核页表。</p><p>首先，我们要在进程的结构体proc中添加一个<code>pagetable_t kernel_pagetable</code>，表示每个进程在内核态中有自己独立的内核页表，结构体如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// kernel/proc.h</span><br><span class="hljs-comment">// Per-process state</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br><br>  <span class="hljs-comment">// p-&gt;lock must be held when using these:</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">procstate</span> <span class="hljs-title">state</span>;</span>        <span class="hljs-comment">// Process state</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">parent</span>;</span>         <span class="hljs-comment">// Parent process</span><br>  <span class="hljs-keyword">void</span> *chan;                  <span class="hljs-comment">// If non-zero, sleeping on chan</span><br>  <span class="hljs-keyword">int</span> killed;                  <span class="hljs-comment">// If non-zero, have been killed</span><br>  <span class="hljs-keyword">int</span> xstate;                  <span class="hljs-comment">// Exit status to be returned to parent&#x27;s wait</span><br>  <span class="hljs-keyword">int</span> pid;                     <span class="hljs-comment">// Process ID</span><br><br>  <span class="hljs-comment">// these are private to the process, so p-&gt;lock need not be held.</span><br>  uint64 kstack;               <span class="hljs-comment">// Virtual address of kernel stack</span><br>  uint64 sz;                   <span class="hljs-comment">// Size of process memory (bytes)</span><br>  <span class="hljs-keyword">pagetable_t</span> pagetable;       <span class="hljs-comment">// User page table</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">trapframe</span>;</span> <span class="hljs-comment">// data page for trampoline.S</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span>      <span class="hljs-comment">// swtch() here to run process</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">ofile</span>[<span class="hljs-title">NOFILE</span>];</span>  <span class="hljs-comment">// Open files</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">cwd</span>;</span>           <span class="hljs-comment">// Current directory</span><br>  <span class="hljs-keyword">char</span> name[<span class="hljs-number">16</span>];               <span class="hljs-comment">// Process name (debugging)</span><br>  <span class="hljs-keyword">pagetable_t</span> kernel_pb;     <span class="hljs-comment">// Kernel page table （在 proc 中添加该 field）</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><p>至于proc结构体在下一个实验前细说。</p><p>在<code>kernel/vm.c</code>中，我们发现了如下变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * the kernel&#x27;s page table.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">pagetable_t</span> kernel_pagetable;<br></code></pre></td></tr></table></figure><p>这就是我们内核中的唯一的<code>kernel_pagetable</code>，在原版本中，vm.c中的<code>void kvminit(void)</code>会调用kvmake函数来修改kernel_pagetable，那么现在我们需要修改kvminit函数，来让我们的每个进程在内核中都有自己的内核页表。我们先来看看原版本中的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Initialize the one kernel_pagetable</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">kvminit</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  kernel_pagetable = kvmmake();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">pagetable_t</span></span><br><span class="hljs-function"><span class="hljs-title">kvmmake</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">pagetable_t</span> kpgtbl;<br><br>  kpgtbl = (<span class="hljs-keyword">pagetable_t</span>) kalloc();<br>  <span class="hljs-built_in">memset</span>(kpgtbl, <span class="hljs-number">0</span>, PGSIZE);<br><br>  <span class="hljs-comment">// uart registers</span><br>  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);<br><br>  <span class="hljs-comment">// virtio mmio disk interface</span><br>  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);<br><br>  <span class="hljs-comment">// PLIC</span><br>  kvmmap(kpgtbl, PLIC, PLIC, <span class="hljs-number">0x400000</span>, PTE_R | PTE_W);<br><br>  <span class="hljs-comment">// map kernel text executable and read-only.</span><br>  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);<br><br>  <span class="hljs-comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span><br>  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);<br><br>  <span class="hljs-comment">// map the trampoline for trap entry/exit to</span><br>  <span class="hljs-comment">// the highest virtual address in the kernel.</span><br>  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);<br><br>  <span class="hljs-comment">// map kernel stacks</span><br>  proc_mapstacks(kpgtbl);<br>  <br>  <span class="hljs-keyword">return</span> kpgtbl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">kvmmap</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> kpgtbl, uint64 va, uint64 pa, uint64 sz, <span class="hljs-keyword">int</span> perm)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(mappages(kpgtbl, va, sz, pa, perm) != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;kvmmap&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以模仿内核页表初始化的方式初始化用户进程的kernel pagetable。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 模仿vm.c中kvminit的方式构建每个进程自己</span><br><span class="hljs-comment">// 的内核映射表 <span class="hljs-doctag">TODO:</span>删除</span><br><span class="hljs-function"><span class="hljs-keyword">pagetable_t</span></span><br><span class="hljs-function"><span class="hljs-title">proc_kpt_init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">pagetable_t</span> kpt;<br>  kpt = <span class="hljs-built_in">uvmcreate</span>();<br>  <span class="hljs-keyword">if</span> (kpt == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">uvmmap</span>(kpt, UART0, UART0, PGSIZE, PTE_R | PTE_W);<br>  <span class="hljs-built_in">uvmmap</span>(kpt, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);<br>  <span class="hljs-built_in">uvmmap</span>(kpt, CLINT, CLINT, <span class="hljs-number">0x10000</span>, PTE_R | PTE_W);<br>  <span class="hljs-built_in">uvmmap</span>(kpt, PLIC, PLIC, <span class="hljs-number">0x400000</span>, PTE_R | PTE_W);<br>  <span class="hljs-built_in">uvmmap</span>(kpt, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);<br>  <span class="hljs-built_in">uvmmap</span>(kpt, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);<br>  <span class="hljs-built_in">uvmmap</span>(kpt, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);<br>  <span class="hljs-keyword">return</span> kpt;<br>&#125;<br><br><span class="hljs-comment">// 添加映射到用户进程的kernel pagetable</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> </span><br><span class="hljs-function"><span class="hljs-title">uvmmap</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable, uint64 va, uint64 pa, uint64 sz, <span class="hljs-keyword">int</span> perm)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">mappages</span>(pagetable, va, sz, pa, perm) != <span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;uvmmap&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Simplify-copyin-copyinstr"><a href="#Simplify-copyin-copyinstr" class="headerlink" title="Simplify copyin/copyinstr"></a>Simplify <code>copyin/copyinstr</code></h4>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT_s.081_Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stanford_CS144_Lab4</title>
    <link href="/2022/01/13/Stanford-CS144-Lab4/"/>
    <url>/2022/01/13/Stanford-CS144-Lab4/</url>
    
    <content type="html"><![CDATA[<p>在这一关要求实现一个TCPConnection类，基于TCP的有限状态机，将send和recieve封装起来。也就是说，作为一个TCP客户端，我们有自己的sender和receiver，现在要用这个客户端与其他主机进行联系，所以我们要实现TCP的各种FSM。</p><p>在tests文件夹中，我们可以看到很多关于fsm的测试文件，这些就是基于不同的有限状态机的测试，因此，我们掌握了TCP的有限状态机，才能将这个实验完成。我们就先来讲讲这些fsm：</p><div class="table-container"><table><thead><tr><th>fsm_ack_rst</th><th></th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td></tr></tbody></table></div><p>我们先来看看到底要实现哪些类</p><p>在上述代码中，可以看到有一个之前没有接触过的类——<code>TCPConfig</code>，所以我们首先来了解一下<code>TCPConfig</code>。我们到<code>TCPConfig</code>类中可以看到，它是对一些相关参数设置默认大小，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TCPConfig</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> DEFAULT_CAPACITY = <span class="hljs-number">64000</span>;  <span class="hljs-comment">//!&lt; Default capacity</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> MAX_PAYLOAD_SIZE = <span class="hljs-number">1000</span>;   <span class="hljs-comment">//!&lt; Conservative max payload size for real Internet</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">uint16_t</span> TIMEOUT_DFLT = <span class="hljs-number">1000</span>;     <span class="hljs-comment">//!&lt; Default re-transmit timeout is 1 second</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">unsigned</span> MAX_RETX_ATTEMPTS = <span class="hljs-number">8</span>;   <span class="hljs-comment">//!&lt; Maximum re-transmit attempts before giving up</span><br><br>    <span class="hljs-keyword">uint16_t</span> rt_timeout = TIMEOUT_DFLT;       <span class="hljs-comment">//!&lt; Initial value of the retransmission timeout, in milliseconds</span><br>    <span class="hljs-keyword">size_t</span> recv_capacity = DEFAULT_CAPACITY;  <span class="hljs-comment">//!&lt; Receive capacity, in bytes</span><br>    <span class="hljs-keyword">size_t</span> send_capacity = DEFAULT_CAPACITY;  <span class="hljs-comment">//!&lt; Sender capacity, in bytes</span><br>    std::optional&lt;WrappingInt32&gt; fixed_isn&#123;&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在<code>_receiver</code>等变量中通过<code>TCPConfig</code>默认大小。刚看到<code>TCPConnection</code>类时可能无从下手，我们先运行一下check程序，从第一个faild入手（没错，本懒狗是边做lab边写博客，面向tests编程）。</p><p>我们可以看到第一个faild出现在第35个测试，也就是fsm_passive_close，这个测试检测的是有限状态机中的初始状态（？）我们在项目中找到指定位置，开始debug，发现是<code>void TCPConnection::connect()</code>方法的错误，当我们要建立连接的时候，我们想到的还是三次握手，如下图：</p><p><img src="http://tva4.sinaimg.cn/large/007SD2TBly1gwp74pmbcrj30jv0dgmz0.jpg" alt=""></p><p>（还是以客户端为例子）首先，我们要进行第一次握手，也就是客户端发送SYN报文，在TCPSender类中，我们实现了fill_window方法，里面包含了三次握手中第一次握手的过程。在TCPConnection中，有相关的建立连接的方法，即<code>void TCPConnection::connect()</code>方法，于是我们将sender中的握手的过程加入函数当中，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TCPConnection::connect</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// send SYN</span><br>    _sender.<span class="hljs-built_in">fill_window</span>();<br>    <span class="hljs-built_in">real_send</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是第一次握手时的场景，调用了fill_window()，在没有预设参数的情况下，fill_window会默认是第一次握手，从而设置对用的syn和seqno值。这样就完成了建立连接的第一步。为了使得发送报文可以模块化操作，实现real_send函数，real_send函数负责将_sender.segment_out队列中的报文拿出来，放入到 _segment_out队列中，代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">TCPConnection::real_send</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">bool</span> isSend = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span> (!_sender.<span class="hljs-built_in">segments_out</span>().<span class="hljs-built_in">empty</span>()) &#123;<br>        isSend = <span class="hljs-literal">true</span>;<br>        TCPSegment segment = _sender.<span class="hljs-built_in">segments_out</span>().<span class="hljs-built_in">front</span>();<br>        _sender.<span class="hljs-built_in">segments_out</span>().<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-built_in">set_ack_and_windowsize</span>(segment);<br>        _segments_out.<span class="hljs-built_in">push</span>(segment);<br>    &#125;<br>    <span class="hljs-keyword">return</span> isSend;<br>&#125;<br></code></pre></td></tr></table></figure><p>当收到服务器的第二次握手时，就会调用TCPConnection中的<code>void TCPConnection::segment_received(const TCPSegment &amp;seg)</code>函数，这个函数的参数是收到的segment，当收到这个segment的时候，客户端就要进行第三次握手，当然，我们的第三次握手就可以看成正常的发送报文了。那么我们来看看收到报文之后应该如何处理。首先，我们将segment给到我们的 _receiver中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// give the segment to receiver</span><br>_receiver.<span class="hljs-built_in">segment_received</span>(seg);<br></code></pre></td></tr></table></figure><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA2MDg0ODUxMjcy?x-oss-process=image/format,png" alt=""></p><p>在TCP协议中，rst用来异常的关闭连接。在TCP的设计中它是不可或缺的，发送rst段关闭连接时，不必等缓冲区的数据都发送出去，直接丢弃缓冲区中的数据，而接收端收到rst后，也不必发送ack来确认。在以下情况下会发送rst段：</p><ol><li>目标端口未监听，链接一个未监听的端口，则被连接方会发送一个rst段。</li><li>向已经关闭的链接发送FIN，cli.close关闭服务端连接，当前服务端连接处于FIN_WAIT2状态，等待对端的FIN段。服务端的连接在FIN_WAIT2状态超时，当前服务端的连接实际上已经消逝，此时，客户端调用sock.close()关闭连接，则服务端产生rst。</li></ol><p>什么时候发送RST包</p><ol><li>建立连接的SYN到达某端口，但是该端口上没有正在 监听的服务。</li><li>TCP收到了一个根本不存在的连接上的分节。</li><li>请求超时。 使用setsockopt的SO_RCVTIMEO选项设置recv的超时时间。接收数据超时时，会发送RST包。</li></ol><p>当收到的segment的rst段为1，那么我们直接断开连接（非正常关闭），如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (seg.<span class="hljs-built_in">header</span>().rst) &#123;<br>    _sender.<span class="hljs-built_in">stream_in</span>().<span class="hljs-built_in">set_error</span>();<br>    _receiver.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">set_error</span>();<br>    _active = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>write</code>函数中，我们需要将数据写入到stream中，然后返回写入stream的data的长度，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">TCPConnection::write</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string &amp;data)</span> </span>&#123;<br>    <span class="hljs-comment">//如果data的为空则直接返回</span><br>    <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//否则将数据写入_sender的stream_in，等待fill_window将其封装为报文</span><br>    <span class="hljs-keyword">size_t</span> actually_write = _sender.<span class="hljs-built_in">stream_in</span>().<span class="hljs-built_in">write</span>(data);<br>    <span class="hljs-comment">//封装data为segment</span><br>    _sender.<span class="hljs-built_in">fill_window</span>();<br>    <span class="hljs-built_in">real_send</span>();<br>    <span class="hljs-comment">//返回实际长度</span><br>    <span class="hljs-keyword">return</span> actually_write;<br>&#125;<br></code></pre></td></tr></table></figure><p>在关闭TCP连接也就是“四次握手”的时候，我们会有一个<code>TIME_WAIT</code>的状态，在这个状态下客户端会等待2MSL才断开，这其实有两个原因：</p><ol><li>保证全双工的连接能够可靠关闭。</li><li>保证这次连接的数据段彻底从网络中消失。</li></ol><hr><h5 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h5><p>做到这里，我们的TCP也就算实现了基本功能，我们也就知道了TCP协议如何保证可靠传输：</p><ol><li>流量控制：TCP连接双方都有固定大小的缓冲空间，TCP接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据的时候，就提示发送方降低发送的速率。</li><li>拥塞控制：当网络拥塞时，减少数据的发送（这个在lab中没有什么体现）。</li><li>超时重传：当TCP发出一个段后，就会启动一个定时器，如果不能及时收到确认，就重发这个报文段。</li><li>校验和：（这个好像在后面的实验中有体现）。</li></ol><p>再补充一个知识点——<code>socket</code></p><h5 id="TCP长连接"><a href="#TCP长连接" class="headerlink" title="TCP长连接"></a>TCP长连接</h5><p>在HTTP1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束后就中断连接。但从HTTP1.1开始，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入如下字段:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">Connection:</span><span class="hljs-meta">keep</span>-alive<br></code></pre></td></tr></table></figure><p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p><h6 id="TCP保活机制"><a href="#TCP保活机制" class="headerlink" title="TCP保活机制"></a>TCP保活机制</h6><p>保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保活功能就是试图在服务器端检测到这种半开放的连接。对于设置了keepalive来说，当<strong>tcp</strong>检测到对端<strong>socket</strong>不再可用时<strong>(</strong>不能发出探测包<strong>,</strong>或探测包没有收到<strong>ACK</strong>的响应包<strong>),select</strong>会返回<strong>socket</strong>可读<strong>,</strong>并且在<strong>recv</strong>时返回<strong>-1,</strong>同时置上<strong>errno</strong>为ETIMEDOUT。此时TCP的状态是断开的。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>standford_cs144_lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6-实验参考书解析</title>
    <link href="/2022/01/10/xv6-%E5%AE%9E%E9%AA%8C%E5%8F%82%E8%80%83%E4%B9%A6%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/01/10/xv6-%E5%AE%9E%E9%AA%8C%E5%8F%82%E8%80%83%E4%B9%A6%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h3 id="第0章"><a href="#第0章" class="headerlink" title="第0章"></a>第0章</h3><h4 id="操作系统接口"><a href="#操作系统接口" class="headerlink" title="操作系统接口"></a>操作系统接口</h4><p>本书通过xv6操作系统来阐述操作系统的概念，它提供Unix操作系统中的基本接口，同时模仿Unix的内部设计。</p><blockquote><p>xv6提供了传统的内核概念，<strong>即一个向其他运行的程序提供服务的特殊程序</strong>，每一个运行中的进程都有指令、数据、栈的内存空间。进程通过系统调用使用内核服务。系统调用会进入内核，让内核执行服务然后返回。所以进程总是在用户空间和内核空间之间交替运行。</p></blockquote><p>我们看到上面加粗的那句话：</p><blockquote><p>xv6提供了传统的内核概念，即一个向其他运行的程序提供服务的特殊程序。</p></blockquote><p>如果说一个进程分了用户空间和内核空间，那么用户态-&gt;内核态相当于是cpu特权级别的切换和栈指针的切换，但进程还是那个进程。但上面那句话表达的意思是一旦用户进入内核态就又是另一个进程，这一点我感觉有点歧义。后面查阅了其他资料后才有了解释：</p><hr><p>我们都知道在linux中其实是没有实现TCB的，也就是没有实现线程的结构抽象，线程其实是用<code>task struct</code>实现的，也就是进程结构的一种复用，举个例子：我可以创建多个<code>task struct</code>，这些<code>task struct</code>都有自己的<code>context</code>，但是他们的堆、数据段、代码段等是共享的。当一个进程的多个线程需要动态分配更多内存时，他们的内存分配操作都是在同一个堆上完成的。但他们的内核栈和用户栈都是分离的。这在我们的<code>task_struct</code>中很容易实现。</p><p>回到xv6，xv6里面也是没有TCB结构的，只有类似于<code>task struct</code>的<code>proc</code>结构，我们同样可以运用同样的方式得到线程的抽象（具体结构实现看第四章）。</p><p>那么有了线程，再联系上面那句话——<code>xv6提供了传统的内核概念，即一个向其他运行的程序提供服务的特殊程序</code>，我们很自然的联想到用户线程：内核线程1：1的结构，每个用户线程都对应一个内核线程。上面那句话应该要表达的就是这个意思。</p><p>（后面我们可以看到，这个解释其实依然有问题，但他的参考书是这样写的，我们只能暂时这样理解）</p><hr><p>一个xv6进程由两部分组成，一部分是用户内存空间（指令、数据、栈），另一部分是仅对内核可见的进程状态。我们直接看看<code>proc</code>结构：</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Per-process state</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br><br>  <span class="hljs-comment">// p-&gt;lock must be held when using these:</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">procstate</span> <span class="hljs-title">state</span>;</span>        <span class="hljs-comment">// Process state</span><br>  <span class="hljs-keyword">void</span> *chan;                  <span class="hljs-comment">// If non-zero, sleeping on chan</span><br>  <span class="hljs-keyword">int</span> killed;                  <span class="hljs-comment">// If non-zero, have been killed</span><br>  <span class="hljs-keyword">int</span> xstate;                  <span class="hljs-comment">// Exit status to be returned to parent&#x27;s wait</span><br>  <span class="hljs-keyword">int</span> pid;                     <span class="hljs-comment">// Process ID</span><br><br>  <span class="hljs-comment">// wait_lock must be held when using this:</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">parent</span>;</span>         <span class="hljs-comment">// Parent process</span><br><br>  <span class="hljs-comment">// these are private to the process, so p-&gt;lock need not be held.</span><br>  uint64 kstack;               <span class="hljs-comment">// Virtual address of kernel stack</span><br>  uint64 sz;                   <span class="hljs-comment">// Size of process memory (bytes)</span><br>  <span class="hljs-keyword">pagetable_t</span> pagetable;       <span class="hljs-comment">// User page table</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">trapframe</span>;</span> <span class="hljs-comment">// data page for trampoline.S</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span>      <span class="hljs-comment">// swtch() here to run process</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">ofile</span>[<span class="hljs-title">NOFILE</span>];</span>  <span class="hljs-comment">// Open files</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">cwd</span>;</span>           <span class="hljs-comment">// Current directory</span><br>  <span class="hljs-keyword">char</span> name[<span class="hljs-number">16</span>];               <span class="hljs-comment">// Process name (debugging)</span><br>  <span class="hljs-keyword">pagetable_t</span> kernel_pt;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如上所示，<code>uint64 kstack;</code>代表内核栈地址，而<code>enum procstate state;</code>则是进程状态，<code>pagetable_t pagetable;</code>则是用户空间的页表。</p><p>内核在创建进程的时候，会为进程创建相应的堆栈。每个进程会有两个栈，一个用户栈，存在于用户空间，一个内核栈，存在于内核空间。当进程在用户空间运行时，CPU堆栈指针寄存器里面的内容是用户堆栈地址，使用用户栈；当进程在内核空间时，CPU堆栈指针寄存器里面的内容是内核栈空间地址，使用内核栈。当进程因为中断或者系统调用而陷入内核态时，进程所使用的堆栈也要从用户栈转到内核栈。进程进入内核态后，先把用户态堆栈的地址保存在内核栈中，然后设置堆栈指针寄存器的内容为内核栈的地址，这样就完成了用户栈向内核栈的切换。</p><p>我们来看看具体的资源分布情况：</p><ul><li>指令实现了程序的运算。</li><li>数据是用于运算中的变量。</li><li>栈管理了程序的过程调用。</li></ul><p>进程通过系统调用使用内核服务。系统调用会进入内核，让内核执行服务然后返回，所以进程总是在用户空间和内核空间中交替运行的。</p><div class="table-container"><table><thead><tr><th>系统调用</th><th>描述</th></tr></thead><tbody><tr><td>fork()</td><td>创建进程</td></tr><tr><td>exit()</td><td>结束当前进程</td></tr><tr><td>wait()</td><td>等待子进程结束</td></tr><tr><td>kill(pid)</td><td>结束pid所指进程</td></tr><tr><td>getpid()</td><td>获取当前进程pid</td></tr><tr><td>sleep(n)</td><td>睡眠n秒</td></tr><tr><td>exec(filename,*argv)</td><td>加载并执行一个文件</td></tr><tr><td>sbrk(n)</td><td>为进程内存空间增加n字节</td></tr><tr><td>open(filename,flags)</td><td>打开文件，flag指定读写模式</td></tr><tr><td>read(fd,buf,n)</td><td>从文件中读取n个字节到buf</td></tr><tr><td>write(fd,buf,n)</td><td>从buf中写n个字节到文件</td></tr><tr><td>close(fd)</td><td>关闭打开的fd</td></tr><tr><td>dup(fd)</td><td>复制fd</td></tr><tr><td>pipe(p)</td><td>创建管道，并把读和写的fd返回到p</td></tr><tr><td>chdir(dirname)</td><td>改变当前目录</td></tr><tr><td>mkdir(dirname)</td><td>创建新的目录</td></tr><tr><td>mknod(name,major,minor)</td><td>创建设备文件</td></tr><tr><td>fstat(fd)</td><td>返回文件信息</td></tr><tr><td>link(f1,f2)</td><td>给f1创建一个新名字（f2）</td></tr><tr><td>unlink(filename)</td><td>删除文件</td></tr></tbody></table></div><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>文件描述符是一个整数，它代表了一个进程可以读写的被内核管理的对象。进程可以通过多种方法获得一个文件描述符，如打开文件、目录、设备或者创建一个管道，或者复制已经存在的文件描述符。简单起见，我们常常把文件描述符指向的对象称为“文件”，文件描述符的接口是对文件、管道、设备等的抽象，这种抽象使得它们看上去就是字节流。</p><p>每个进程都有一张表，而xv6内核就是以文件描述符作为这张表的索引，所以每个进程都有一个从0开始的文件描述符空间。</p><h5 id="系统调用read和write"><a href="#系统调用read和write" class="headerlink" title="系统调用read和write"></a>系统调用read和write</h5><p>系统调用<code>read</code>和<code>write</code>从文件描述符所指的文件中读或者写n个字节。<code>read</code>从fd中读最多n个字节，将它们拷贝到buffer中，然后返回读出的字节数。每一个指向文件的文件描述符都和一个偏移量有关，</p><p>我们都知道在linux中有一切皆文件的说法，linux中的所有内容都是以文件的形式保存和管理的，在linux中，文件具体可分为以下几种类型：</p><ul><li><p>普通文件</p><p>类似txt、jpg这种可以直接拿来使用的都是普通文件，linux用户根据访问权限的不同可以对于这些文件进行查看、删除以及更改操作。</p></li><li><p>目录文件</p><p>在linux中，目录文件包含了此目录中各个文件的文件名以及执行这个文件的指针，打开目录等同于打开目录文件。</p></li><li></li></ul><h6 id="“一切皆文件”的利弊"><a href="#“一切皆文件”的利弊" class="headerlink" title="“一切皆文件”的利弊"></a>“一切皆文件”的利弊</h6><p>linux中所有读操作都可以用read函数来进行，几乎所有更改的操作都可以用write函数来进行。不过任何硬件设备都必须跟根目录下某一目录执行挂载操作，否则无法使用。</p><h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><p>xv6使用页表（由硬件实现）来为每个进程提供其独有的地址空间。页表将虚拟地址翻译为物理地址。xv6为每个进程维护了不同的页表，这样就能够合理地定义进程的地址空间了，一片地址空间包含了从虚拟地址0开始的用户内存，</p><h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><p>这一章细说页表。</p><p>操作系统通过页表机制实现了对内存空间的控制。除了传统的功能——让不同的进程各自的进程空间映射到相同的物理内存上，还能够为不同的进程的内存提供保护，我们还能够通过使用页表来间接实现一些特殊功能。xv6主要利用页表来</p><h3 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h3><p>运行程序时，CPU一直处于一个大循环中：取指、更新PC、执行，取指。但有些情况下用户程序需要进入内核，而不是执行下一条用户指令，这些情况包括设备信号的发出，用户程序的非法操作，也就是我们所说的用户态进入内核态的三种情况——中断、异常和系统调用。处理这些情况面临三大挑战：</p><ol><li>内核必须使处理器能够从用户态转换到内核态（并且再转回到用户态）。</li><li>内核和设备必须协调好他们并行的活动。</li><li>内核必须知道硬件接口的细节。</li></ol><p>用户程序通过系统调用请求系统服务；硬件产生引起操作系统注意的信号<code>interrupt</code>；非法程序操作产生的<code>exception</code>，都会使得用户态进入内核态。在所有的三种情况下，我们都要保证：系统必须保存寄存器以备将来的状态恢复。</p><h3 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h3><p>xv6运行在多处理器上，即计算机上有多个单独执行代码的CPU，这些CPU操作同一片地址空间并分享其中的数据结构，xv6必须建立一种合作机制防止它们互相干扰，即使是在单个处理器上，xv6也必须使用某些机制来防止中断处理程序与非中断代码之间的相互干扰。xv6为这两种情况的使用提供了底层概念——锁。</p><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p><code>trap</code>调用<code>syscall</code>，<code>syscall</code>从中断帧中读出系统调用号。</p><h3 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h3><h4 id="关于进程"><a href="#关于进程" class="headerlink" title="关于进程"></a>关于进程</h4><p>xv6这个版本还没有线程的概念，因此我们要从proc（线程）的视角来看待它的运行和调度过程。</p><blockquote><p>“在大部分情况下，我们认为内核态是一种CPU的特权态，这个特权态下，CPU可以执行这个特权态才允许执行的指令，访问这个特权态才运行访问的资源。这和当前的进程无关。”</p></blockquote><p>上面这句话描述的对象是CPU，从CPU的角度来说什么是内核态。对于CPU来说，用户态——内核态就是硬件上一个标志位的切换，从而可以执行一些特权级才能执行的指令。</p><p>那么我们从进程的角度来说内核态是怎么样的呢？援引陈海波教授《现代操作系统：原理与实现》的说法：</p><blockquote><p>处于进程地址空间最顶端的是内核内存。每个进程的虚拟地址空间里都映射了相同的内核内存。当进程在用户态运行时，内核内存对其不可见；只有当进程进入内核态时，才能访问内核内存。与用户态相似，内核部分也有内核需要的代码和数据段，当进程由于中断或系统调用进入内核后，会使用内核的栈。</p></blockquote><p>这一点在xv6的<code>proc</code>结构也有所体现，我们来介绍一下<code>proc</code>结构，详情见<code>kernel/proc.h</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Per-process state</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br><br>  <span class="hljs-comment">// p-&gt;lock must be held when using these:</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">procstate</span> <span class="hljs-title">state</span>;</span>        <span class="hljs-comment">// Process state</span><br>  <span class="hljs-keyword">void</span> *chan;                  <span class="hljs-comment">// If non-zero, sleeping on chan</span><br>  <span class="hljs-keyword">int</span> killed;                  <span class="hljs-comment">// If non-zero, have been killed</span><br>  <span class="hljs-keyword">int</span> xstate;                  <span class="hljs-comment">// Exit status to be returned to parent&#x27;s wait</span><br>  <span class="hljs-keyword">int</span> pid;                     <span class="hljs-comment">// Process ID</span><br><br>  <span class="hljs-comment">// wait_lock must be held when using this:</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">parent</span>;</span>         <span class="hljs-comment">// Parent process</span><br><br>  <span class="hljs-comment">// these are private to the process, so p-&gt;lock need not be held.</span><br>  uint64 kstack;               <span class="hljs-comment">// Virtual address of kernel stack</span><br>  uint64 sz;                   <span class="hljs-comment">// Size of process memory (bytes)</span><br>  <span class="hljs-keyword">pagetable_t</span> pagetable;       <span class="hljs-comment">// User page table</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">trapframe</span>;</span> <span class="hljs-comment">// data page for trampoline.S</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span>      <span class="hljs-comment">// swtch() here to run process</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">ofile</span>[<span class="hljs-title">NOFILE</span>];</span>  <span class="hljs-comment">// Open files</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">cwd</span>;</span>           <span class="hljs-comment">// Current directory</span><br>  <span class="hljs-keyword">char</span> name[<span class="hljs-number">16</span>];               <span class="hljs-comment">// Process name (debugging)</span><br>  <span class="hljs-keyword">pagetable_t</span> kernel_pt;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在上述代码中，我们可以看到如下成员：</p><ul><li><p><code>int killed</code>，表示进程是否被杀死；</p></li><li><p><code>struct proc *parent</code>，指向父进程；</p></li><li><p><code>uint sz</code>，进程空间的大小；</p><p>……..</p></li></ul><p>我们可以看到有一个<code>uint64 kstack</code>的成员，这就是进程内核栈的地址。当进程由于中断或系统调用进入内核后，会使用内核的栈。当然，在linux中，<code>proc</code>结构的名字叫<code>task struct</code>，准确的说它们都是进程控制块。</p><hr><p>值得注意的是：在linux内核中，没有专门的线程这个概念，而是把线程当作普通的进程来看待，在内核里面还是以<code>task_struct</code>数据结构来描述，并没有特殊的数据结构或者调度算法来描述线程。</p><hr><p>进程的上下文包括进程运行时的寄存器状态，其能够用于保存和恢复一个进程在处理器上运行的状态。我们看看context的结构就知道了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Saved registers for kernel context switches.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> &#123;</span><br>  uint64 ra;<br>  uint64 sp;<br><br>  <span class="hljs-comment">// callee-saved</span><br>  uint64 s0;<br>  uint64 s1;<br>  uint64 s2;<br>  uint64 s3;<br>  uint64 s4;<br>  uint64 s5;<br>  uint64 s6;<br>  uint64 s7;<br>  uint64 s8;<br>  uint64 s9;<br>  uint64 s10;<br>  uint64 s11;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里保存的全是寄存器状态，当操作系统需要切换当前执行的进程的时候就会使用上下文切换机制。该进程会将前一个进程的寄存器状态保存到PCB中，准确的说是PCB的context中，然后将下一个进程先前保存的状态写入寄存器，从而切换到该进程执行。</p><h4 id="调度与多路复用"><a href="#调度与多路复用" class="headerlink" title="调度与多路复用"></a>调度与多路复用</h4><p>当进程数&gt;处理器的数量的时候，我们就要考虑如何分享处理器资源，即如何调度资源。通常我们对进程造成一个自己独占处理器的家乡，然后让操作系统的多路复用机制将单独的一个物理处理器模拟为多个虚拟处理器。</p><p>当一个进程等待磁盘请求的时候，xv6使之进入睡眠状态，然后调度执行另一个进程。另外，当一个进程耗尽了它在处理器上的时间片的时候，xv6使用时钟中断强制它停止运行，这样调度器才能调度运行其他进程，这样的多路复用机制为进程提供了独占处理器的假象。</p><h5 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h5><p>如何从运行的一个进程切换到另一个进程？</p><ol><li>当一个程序正在执行的过程中，中断或系统调用发生可以使得CPU的控制权会从当前进程转移到操作系统内核。</li><li>操作系统内核负责保存进程i在CPU中的上下文（程序计数器、寄存器）到$PCB_i$(操作系统分配给进程的一个内存块)中。</li><li>从$PCB_j$取出进程j的CPU上下文，将CPU控制权转移给进程j,开始执行进程j的指令。</li></ol><p>xv6的参考书里面对上述过程有详细解释：</p><h6 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h6><p>xv6在底层实现了两种上下文切换：</p><ol><li>从进程的内核线程切换到当前CPU的调度器线程；</li><li>从调度器线程切换到进程的内核线程。</li></ol><p>==我看到xv6的参考书上这样说感到很怪，准确的说xv6还没有引入线程的概念，更没有线程的实现。==</p><h6 id="具体的实现过程"><a href="#具体的实现过程" class="headerlink" title="具体的实现过程"></a>具体的实现过程</h6><p>进程的切换是通过用户态——内核态切换、切换到调度器、切换到新进程的内核线程、最后返回用户态实现的。如下图所示：</p><p><img src="https://tvax2.sinaimg.cn/large/008qL1EEly1h05ya2e0tlj30fp07q0ua.jpg" alt=""></p><p>每个xv6进程都有自己的内核栈以及寄存器集合。每个CPU都有一个单独的调度器线程，这样调度就不会发生在进程的内核线程中，而是在此调度器线程中，线程切换涉及到了保存旧线程的CPU寄存器，恢复新线程之前保存的寄存器。</p><p>当进程让出CPU时，进程的内核线程调用swtch来保存自身进程的上下文然后返回到调度器的上下文中。这也就是第一个swtch，第二个swtch同理，swtch简单的保存和恢复寄存器集合。每个上下文以结构体<code>struct context*</code>表示，实际上就是一个保存在内核栈中的指针，swtch有两个参数，<code>struct context *old</code>，<code>struct context *new</code>。</p><p>回到上面我标成黄色的句子，xv6并没有线程，但是在参考书中却引入了线程的概念。我们都知道在linux里面没有严格区分进程和线程，他们都是用<code>task struct</code>作为抽象实现的，只是在一些共享资源上共用了一个指针。</p><p>在xv6中，虽然只有proc结构的抽象，但是一个进程下有用户态线程和内核态线程，其中<code>kstack</code>是内核栈的地址，当需要进行用户态-内核态的切换的时候：</p><ol><li><p>将对应的用户栈的PC地址和寄存器信息保存起来（xv6中是保存在内核栈），方便后续内核方法调用完毕后，恢复用户方法执行的现场。</p></li><li><p>将CPU的字段改为内核态（硬件标志位），将内核段对应的代码地址写入到PC寄存器中，设置堆栈指针寄存器的内容为内核栈的地址，然后开始执行内核方法。</p></li><li><p>当内核方法执行完毕后，会将CPU的字段改为用户态，然后利用之前用户态的信息来恢复用户栈的执行。</p></li></ol><p>在linux中，线程的创建是<code>vfork</code>函数创建的，该函数创建出的子进程与父进程共用一个地址空间。所以，可以将父进程中的代码和函数分解，并分别交给这些子进程并行执行。这种方式相较于普通进程执行的方案更为高效。事实上，我们可以将这些子进程看作<strong>线程</strong>，而把上图中的father和child统称为一个进程。这样，我们就可以知道线程在进程和OS中扮演的角色。</p><h3 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h3><h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p>正如我们在第〇章所说，xv6的文件系统中使用了类似Unix的文件、文件描述符、目录和路径，并且把数据存储到一块内存，我们通过xv6中的描述来具体看看：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*, <span class="hljs-keyword">int</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>第一个参数代表文件路径字符串，第二个参数是<code>flag</code>，表示以何种方式打开文件，返回值是文件描述符。说到这里，我们来说说文件描述符指向的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;<br>  <span class="hljs-keyword">int</span> ref; <span class="hljs-comment">// reference count</span><br>  <span class="hljs-keyword">char</span> readable;<span class="hljs-comment">//能读</span><br>  <span class="hljs-keyword">char</span> writable;<span class="hljs-comment">//能写</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe</span> *<span class="hljs-title">pipe</span>;</span> <span class="hljs-comment">// FD_PIPE</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>;</span>  <span class="hljs-comment">// FD_INODE and FD_DEVICE</span><br>  uint off;          <span class="hljs-comment">// FD_INODE</span><br>  <span class="hljs-keyword">short</span> major;       <span class="hljs-comment">// FD_DEVICE</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>我们从一个实例来看看xv6的调度情况：</p><p>如上图所示：我们从一个shell语句开始，例如我们执行<code>read</code>这个语句，我们为了进入内核，要先执行如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">read:<br>li a7,SYS_read<br>ecall<br>ret<br>.global read<br></code></pre></td></tr></table></figure><p>在上述代码中，我们会将系统调用号<code>SYS_read</code>放入a7寄存器，然后调用ecall指令，该指令将CPU的特权级从用户级改为内核级。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT_s.081_Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT-6.s081-Lab2-system calls</title>
    <link href="/2022/01/10/MIT-s-081-Lab2-system-calls/"/>
    <url>/2022/01/10/MIT-s-081-Lab2-system-calls/</url>
    
    <content type="html"><![CDATA[<p>在上一个实验中我们使用系统调用编写了一些utilities，在这个实验中我们需要为xv6增加一些系统调用，以便我们理解系统调用是如何工作的，并向我们展示xv6内核的一些内部结构。</p><p>我们先来说说什么是系统调用，操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务，主要包括命令接口和程序接口。其中，程序接口由一组系统调用组成。应用程序通过系统调用请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌握，因此在用户程序中，凡是与资源有关的操作(如存储分配、I/O操作、文件管理等)，都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。</p><p>我们来看如下例子，来源于<a href="http://blog.codepiano.com/2017/03/01/read-file-from-disk">博客</a>：</p><hr><p>假设场景是一个linux操作系统中运行的进程P需要读取文件/home/user/text.txt。</p><p>如果进程P需要读取文件，首先要发起系统调用open，传入文件路径和相关参数，执行系统调用后操作系统会从用户态转换到内核态，切换到内核态后，操作系统调用相应的处理器开始处理读取文件的请求。然后内核控制硬件。</p><p>这个时候并不会直接读取磁盘中的文件到进程掌握的内存，而是先进行权限方面的检查，如果进程可以访问这个文件，就根据文件路径去查找文件对应的inode编号，这部分属于文件系统的内容，这里不做说明。</p><p>在获取inode以后，操作系统生成一个文件描述符，存储在进程P的数据结构中，通过文件描述福可以索引到文件的打开方式和要打开文件的inode。至此系统调用open完成。</p><p>进程在得到文件描述符之后，还要再发起系统调用read，传入文件描述符来读取文件内容，在这里读取操作同样需要切换到内核态由内核代为完成，切换到内核态后，操作系统通过文件描述符找到对应的inode，通过inode来确定文件存储在磁盘的哪个扇区，然后读取这些扇区，把内容读取到内核的地址空间里面。</p><p>磁盘的IO完成之后，磁盘会触发一个中断，CPU会暂时终止当前线程的执行，保存相关的寄存器信息，然后把读取到的内容从内核地址空间拷贝到进程P的地址空间里面，然后进程P的状态设置为runnable，进程P排队等待自己的CPU时间片，被调度器调度以后可以继续执行。</p><hr><h4 id="syscall-c"><a href="#syscall-c" class="headerlink" title="syscall.c"></a>syscall.c</h4><p>syscall.c是系统调用程序，我们先来介绍在syscall中的几个函数。</p><h5 id="argint函数"><a href="#argint函数" class="headerlink" title="argint函数"></a>argint函数</h5><p>argint的函数原型为<code>int argint(int n,int *ip)</code>，其意义为获得第n个32位调用参数，该函数调用了argraw函数，在得到了相应的数据之后，保存在以ip为地址的空间中。</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(argint(<span class="hljs-number">0</span>,&amp;pid)&lt;<span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="argraw函数"><a href="#argraw函数" class="headerlink" title="argraw函数"></a>argraw函数</h5><p>argraw的函数原型为<code>static uint64 argraw(int n)</code>，其意义为返回相应的寄存器中保存的值。代码如下图所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">switch</span> (n) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br><span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a0;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br><span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a1;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br><span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a2;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br><span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a3;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br><span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a4;<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br><span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a5;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="syscall函数"><a href="#syscall函数" class="headerlink" title="syscall函数"></a>syscall函数</h5><p>syscall函数代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">syscall</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> num;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  num = p-&gt;trapframe-&gt;a7;<br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;<br>    p-&gt;trapframe-&gt;a0 = syscalls[num]();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,<br>            p-&gt;pid, p-&gt;name, num);<br>    p-&gt;trapframe-&gt;a0 = <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>设置一个proc指针，指向myproc，在<code>num = p-&gt;trapframe-&gt;a7;</code>中，将a7寄存器中的值赋值给num，a7寄存器中保存的就是系统调用的调用号，我们可以在user/usys.s中看见相关的代码（以fork系统调用为例）：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">fork:<br> li a7, SYS_fork<br> ecall<br> ret<br>.global <span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure><p>然后判断调用号是否正确，如果正确的话就将<code>syscalls[num]()</code>赋值给a0，syscalls中调用号对应sys_xxx函数，也就是将要调用的函数的返回值赋值给a0。代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">uint64</span> <span class="hljs-params">(*syscalls[])</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>= &#123;<br>[SYS_fork]    sys_fork,<br>[SYS_exit]    sys_exit,<br>[SYS_wait]    sys_wait,<br>[SYS_pipe]    sys_pipe,<br>[SYS_read]    sys_read,<br>[SYS_kill]    sys_kill,<br>[SYS_exec]    sys_exec,<br>[SYS_fstat]   sys_fstat,<br>[SYS_chdir]   sys_chdir,<br>[SYS_dup]     sys_dup,<br>[SYS_getpid]  sys_getpid,<br>[SYS_sbrk]    sys_sbrk,<br>[SYS_sleep]   sys_sleep,<br>[SYS_uptime]  sys_uptime,<br>[SYS_open]    sys_open,<br>[SYS_write]   sys_write,<br>[SYS_mknod]   sys_mknod,<br>[SYS_unlink]  sys_unlink,<br>[SYS_link]    sys_link,<br>[SYS_mkdir]   sys_mkdir,<br>[SYS_close]   sys_close,<br>[SYS_trace]   sys_trace,<br>&#125;;<br></code></pre></td></tr></table></figure><p>同样，我们在syscalls.c中定义了如下的外部函数，部分外部函数的实现在sysproc.c中，代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_chdir</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_close</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_dup</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_exec</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_exit</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_fork</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_fstat</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_getpid</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_kill</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_link</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_mkdir</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_mknod</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_open</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_pipe</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_read</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_sbrk</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_sleep</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_unlink</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_wait</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_write</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_uptime</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_trace</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="sysproc-c"><a href="#sysproc-c" class="headerlink" title="sysproc.c"></a>sysproc.c</h4><p>sysproc.c是系统进程，正如我们在xv6文档看到的那样，起到由用户转到内核的作用，通过syscall，可以进入sysproc执行相应的函数。</p><h5 id="proc数据结构"><a href="#proc数据结构" class="headerlink" title="proc数据结构"></a>proc数据结构</h5><p>proc数据结构表示进程状态，其数据结构如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Per-process state</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br><br>  <span class="hljs-comment">// p-&gt;lock must be held when using these:</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">procstate</span> <span class="hljs-title">state</span>;</span>        <span class="hljs-comment">// Process state</span><br>  <span class="hljs-keyword">void</span> *chan;                  <span class="hljs-comment">// If non-zero, sleeping on chan</span><br>  <span class="hljs-keyword">int</span> killed;                  <span class="hljs-comment">// If non-zero, have been killed</span><br>  <span class="hljs-keyword">int</span> xstate;                  <span class="hljs-comment">// Exit status to be returned to parent&#x27;s wait</span><br>  <span class="hljs-keyword">int</span> pid;                     <span class="hljs-comment">// Process ID</span><br><br>  <span class="hljs-comment">// wait_lock must be held when using this:</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">parent</span>;</span>         <span class="hljs-comment">// Parent process</span><br><br>  <span class="hljs-comment">// these are private to the process, so p-&gt;lock need not be held.</span><br>  uint64 kstack;               <span class="hljs-comment">// Virtual address of kernel stack</span><br>  uint64 sz;                   <span class="hljs-comment">// Size of process memory (bytes)</span><br>  <span class="hljs-keyword">pagetable_t</span> pagetable;       <span class="hljs-comment">// User page table</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">trapframe</span>;</span> <span class="hljs-comment">// data page for trampoline.S</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span>      <span class="hljs-comment">// swtch() here to run process</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">ofile</span>[<span class="hljs-title">NOFILE</span>];</span>  <span class="hljs-comment">// Open files</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">cwd</span>;</span>           <span class="hljs-comment">// Current directory</span><br>  <span class="hljs-keyword">char</span> name[<span class="hljs-number">16</span>];               <span class="hljs-comment">// Process name (debugging)</span><br>  uint64 mask;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h4><p>这个模块要实现系统调用跟踪，添加一个新的系统调用跟踪功能，即创建一个新的跟踪系统调用来控制跟踪。我们首先分析trace程序，在user/trace.c中可以看到第十七行为<code>if (trace(atoi(argv[1])) &lt; 0)</code>，我们可以得知trace函数的原型为<code>int trace(int n)</code>其中，n为第一个参数，也就是<code>1&lt;&lt;SYS_xxx</code>,这个SYS_xxx是一个整数“掩码”（这么翻译的，感觉翻译得不太好，调用号更合适些），每一个不同的SYS_xxx对应不同的系统调用。我们可以看看trace函数中的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/param.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-keyword">char</span> *nargv[MAXARG];<br><br>  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">3</span> || (argv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &lt; <span class="hljs-string">&#x27;0&#x27;</span> || argv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &gt; <span class="hljs-string">&#x27;9&#x27;</span>))&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: %s mask command\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (trace(atoi(argv[<span class="hljs-number">1</span>])) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;%s: trace failed\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">2</span>; i &lt; argc &amp;&amp; i &lt; MAXARG; i++)&#123;<br>    nargv[i<span class="hljs-number">-2</span>] = argv[i];<br>  &#125;<br>  exec(nargv[<span class="hljs-number">0</span>], nargv);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述程序中，调用了trace函数，trace函数的参数就是在终端输入的trace指令的第一个参数，trace函数通过<code>entry(trace)</code>从用户态转到内核态，执行后续操作。在内核态中会将第一个参数也就是系统调用号保存在myproc-&gt;mask中，后续调用exec函数的时候会通过之前保存的mask值来跟踪相应的系统调用（后续详细讲解）。</p><p>在上述程序中，输入的参数必须大于2个，也就是必须要有一个调用号参数，还要有一个另外的一个指令参数，跟踪的正是这个指令中相应调用号的系统调用。正如上述代码中第三个for循环所示，将从第二个参数开始之后的所有参数复制到nargv，然后调用exec函数执行该指令。</p><p>在实验文档中给出的例子中，执行命令<code>trace 32 grep hello README</code>的意思是，跟踪grep命令中调用号为5（32=1&lt;&lt;5）的系统调用。我们可以在syscall.h中看到这些调用号，如下代码所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// System call numbers</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_fork    1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_exit    2</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_wait    3</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_pipe    4</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_read    5</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_kill    6</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_exec    7</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_fstat   8</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_chdir   9</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_dup    10</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_getpid 11</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_sbrk   12</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_sleep  13</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_uptime 14</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_open   15</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_write  16</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_mknod  17</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_unlink 18</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_link   19</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_mkdir  20</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_close  21</span><br></code></pre></td></tr></table></figure><p>那么32就对应<code>SYS_read=5</code>。也就是说要跟踪read系统调用。</p><p>因为trace本身也是系统调用之一，在user/usys.pl中加入从用户态进入内核态的入口<code>entry(trace)</code>，生成汇编语言代码，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">trace:<br> li a7, SYS_trace<br> ecall<br> ret<br></code></pre></td></tr></table></figure><p>可以看到，将SYS_trace保存在a7寄存器中。系统调用的ecall指令会使用a0和a7寄存器，其中a7寄存器保存的是系统进程号，a0寄存器保存的是系统调用参数，返回值会保存在a0寄存器中（unix中是这样，拿到xv6中应该也是的，ecall的实现过程在文章开头给出）。</p><p>（这一部分我是参考了CSDN上的博主@//夜游神的<a href="https://blog.csdn.net/qq_33894666/article/details/121545027">博客</a>)</p><p>在kernel/syscall.h中加入系统进程号<code>#define SYS_trace 22</code>。</p><p>在kernel/proc.h的结构体proc中加入一个新成员<code>uint64 mask</code>。（我看到有的博主写的是<code>uint32 mask</code>，个人认为位数的多少取决于系统调用的数量。到trace为止，系统调用的数量为22）。</p><p>在kernel/sysproc.c中实现<code>uint64 sys_trace(void)</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">uint64 <span class="hljs-title">sys_trace</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> mask;<span class="hljs-comment">//这里的int也可以换成长整数</span><br>    <span class="hljs-keyword">if</span> (argint(<span class="hljs-number">0</span>,&amp;mask) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    myproc()-&gt;mask = mask;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在文章开头我们讲过了<code>int argint(int n,int *ip)</code>函数，，trace只有一个参数，放在a0中，在这里我们要将a0的值保存在mask中，即<code>if(argint(0,&amp;mask)&lt;0) return -1;</code>。将mask赋值给myproc()-&gt;mask，作为我们进程的状态结构体的一部分。</p><p>在kernel/syscall.c中补充syscall函数，代码如下如所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (p-&gt;mask &amp; (<span class="hljs-number">1</span> &lt;&lt; num))<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, callnames[num - <span class="hljs-number">1</span>], p-&gt;trapframe-&gt;a0);<br></code></pre></td></tr></table></figure><p>上述代码中callnamens数组如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* callnames[] = &#123;<br><span class="hljs-string">&quot;fork&quot;</span>,<span class="hljs-string">&quot;exit&quot;</span>,<span class="hljs-string">&quot;wait&quot;</span>,<span class="hljs-string">&quot;pipe&quot;</span>,<span class="hljs-string">&quot;read&quot;</span>,<span class="hljs-string">&quot;kill&quot;</span>,<span class="hljs-string">&quot;exec&quot;</span>,<span class="hljs-string">&quot;fstat&quot;</span>,<span class="hljs-string">&quot;chdir&quot;</span>,<br><span class="hljs-string">&quot;dup&quot;</span>,<span class="hljs-string">&quot;getpid&quot;</span>,<span class="hljs-string">&quot;sbrk&quot;</span>,<span class="hljs-string">&quot;sleep&quot;</span>,<span class="hljs-string">&quot;uptime&quot;</span>,<span class="hljs-string">&quot;open&quot;</span>,<span class="hljs-string">&quot;write&quot;</span>,<span class="hljs-string">&quot;mknod&quot;</span>,<br><span class="hljs-string">&quot;unlink&quot;</span>,<span class="hljs-string">&quot;link&quot;</span>,<span class="hljs-string">&quot;mkdir&quot;</span>,<span class="hljs-string">&quot;close&quot;</span>,<span class="hljs-string">&quot;trace&quot;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>p-&gt;pid是进程号，callnamens是系统调用名称，p-&gt;trapframe-&gt;a0是返回值。</p><p>下面就可以好好说说系统调用响应的过程了：</p><p>在命令行输入<code>trace 32 grep hello README</code>指令，然后调用trace程序(如上述代码所示)，首先执行trace函数，待trace函数执行完后执行grep命令。在trace函数中（trace的系统调用只有sys_trece)，通过entry(trace)将sys_trace系统调用号保存在a7寄存器中，调用ecall进入内核态（用户态进入内核态的具体实现会在lab4中体现）。在内核态中首先调用syscall函数，将a7的值赋值给num，由此调用sys_trace函数，将我们的命令的第一个参数保存在<code>myproc()-&gt;mask</code>中，方便后续的命令进行比较。由于trace函数只有trace一个系统调用，num的值为SYS_trace，但是此时的mask为read的调用号，所以不进行打印系统调用的过程。</p><p>执行完trace函数之后通过exec命令执行grep命令，grep命令会用到调用号为5的系统调用read，通过entry(read)进入内核态后，先调用syscall函数，将a7的值赋值给num，然后执行sys_read函数，然后进行判定，<code>p-&gt;mask &amp; (1 &lt;&lt; num)</code>，如果这两个值相等，就可以打印相应系统调用的进程号、名称以及返回值。</p><h4 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h4><p>在这个作业中，我们要添加一个系统调用sysinfo，它收集有关正在运行的系统调用的信息。系统调用有一个参数：指向strcut sysinfo的指针。</p><ol><li><p>在Makefile中加入<code>$U/_sysinfotest</code>。</p></li><li><p>在user.h中加入<code>int sysinfo(struct sysinfo*)</code>和<code>struct sysinfo</code>。</p></li><li><p>在usys.pl中加入系统调用入口<code>entry(&quot;sysinfo&quot;)</code>。</p></li><li><p>在kernel/syscall.h中加入sysinfo的系统调用号<code>#define SYS_sysinfo 23</code>。</p></li><li><p>在kernel/syscall.c函数中加入外部函数生命和函数指针，代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_sysinfo</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">uint64</span> <span class="hljs-params">(*syscalls[])</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>= <br>&#123;<br>    .....<br>    [SYS_sysinfo] sys_sysinfo<br>&#125;;<br><br></code></pre></td></tr></table></figure></li></ol><p>在上述完成后我们就将基础工作完成了。</p><p>在正式分析sysinfotest函数之前，我们要先搞懂<code>struct sysinfo</code>数据结构，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span> &#123;</span><br>  uint64 freemem;   <span class="hljs-comment">// amount of free memory (bytes)</span><br>  uint64 nproc;     <span class="hljs-comment">// number of process</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在sysinfo数据结构中，有两个uint64变量，一个是freemem，代表空闲内存的大小，单位为bytes；另一个是nproc，代表进程的数量。</p><p>现在来具体分析sysinfotest要实现的功能，该系统调用收集正在运行的系统调用的信息。在sysinfotest的主函数如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sysinfotest: start\n&quot;</span>);<br>  testcall();<br>  testmem();<br>  testproc();<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sysinfotest: OK\n&quot;</span>);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述主函数中，首先调用了testcall函数，testcall函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">testcall</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span> <span class="hljs-title">info</span>;</span><br>  <br>  <span class="hljs-keyword">if</span> (sysinfo(&amp;info) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;FAIL: sysinfo failed\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (sysinfo((struct sysinfo *) <span class="hljs-number">0xeaeb0b5b00002f5e</span>) !=  <span class="hljs-number">0xffffffffffffffff</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;FAIL: sysinfo succeeded with bad argument\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在sysinfo函数中，定义了一个sysinfo变量info。调用sysinfo函数，也就是在内核中调用sys_sysinfo函数，我们在上文中提到，调用sysinfo函数，会在entry中将sys_info的系统调用号赋值给a7（同时将参数赋值给a0），然后进入内核进行调用。那么我们就要来完成sys_sysinfo函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">sys_sysinfo</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>uint64 addr;<br><span class="hljs-keyword">if</span> (argaddr(<span class="hljs-number">0</span>,&amp;addr) &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span> <span class="hljs-title">sf</span>;</span><br>sf.nproc = nop();<span class="hljs-comment">//nop 后面加</span><br>sf.freemem = freemem();<span class="hljs-comment">// 后面加</span><br><span class="hljs-keyword">if</span> (copyout(myproc()-&gt;pagetable,addr,(<span class="hljs-keyword">char</span>*)&amp;sf,<span class="hljs-keyword">sizeof</span>(sf)) &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在sys_sysinfo中定义了一个uint64变量addr，sysinfo的参数也就是a0赋值给addr，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">testmem</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span> <span class="hljs-title">info</span>;</span><br>  uint64 n = countfree();<br>  <br>  sinfo(&amp;info);<br><br>  <span class="hljs-keyword">if</span> (info.freemem!= n) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;FAIL: free mem %d (bytes) instead of %d\n&quot;</span>, info.freemem, n);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span>((uint64)sbrk(PGSIZE) == <span class="hljs-number">0xffffffffffffffff</span>)&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sbrk failed&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br><br>  sinfo(&amp;info);<br>    <br>  <span class="hljs-keyword">if</span> (info.freemem != n-PGSIZE) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;FAIL: free mem %d (bytes) instead of %d\n&quot;</span>, n-PGSIZE, info.freemem);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span>((uint64)sbrk(-PGSIZE) == <span class="hljs-number">0xffffffffffffffff</span>)&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sbrk failed&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br><br>  sinfo(&amp;info);<br>    <br>  <span class="hljs-keyword">if</span> (info.freemem != n) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;FAIL: free mem %d (bytes) instead of %d\n&quot;</span>, n, info.freemem);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testproc</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span> <span class="hljs-title">info</span>;</span><br>  uint64 nproc;<br>  <span class="hljs-keyword">int</span> status;<br>  <span class="hljs-keyword">int</span> pid;<br>  <br>  sinfo(&amp;info);<br>  nproc = info.nproc;<br><br>  pid = fork();<br>  <span class="hljs-keyword">if</span>(pid &lt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sysinfotest: fork failed\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>    sinfo(&amp;info);<br>    <span class="hljs-keyword">if</span>(info.nproc != nproc+<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sysinfotest: FAIL nproc is %d instead of %d\n&quot;</span>, info.nproc, nproc+<span class="hljs-number">1</span>);<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  wait(&amp;status);<br>  sinfo(&amp;info);<br>  <span class="hljs-keyword">if</span>(info.nproc != nproc) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sysinfotest: FAIL nproc is %d instead of %d\n&quot;</span>, info.nproc, nproc);<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT_s.081_Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Goroutine</title>
    <link href="/2021/12/17/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%96%9C%E6%AC%A2Go%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94Goroutine/"/>
    <url>/2021/12/17/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%96%9C%E6%AC%A2Go%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94Goroutine/</url>
    
    <content type="html"><![CDATA[<p>Go语言中实现了两种并发模型，一种是依赖于共享内存实现的线程-锁并发模型，另一种则是CSP。作为Go并发核心编程核心的CSP理论的核心概念只有一个：同步通信。</p><p>Goroutine是由Go运行时管理的轻量级线程（协程）。Goroutine和操作系统线程相比，Goroutine的资源占用和使用代价非常小，大小默认是2K字节。Goroutine调度的切换也不在操作系统的内部完成，代价很低。所以一个Go程序可以创建成千上万个并发的Goroutine，而把这些Goroutine按照一定算法放到cpu上执行的程序，就成了Goroutine调度器。</p><p>开发go程序的时候，时常需要使用goroutine并发处理任务，有时候这些goroutine是相互独立的，而有的时候，多个goroutine之间常常是需要同步与通信的，值得注意的是，有时候主goroutine需要控制它所属的子goroutine。</p><h5 id="Goroutine和Coroutine的区别"><a href="#Goroutine和Coroutine的区别" class="headerlink" title="Goroutine和Coroutine的区别"></a>Goroutine和Coroutine的区别</h5><hr><p>补充一下常见的面经：</p><h6 id="进程、线程、协程的区别："><a href="#进程、线程、协程的区别：" class="headerlink" title="进程、线程、协程的区别："></a>进程、线程、协程的区别：</h6><p>进程是系统进行资源调度和分配的单位，线程是程序执行的单位，也就是CPU调度和分配的单位，线程作为进程下属的单位，可以享用进程被分配的资源，一个进程下的多个线程可以共享该进程的资源。而进程之间是不能共享资源的，进程间想要互相通信，必须通过进程间通信。</p><p>协程是一种用户态的轻量级线程，协程的调度完全由用户控制，协程拥有自己的寄存器上下文和栈。一个线程可以有多个协程，一个进程也可以有多个协程。进程线程都是同步机制，而协程是异步机制。线程是抢占式，而协程是非抢占式，所以需要用户自己释放使用权来切换到其他协程。</p><p>如下图所示，我们可以更好的理解协程和线程的关系，<a href="https://juejin.cn/post/6995091405563494431">图片来源</a>。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a22b3af8462e41f8adb601eb34c22bb6~tplv-k3u1fbpfcp-watermark.awebp" alt=""></p><h6 id="同步与异步的区别："><a href="#同步与异步的区别：" class="headerlink" title="同步与异步的区别："></a>同步与异步的区别：</h6><p>同步是阻塞模式，而异步是非阻塞模式：</p><ul><li><p>同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个请求就会一直等待下去，直到收到返回信息才继续执行下去。</p></li><li><p>异步是进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程处理，这样可以提高执行的效率。</p><p>知乎上这个<a href="https://zhuanlan.zhihu.com/p/67452727">文章</a>说得很好，分享给大家：</p><blockquote><p>同步异步 ， 举个例子来说，一家餐厅吧来了5个客人，<strong>同步</strong>的意思就是说，来第一个点菜，点了个鱼，好， 厨师去捉鱼杀鱼，过了半小时鱼好了给第一位客人，开始下位一位客人，就这样一个一个来，按<strong>顺序</strong>来相同， <strong>异步</strong>呢，异步的意思就是来第一位客人，点什么，点鱼，给它一个牌子，让他去一边等吧，下一位客人接着点菜，点完接着点让厨师做去吧，哪个的菜先好就先端出来。</p><p>同步的优点是：同步是按照顺序一个一个来，不会乱掉，更不会出现上面代码没有执行完就执行下面的代码， 缺点：是解析的速度没有异步的快；</p><p>异步的优点是：异步是接取一个任务，直接给后台，在接下一个任务，一直一直这样，谁的先读取完先执行谁的， 缺点：没有顺序 ，谁先读取完先执行谁的 ，会出现上面的代码还没出来下面的就已经出来了，会报错。</p></blockquote></li></ul><hr><p>goroutine 来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被 runtime 调度，转移到其他可运行的线程上。最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发。</p><p>Go 中，协程被称为 goroutine，它非常轻量，一个 goroutine 只占几 KB，并且这几 KB 就足够 goroutine 运行完，这就能在有限的内存空间内支持大量 goroutine，支持了更多的并发。虽然一个 goroutine 的栈只占几 KB，但实际是可伸缩的，如果需要更多内容，runtime 会自动为 goroutine 分配。</p><p>C#、Lua、Python 语言都支持 coroutine 特性。coroutine 与 goroutine 在名字上类似，都可以将函数或者语句在独立的环境中运行，但是它们之间有两点不同：</p><ul><li>goroutine 可能发生并行执行；</li><li>但 coroutine 始终顺序执行。</li></ul><p>goroutine意味着并行（或者可以以并行方式部署），coroutine一般来说不是这样。狭义的说，goroutine可能发生在多线程环境下，coroutine始终发生在单线程。goroutine间使用channel通信，coroutine使用yield和resume操作。coroutine的运行机制属于协作式任务处理，goroutine属于抢占式任务处理。</p><h4 id="channel之于Goroutine"><a href="#channel之于Goroutine" class="headerlink" title="channel之于Goroutine"></a>channel之于Goroutine</h4><h5 id="无缓冲channel和有缓冲channel"><a href="#无缓冲channel和有缓冲channel" class="headerlink" title="无缓冲channel和有缓冲channel"></a>无缓冲channel和有缓冲channel</h5><p>无缓冲channel发送动作和接收动作是同时发生的，例如 <code>ch := make(chan int)</code> ，如果没 <code>goroutine</code> 读取接收者<code>&lt;-ch</code> ，那么发送者<code>ch&lt;-</code> 就会一直阻塞，<strong>缓冲</strong> <code>channel</code> 类似一个队列，只有队列满了才可能发送阻塞。</p><h5 id="如何优化channel"><a href="#如何优化channel" class="headerlink" title="如何优化channel"></a>如何优化channel</h5><p>和学长聊到这个问题，深夜无眠，写一下自己的理解。</p><p>channel 的构造语句 <code>make(chan int)</code>，将会被 golang 编译器翻译为 <code>runtime.makechan</code> 函数, 其函数签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makechan</span><span class="hljs-params">(t *chantype, size <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">hchan</span></span><br></code></pre></td></tr></table></figure><p>其中，<code>t *chantype</code> 即构造 channel 时传入的元素类型。<code>size int</code> 即用户指定的 channel 缓冲区大小，不指定则为 0。该函数的返回值是 <code>*hchan</code>。hchan 则是 channel 在 golang 中的内部实现。其定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> hchan <span class="hljs-keyword">struct</span> &#123;<br>qcount   <span class="hljs-keyword">uint</span>           <span class="hljs-comment">// buffer 中已放入的元素个数</span><br>dataqsiz <span class="hljs-keyword">uint</span>           <span class="hljs-comment">// 用户构造 channel 时指定的 buf 大小</span><br>buf      unsafe.Pointer <span class="hljs-comment">// buffer</span><br>elemsize <span class="hljs-keyword">uint16</span>         <span class="hljs-comment">// buffer 中每个元素的大小</span><br>closed   <span class="hljs-keyword">uint32</span>         <span class="hljs-comment">// channel 是否关闭，== 0 代表未 closed</span><br>elemtype *_type         <span class="hljs-comment">// channel 元素的类型信息</span><br>sendx    <span class="hljs-keyword">uint</span>           <span class="hljs-comment">// buffer 中已发送的索引位置 send index</span><br>recvx    <span class="hljs-keyword">uint</span>           <span class="hljs-comment">// buffer 中已接收的索引位置 receive index</span><br>recvq    waitq          <span class="hljs-comment">// 等待接收的 goroutine  list of recv waiters</span><br>sendq    waitq          <span class="hljs-comment">// 等待发送的 goroutine list of send waiters</span><br><br>lock mutex<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以知道，hchan中定义了悲观锁来进行互斥，channel是一个用于同步和通信的有锁队列。</p><h6 id="channel回比mutex低效吗？"><a href="#channel回比mutex低效吗？" class="headerlink" title="channel回比mutex低效吗？"></a>channel回比mutex低效吗？</h6><p>今晚我被这个问题折磨了很久，查了很多资料才有了一些答案。</p><p>Golang中的channel，发送一个数据到channel和从channel接收一个数据都是原子性的。Go语言线程的设计模式就是<strong>不要通过共享内存的方式进行通信，而是应该通过通信的方式共享内存。</strong>这种设计思想有明显的好处，那就是逻辑简单，但是实现成本较高，我觉得这里的实现成本较高是因为channel不但用到了锁，还需要执行调度，会比一般的互斥锁成本更高。两者之间的取舍就是（效率+低可维护性）和（相对低效率+高可维护性）。当然这只是我非常片面的看法，应该还要涉及到具体的使用场景。</p><p><strong><em>更新</em></strong></p><hr><p><a href="https://segmentfault.com/a/1190000017890174">https://segmentfault.com/a/1190000017890174</a></p><p>我在看了上述博文之后对channel和mutex的选择有了一些认识，摘录如下：</p><blockquote><p>面对一个并发问题的时候，应当选择合适的并发方式：channel还是mutex。<strong>选择的依据是他们的能力/特性：channel的能力是让数据流动起来，擅长的是数据流动的场景</strong>，<strong>mutex的能力是数据不动，某段时间只给一个协程访问数据的权限擅长数据位置固定的场景</strong>。</p></blockquote><hr><h6 id="无锁队列ring-buffer"><a href="#无锁队列ring-buffer" class="headerlink" title="无锁队列ring buffer"></a>无锁队列ring buffer</h6><p>按照上述我的想法来看加锁的损耗较高，对于某些特殊的情况，可以采用简单的无锁ring buffer来实现。</p><p><img src="https://tva1.sinaimg.cn/large/008qL1EEly1gza4dbce63j30ab02s0su.jpg" alt=""></p><p>在ring buffer中，设置两个指针，head指向的是下一次读的位置，而tail指向的是下一次写的位置，由于是ring buffer，可以将buffer的最后一个单元不存储数据。所以，如果head == tail，那么说明buffer为空。如果 head == tail + 1 ，那么说明buffer满了。</p><p>在进行读操作时，我们只修改head的值，而在写操作时我们只修改tail的值，在写操作时，我们在写入内容到buffer之后才修改tail的值；而在进行读操作的时候，我们会读取tail的值并将其赋值给copyTail。</p><p>赋值操作是原子操作。所以在读到copyTail之后，从head到copyTail之间一定是有数据可以读的，不会出现数据没有写入就进行读操作的情况。同样的，读操作完成之后，才会修改head的数值；而在写操作之前会读取head的值判断是否有空间可以用来写数据。</p><p>所以，这时候tail到head - 1之间一定是有空间可以写数据的，而不会出现一个位置的数据还没有读出就被写操作覆盖的情况。这样就保证了RingBuffer的线程安全性。（参考博文<a href="https://cloud.tencent.com/developer/article/1561232">无锁ring buffer</a>）</p><p>下面是我自己实现的无锁队列ring buffer，大伙看个热闹：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><br></code></pre></td></tr></table></figure><h6 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h6><p>分段锁提高channel效率思想的思想就是<strong>使用带有协调机制的独占锁，这些机制允许更高的并发性</strong>。</p><p>用白话说就是给buffer中的不同数据段上不同的锁，那么当多个Goroutine访问不同数据段的数据时，就不会存在锁竞争，从而可以有效的提高并发访问效率。</p><p>但是这只是ConcurrentHashMap所使用的锁分段技术，我查了很多遍也没有在网上看到有人用这个思路优化channel，这也许只是我个人的脑洞。</p><h6 id="官方大佬的答案"><a href="#官方大佬的答案" class="headerlink" title="官方大佬的答案"></a>官方大佬的答案</h6><p>Go 语言社区也在 2014 年提出了无锁 Channel 的实现方案，该方案将 Channel 分成了以下三种类型：</p><ul><li>同步 Channel — 不需要缓冲区，发送方会直接将数据交给（Handoff）接收方；</li><li>异步 Channel — 基于环形缓存的传统生产者消费者模型；</li><li>chan struct{} 类型的异步 Channel — struct{} 类型不占用内存空间，不需要实现缓冲区和直接发送（Handoff）的语义；</li></ul><p>这个方案可以在一些关键路径上通过无锁提升channel的性能，但这玩意最后被搁浅了，我也不知道为啥。</p><h6 id="channel一些问题"><a href="#channel一些问题" class="headerlink" title="channel一些问题"></a>channel一些问题</h6><ul><li>channel关闭了写入会怎样？</li></ul><p>​        会发生panic。</p><ul><li>从关闭的channel读取会怎样？</li></ul><p>​        从已经关闭的channel中读取数据是没有问题的，但读取完channel的数据后再次读取会        返回false和默认值0。</p><ul><li><p>channel怎么判断是否关闭了？</p><p>如果返回值是true就是没有关闭，如果返回值是false就是关闭了。</p></li></ul><h5 id="Goroutine调度原理"><a href="#Goroutine调度原理" class="headerlink" title="Goroutine调度原理"></a>Goroutine调度原理</h5><h6 id="GMP调度模型"><a href="#GMP调度模型" class="headerlink" title="GMP调度模型"></a>GMP调度模型</h6><ul><li><p>M代表内核级线程，一个M就是一个线程，Goroutine就是运行在M之上，M是一个很大的结构，里面维护当前执行的goroutine等信息。</p></li><li><p>G代表一个Goroutine，它有自己的栈，instruction pointer和其他信息。</p></li><li>P代表Processor，它的主要用途就是用来执行Goroutine的，它维护一个Goroutine队列，里面存储了所有需要它来执行的Goroutine。</li></ul><p>也就是说，一个G的执行需要M和P的支持，一个M在与一个P关联后形成一个有效的G的运行环境[内核环境+上下文环境]。每个P都会包含一个可运行的G的队列。</p><p><img src="https://upload-images.jianshu.io/upload_images/10436675-a29a641d8a384787.png?imageMogr2/auto-orient/strip|imageView2/2/w/400/format/webp" alt=""></p><p>从上图中看，有2个物理线程M，每一个M都拥有一个处理器P，每一个也都有一个正在运行的Goroutine。默认的P的数量等于CPU的个数，P的数量可以通过GOMAXPROCS()来设置，它其实也就代表了真正的并发度，即有多少个Goroutine可以同时运行。上图中灰色的代表Goroutine并没有运行，而是处于ready的就绪态，正在等待被调度，P维护这个队列。</p><p>在go语言中，一旦执行go function，runqueue队列就会在其末尾加入一个Goroutine。在下一个调度点，就从runqueue中取出一个goroutine执行。系统中这么多P，具体会加到哪个P中，要看具体的调度策略。（补充：其实还有一个全局队列，如果P中队列满了，就会存放在全局队列中。）</p><h6 id="P-和-M-何时会被创建"><a href="#P-和-M-何时会被创建" class="headerlink" title="P 和 M 何时会被创建"></a>P 和 M 何时会被创建</h6><p>1、P 何时创建：在确定了 P 的最大数量 n 后，运行时系统会根据这个数量创建 n 个 P。</p><p>2、M 何时创建：没有足够的 M 来关联 P 并运行其中的可运行的 G。比如所有的 M 此时都阻塞住了，而 P 中还有很多就绪任务，就会去寻找空闲的 M，而没有空闲的，就会去创建新的 M。</p><h6 id="调度过程"><a href="#调度过程" class="headerlink" title="调度过程"></a>调度过程</h6><ol><li>通过go func()创建一个goroutine；</li><li>新创建的G会保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中；</li><li>G只能运行在M中，一个M必须持有一个P。M会从P的本地队列中弹出一个可执行状态的G来执行，如果P的本地队列为空，就会向其他的M-P组合中偷取一个可执行的G来执行；</li><li>循环执行；</li><li>当M执行某一个G的时候如果发生了系统调用或者阻塞操作，M会阻塞，如果当前有一个G在执行，runtime会把这个线程M从P中摘除，然后再创建一个新的内核线程来服务于这个P；</li><li>当M系统调用结束后，这个G会尝试获取一个空闲的P执行，并放到这个P的本地队列，如果获取不到P，那么这个线程M就会变成休眠状态，加入到空闲线程中，然后这个G会被放到全局队列中。</li></ol><p>GMP的数量都是有限制的，摘自<a href="https://juejin.cn/post/6947589840187686920">博客</a></p><h6 id="M的限制"><a href="#M的限制" class="headerlink" title="M的限制"></a>M的限制</h6><p>在协程的执行中，真正干活的是GMP中的M，M的默认数量限制是10000，如果超出就会报错。通常只有在Goroutine出现阻塞的时候才会出现这种情况。</p><h6 id="G的限制"><a href="#G的限制" class="headerlink" title="G的限制"></a>G的限制</h6><p>Goroutine的创建数量理论上没有限制，但是我们的内存是有上限的，所以实际是有限制的。</p><h6 id="P的限制"><a href="#P的限制" class="headerlink" title="P的限制"></a>P的限制</h6><p>P的数量受环境变量GOMAXPROCS的直接影响。</p><h6 id="GMP中为什么要有P"><a href="#GMP中为什么要有P" class="headerlink" title="GMP中为什么要有P"></a>GMP中为什么要有P</h6>]]></content>
    
    
    <categories>
      
      <category>Go语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Goroutine</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go自动管理内存</title>
    <link href="/2021/12/16/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%96%9C%E6%AC%A2Go%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98/"/>
    <url>/2021/12/16/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%96%9C%E6%AC%A2Go%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h3 id="Go垃圾回收机制"><a href="#Go垃圾回收机制" class="headerlink" title="Go垃圾回收机制"></a>Go垃圾回收机制</h3><p>垃圾回收（GC，garbage collection）是自动内存管理的一种形式，通常由垃圾收集器收集并适时回收或重用不再被对象占用的内存。所谓垃圾回收，即所有的内存分配都做都会被在运行时记录，同时任何对该内存的使用也都会被记录，然后垃圾回收器会对所有已经分配的内存进行跟踪监测，一旦发现有些内存已经不再被任何人使用，就阶段性地回收这些没人用的内存，当然，因为需要尽量最小化垃圾回收的性能顺好，以及降低对正常程序执行过程的影响，现实中的垃圾回收算法要比这个复杂的多，比如为对象增加年龄属性等（FIFO?），但基本原理都是如此。</p><h4 id="C-C-语言的手动管理内存"><a href="#C-C-语言的手动管理内存" class="headerlink" title="C/C++语言的手动管理内存"></a>C/C++语言的手动管理内存</h4><p>不支持垃圾回收的语言往往采用手动的方式进行资源管理，然而各种非预期的原因可能会引发严重的问题。</p><h5 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h5><p>手动管理内存的其中一个问题就是由于指针的到处传递而无法确定何时可以释放该指针所指向的内存块。如果代码中的某个位置释放了内存，而另一些地方还在使用指向这块内存的指针，那么这些指针就变成了所谓的“野指针”(wild pointer)或者“悬空指针” (dangling pointer)，对这些指针进行的任何读写操作都会导致不可预料的后果。</p><p>我们来看以下例子：</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">char</span> *p = (<span class="hljs-keyword">char</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">strcpy</span>(p, <span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-built_in">free</span>(p);         <span class="hljs-comment">// p 所指的内存被释放，但是p所指的地址仍然不变</span><br>    <span class="hljs-keyword">if</span>(p != <span class="hljs-literal">NULL</span>)      <span class="hljs-comment">// 没有起到防错作用</span><br>    &#123;<br>        <span class="hljs-built_in">strcpy</span>(p, <span class="hljs-string">&quot;world&quot;</span>);      <span class="hljs-comment">// 出错</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到如下情况：</p><p><img src="http://tva1.sinaimg.cn/large/007SD2TBly1gy979nbq7rj308100nt8q.jpg" alt="image-20220111034419688"></p><p>当然，我们在写代码的时候一般不会这么傻，但是如果遇到下面例子，运行代码时就是一种严峻的考验（摘自许式伟《Go语言编程》）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;<br>p += <span class="hljs-number">10</span>; <span class="hljs-comment">// 对指针进行了偏移，因此那块内存不再被引用</span><br><span class="hljs-comment">// …… 这里可能会发生针对这块int内存的垃圾收集 ……</span><br>p -= <span class="hljs-number">10</span>; <span class="hljs-comment">// 咦，居然又偏移到原来的位置</span><br>*p = <span class="hljs-number">10</span>; <span class="hljs-comment">// 如果有垃圾收集，这里就无法保证可以正常运行了</span><br></code></pre></td></tr></table></figure><h5 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h5><p>当你向系统申请分配内存进行使用，可是使用完后却不归还，结果你申请到的那块内存自己也不会再访问，而系统也不会将其分配给需要的程序，长此以往，造成积重难返的后果。</p><h5 id="解藕"><a href="#解藕" class="headerlink" title="解藕"></a>解藕</h5><p>当两个模块中同时维护了同一内存时，释放内存将会变得非常小心，这种手动分配的困难在于，难以在本地模块内做出全局的决定。</p><h4 id="Go语言的垃圾回收"><a href="#Go语言的垃圾回收" class="headerlink" title="Go语言的垃圾回收"></a>Go语言的垃圾回收</h4><p>Golang使用的垃圾回收机制是三色标记法配合写屏障和辅助GC，三色标记法是标记清除法的一种增强版本。</p><h5 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h5><p>原始的标记清除法分为两个步骤：</p><ol><li>标记。先STP（stop the world），暂停整个程序的全部线程，将被引用的对象打上标记。</li><li>清除没有被打标记的对象，即回收内存资源，然后恢复运行线程。</li></ol><h5 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h5><p>三色标记法中的三色对应垃圾回收过程中对象的三种状态：</p><ul><li>灰色：对象还在标记队列中等待</li><li>黑色：对象已被标记，gcmarkBits对应位为1——该对象不会在本次GC中被回收</li><li>白色：对象未被标记，gcmarkBits对应位为0——该对象将会在本次GC中被回收</li></ul><p>三色标记法的原理就是标记内存中那些还在使用中的部分，而内存中不再使用的部分，就是要回收的垃圾，需要将其回收，以供后续内存分配使用。</p><p>举个例子：我们先扫描前</p><h5 id="回收过程"><a href="#回收过程" class="headerlink" title="回收过程"></a>回收过程</h5><p>在Go语言中，内存的分配和回收都是由Go在底层完成的，Go语言选择并发三色标记，为什么Go语言不选择压缩GC和分代GC，并发三色标记实现起来会非常简单，但它有一个缺陷，就是内存</p><p>GC工作的完整流程如下，Golang GC的大部分处理是和用户代码并行的：</p><ol><li>初始化GC任务，包括开启写屏障和辅助GC，统计root对象的任务数量等。这个过程需要STW。</li><li>扫描所有root对象，包括全局指针和goroutine栈上的指针，将其加入标记队列，并循环处理灰色队列的对象，知道灰色队列为空，该过程后台并行执行。</li><li></li></ol><h5 id="GC优化"><a href="#GC优化" class="headerlink" title="GC优化"></a>GC优化</h5><p>GC性能是与对象数量有关的，对象越多GC性能越差，对程序的影响也越大。在开发中可以减少对象分配个数，采用对象复用、将小对象组合成大对象等方法进行优化。</p><h5 id="GC触发条件"><a href="#GC触发条件" class="headerlink" title="GC触发条件"></a>GC触发条件</h5><p>自动垃圾回收的触发条件有两个：</p><ul><li>超过内存大小阈值</li><li>达到定时时间</li></ul>]]></content>
    
    
    <categories>
      
      <category>Go语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
      <tag>Go map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对浮点数精度丢失的一点研究</title>
    <link href="/2021/12/13/%E5%AF%B9%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E7%9A%84%E4%B8%80%E7%82%B9%E7%A0%94%E7%A9%B6/"/>
    <url>/2021/12/13/%E5%AF%B9%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E7%9A%84%E4%B8%80%E7%82%B9%E7%A0%94%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<h4 id="什么叫精度丢失"><a href="#什么叫精度丢失" class="headerlink" title="什么叫精度丢失"></a>什么叫精度丢失</h4><h5 id="计算不准确"><a href="#计算不准确" class="headerlink" title="计算不准确"></a>计算不准确</h5><p>我们看看如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">float</span> f;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)&#123;<br>    f+=<span class="hljs-number">0.1f</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>,f);<br></code></pre></td></tr></table></figure><p>上述代码中f的结果本应该是10.000000,但是却输出10.000002，如下图所示。这就是浮点数计算不准确的现象，即精度丢失。</p><p><img src="http://tva4.sinaimg.cn/large/007SD2TBly1gxcilvh1yuj308w02c74b.jpg" alt=""></p><p>我们打印小数点后更多位数，能看得更清楚。<code>printf(&quot;%.20f\n&quot;,f);</code>，得到的结果如下：</p><p><img src="http://tvax2.sinaimg.cn/large/007SD2TBly1gxcimk8rcyj308j01q3yp.jpg" alt=""></p><p>我们通过gdb调试看看存储在内存中的数据是什么样子的：</p><p><img src="http://tvax2.sinaimg.cn/large/007SD2TBly1gxcimmglexj306301bglq.jpg" alt=""></p><p>我们将其转化为二进制是<code>0100 0001 0010 0000 0000 0000 0000 0010</code>。</p><p>将这个IEEE745标准的二进制浮点数转化为十进制为：10.000001907348633。</p><p>为什么会出现这种情况呢？这就要涉及到我们下一个知识点，保存不准确。</p><h6 id="保存不准确"><a href="#保存不准确" class="headerlink" title="保存不准确"></a>保存不准确</h6><p>我们看看如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">float</span> f;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.18f\n&quot;</span>,f);<br></code></pre></td></tr></table></figure><p>上述代码中打印结果如下所示：</p><p><img src="http://tva3.sinaimg.cn/large/007SD2TBly1gxcimqnr1sj308f01y74g.jpg" alt=""></p><p>我们来看看内存中如何表示这个数据的：</p><p><img src="http://tva3.sinaimg.cn/large/007SD2TBly1gxcimz3301j308702mq31.jpg" alt=""></p><p>将这个二进制数转化为十进制数为：</p><p><img src="http://tva4.sinaimg.cn/large/007SD2TBly1gxcin0vua5j309d02l74i.jpg" alt=""></p><p>可以看到某些浮点数在写入内存的过程中就存在误差，当然这是无法避免的。这个跟十进制中的无穷小数是一个道理。</p><h4 id="浮点数判断大小或者排序"><a href="#浮点数判断大小或者排序" class="headerlink" title="浮点数判断大小或者排序"></a>浮点数判断大小或者排序</h4><h5 id="浮点数相等"><a href="#浮点数相等" class="headerlink" title="浮点数相等"></a>浮点数相等</h5><p>当判断两个浮点数是否相等时，我们应该使用如下语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a - b) &lt; EPSILON) &#123;<br>    <span class="hljs-comment">//执行当两个浮点数 a 和 b 相等时的操作</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中EPSILON为精度，例如0.000001。</p><h4 id="float可以作为map中的key吗（Go语言）"><a href="#float可以作为map中的key吗（Go语言）" class="headerlink" title="float可以作为map中的key吗（Go语言）"></a>float可以作为map中的key吗（Go语言）</h4><p>从语法上看，Go语言中只要是可比较的类型都可以作为key。除开slice，map，functions这几种类型，其他类型都是OK的。具体包括：布尔值、数字、字符串、指针、通道、接口类型、结构体、只包含上述类型的数组。这些类型的共同特征是支持 <code>==</code> 和 <code>!=</code> 操作符，<code>k1 == k2</code> 时，可认为 k1 和 k2 是同一个 key。当然，任何类型都可以作为value，包括map类型。</p><p>我们来看如下例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">float64</span>]<span class="hljs-keyword">int</span>)<br>    m[<span class="hljs-number">1.4</span>] = <span class="hljs-number">1</span><br>    m[<span class="hljs-number">2.4</span>] = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;[%v, %d] &quot;</span>, k, v)<br>    &#125;<br>    fmt.Printf(<span class="hljs-string">&quot;k: %v, v: %d\n&quot;</span>, <span class="hljs-number">2.400000000001</span>, m[<span class="hljs-number">2.400000000001</span>])<br>    fmt.Printf(<span class="hljs-string">&quot;k: %v, v: %d\n&quot;</span>, <span class="hljs-number">2.4000000000000000000000001</span>, m[<span class="hljs-number">2.4000000000000000000000001</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p>程序输出如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">[<span class="hljs-number">2.4</span>, <span class="hljs-number">2</span>] [<span class="hljs-number">1.4</span>, <span class="hljs-number">1</span>] <br>k: <span class="hljs-number">2.400000000001</span>, v: <span class="hljs-number">0</span><br>k: <span class="hljs-number">2.4</span>, v: <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>我们发现2.4000000000000000000000001存在value。当用float作为key的时候，先要将其转成uint64类型，再插入key中。通过以下函数实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Float64frombits returns the floating point number corresponding</span><br><span class="hljs-comment">// the IEEE 754 binary representation b.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Float64frombits</span><span class="hljs-params">(b <span class="hljs-keyword">uint64</span>)</span> <span class="hljs-title">float64</span></span> &#123; <span class="hljs-keyword">return</span> *(*<span class="hljs-keyword">float64</span>)(unsafe.Pointer(&amp;b)) &#125;<br></code></pre></td></tr></table></figure><p>也就是我们上述所说的IEEE 754规定的格式。</p><p>我们再来输出点东西：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;math&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">float64</span>]<span class="hljs-keyword">int</span>)<br>    m[<span class="hljs-number">2.4</span>] = <span class="hljs-number">2</span><br>    fmt.Println(math.Float64bits(<span class="hljs-number">2.4</span>))<br>    fmt.Println(math.Float64bits(<span class="hljs-number">2.400000000001</span>))<br>    fmt.Println(math.Float64bits(<span class="hljs-number">2.4000000000000000000000001</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">4612586738352862003</span><br><span class="hljs-number">4612586738352864255</span><br><span class="hljs-number">4612586738352862003</span><br></code></pre></td></tr></table></figure><p>转成十六进制如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">0x4003333333333333</span><br><span class="hljs-number">0x4003333333333BFF</span><br><span class="hljs-number">0x4003333333333333</span><br></code></pre></td></tr></table></figure><p>由此可见，由于精度受限，2.4和2.4000000000000000000000001经过 <code>math.Float64bits()</code> 函数转换后的结果是一样的。自然，二者在 map 看来，就是同一个 key 了。</p>]]></content>
    
    
    <categories>
      
      <category>杂文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浮点数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT_6.s081_Lab1:Xv6 and Unix utilities</title>
    <link href="/2021/12/12/MIT-s-081-Lab1-Xv6-and-Unix-utilities/"/>
    <url>/2021/12/12/MIT-s-081-Lab1-Xv6-and-Unix-utilities/</url>
    
    <content type="html"><![CDATA[<p>在这个实验中要实现几个用户级别的应用程序，其对应的系统调用在<code>kernel</code>中都已经被实现好了。</p><h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a><em>sleep</em></h4><p>本实验要为 xv6 实现 UNIX 程序 sleep； 您的睡眠应暂停用户指定的滴答数。 滴答是 xv6 内核定义的时间概念，即来自定时器芯片的两次中断之间的时间。</p><p>我们检查参数，如果出现不是数字的参数就<code>exit(-1)</code>，否则进行sleep。代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> *argv[])</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(argv[<span class="hljs-number">1</span>][i]!=<span class="hljs-string">&#x27;&#x27;)&#123;</span><br><span class="hljs-string">    if(argv[1][i]&gt;&#x27;</span><span class="hljs-number">9&#x27;</span>||argv[<span class="hljs-number">1</span>][i]&lt;<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>      write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;error\n&quot;</span>, <span class="hljs-number">6</span>);<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    i++; <br>  &#125;<br>  <span class="hljs-keyword">int</span> times=atoi(argv[<span class="hljs-number">1</span>]);<br>  sleep(times);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>值得注意的是，程序中我们使用了一些系统调用函数，如sleep函数，write函数。我们可以在user/user.h中一窥这些函数的原型：</p><p><img src="http://tva4.sinaimg.cn/large/007SD2TBly1gy981i7x0kj30a10agtbw.jpg" alt=""></p><p>我们来分析一下<code>write</code>函数，我们可以看到<code>write</code>函数的声明为<code>int write(int,const void*,int);</code>其中，参数中第一个<code>int</code>为文件描述符<code>fd</code>，参数中第二个<code>const void*</code>为内存地址，第三个<code>int</code>为写入的字节数量，意思就是说：将参数buf所指的内存写入count个字节到参数fd所指的文件，其中，fd为文件描述符。大家可以看到上述代码中的<code>write</code>函数的调用：<code>write(1,&quot;error\n&quot;,6)</code>，其中<code>fd=1</code>代表标准输出<code>stdout</code>，也就是会打印到显示器。</p><p>我们来看看<code>write</code>在内核中的实现<code>sys_write</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">sys_write</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span><br>  <span class="hljs-keyword">int</span> n;<br>  uint64 p;<br><br>  <span class="hljs-keyword">if</span>(argfd(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &amp;f) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">2</span>, &amp;n) &lt; <span class="hljs-number">0</span> || argaddr(<span class="hljs-number">1</span>, &amp;p) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-keyword">return</span> filewrite(f, p, n);<br>&#125;<br></code></pre></td></tr></table></figure><p>在进入内核的时候，系统调用函数会将参数保存在寄存器中，然后调用<code>argfd</code>等函数将参数取出，保存在<code>f，p，n</code>中，调用<code>filewrite</code>函数。我们注意到<code>struct file *f</code>结构，其结构如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;<br>  <span class="hljs-keyword">int</span> ref; <span class="hljs-comment">// reference count</span><br>  <span class="hljs-keyword">char</span> readable;<br>  <span class="hljs-keyword">char</span> writable;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe</span> *<span class="hljs-title">pipe</span>;</span> <span class="hljs-comment">// FD_PIPE</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>;</span>  <span class="hljs-comment">// FD_INODE and FD_DEVICE</span><br>  uint off;          <span class="hljs-comment">// FD_INODE</span><br>  <span class="hljs-keyword">short</span> major;       <span class="hljs-comment">// FD_DEVICE</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><p>说到这里了，我们提一下buffer IO，我感觉xv6是没有实现buffer IO的，源码里面没有找到相关的说明和代码，但是在linux里面是实现了的。buffer IO是为了提高读写效率和保护磁盘，比如我们通过read函数将fd对应的文件拷贝count个字节到buf对应的内存，这个时候如果是buffer io机制，那么我们就会先将count个字节拷贝到page cache中，然后再拷贝到buf对应的用户空间中。write操作类似。</p><p>上次面试官问了我一个问题：什么时候将脏页刷回磁盘？</p><p>我查了一下，有的说是进程退出的时候刷回去，有的说是定时刷回去。在CMU15445细说。</p><hr><p>我们将在后面的实验中继续学习syscall。</p><h4 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a><em>pingpong</em></h4><p>编写一个程序，使用 UNIX 系统调用在两个进程之间通过一对管道“乒乓”一个字节，每个管道一个。 父母应该向孩子发送一个字节； 子进程应该打印“<pid>: received ping”，其中 <pid> 是它的进程 ID，将管道上的字节写入父进程，然后退出； 父母应该从孩子那里读取字节，打印“<pid>: received pong”，然后退出。</p><p>一些提示：</p><ul><li>使用管道创建管道。</li><li>使用 fork 创建一个孩子。</li><li>使用 read 从管道读取，并使用 write 写入管道。</li><li>使用 getpid 查找调用进程的进程 ID。</li><li>将程序添加到 Makefile 中的 UPROGS。</li><li>xv6 上的用户程序有一组有限的库函数可供它们使用。 可以在 user/user.h 中看到列表； 源（系统调用除外）位于 user/ulib.c、user/printf.c 和 user/umalloc.c。</li></ul><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">int</span> p_filedes[<span class="hljs-number">2</span>],s_filedes[<span class="hljs-number">2</span>];<br>  pipe(p_filedes);<br>  pipe(s_filedes);<br>  <span class="hljs-keyword">char</span> buf[<span class="hljs-number">4</span>];<br>  <span class="hljs-keyword">if</span>(fork()==<span class="hljs-number">0</span>)&#123;<br>    read(p_filedes[<span class="hljs-number">0</span>],buf,<span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received %s\n&quot;</span>,getpid(),buf);<br>    write(s_filedes[<span class="hljs-number">1</span>],<span class="hljs-string">&quot;pong&quot;</span>,<span class="hljs-number">4</span>);<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    write(p_filedes[<span class="hljs-number">1</span>],<span class="hljs-string">&quot;ping&quot;</span>,<span class="hljs-number">4</span>);<br>    read(s_filedes[<span class="hljs-number">0</span>],buf,<span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received %s\n&quot;</span>,getpid(),buf);<br>  &#125;<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，我们使用了两个管道，p_filedes和s_filedes，来传递父进程和子进程之间的信息。</p><p>借此机会，我们来分析一下<code>read</code>函数，read函数原型为<code>read(int,void *,int)</code>，其意义为将文件描述符<code>fd</code>所指向的文件读取<code>count</code>个数据到<code>buf</code>中。如<code>read(0,buf,10)</code>就是将标准输入读取10个字节到buf中。其底层实现为<code>sys_read</code>，</p><p>这让我想到了HUST大三学生在2021年做的lab1，通过程序演示多进程并发执行和进程软中断、管道通信。实验具体描述如下：</p><ul><li><p>父进程先建立一个管道,然后创建两个进程:子进程1和子进程2;</p></li><li><p>父进程每隔1秒向管道发送消息(消息数量有上限) :</p><p>I send you x times. (x的初值为1,每次发送后对x做加1操作)</p></li><li><p>子进程1、2从管道接收消息,并显示在屏幕上。</p></li><li>父进程能捕获软中断信号SIGINT(按键盘的Ctrl+C键),捕获到该信号后,父进程分别向两个子进程发出软中断信号SIGUSR1。</li><li>子进程能捕获父进程发出的SIGUSR1信号,捕获到该信号后,分别输出下列信息后终止:<br>Child Process l is Killed by Parent!<br>Child Process 2 is Killed by Parent!</li><li>父进程等待两个子进程终止后,释放管道并输出如下信息后终止:<br>Parent Process is Killed!</li></ul><p>这个实验可以通过如下框架进行设计：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"> </span>)</span><br>&#123;<br>    创建无名管道;<br>    设置信号SIGINT处理;<br>    创建子进程<span class="hljs-number">1</span>、<span class="hljs-number">2</span>;<br>    定时发送数据;<br>    等待子进程<span class="hljs-number">1</span>、<span class="hljs-number">2</span>退出;<br>    关闭管道;<br>    打印信息、退出;<br>&#125;<br>父进程SIGINT信号处理<br>&#123;<br>    发SIGUSR1给子进程<span class="hljs-number">1</span>;<br>    发SIGUSR2给子进程<span class="hljs-number">2</span>;<br>    等待子进程<span class="hljs-number">1</span>、<span class="hljs-number">2</span>退出;<br>    关闭管道;<br>    打印信息、退出;<br>&#125;<br>子进程<span class="hljs-number">1</span>/<span class="hljs-number">2</span><br>&#123;<br>    设置信号SIGINT处理;<br>    设置SIGUSR1或<span class="hljs-number">2</span>处理;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        从管道接收数据;<br>        显示数据;<br>        计数器++;<br>    &#125;<br>    关闭管道;<br>    打印信息、退出;<br>&#125;<br>SIGUSR1/<span class="hljs-number">2</span>信号处理<br>&#123;<br>    关闭管道;<br>    打印信息;<br>    退出;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-keyword">int</span> pid_1,pid_2;<br><span class="hljs-keyword">int</span> filedes_1[<span class="hljs-number">2</span>],filedes_2[<span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span><br><span class="hljs-function"></span>&#123;<br>kill(pid_1,SIGUSR1);<br>kill(pid_2,SIGUSR1);<br>    waitpid(pid_1,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>);<br>    waitpid(pid_2,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>);<br>    close(filedes_1[<span class="hljs-number">0</span>]);<br>    close(filedes_1[<span class="hljs-number">1</span>]);<br>    close(filedes_2[<span class="hljs-number">0</span>]);<br>    close(filedes_2[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent Process is Killed!\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nChild1 process1  is  killed by parent!\n&quot;</span>);<br>    close(filedes_1[<span class="hljs-number">0</span>]);<br>    close(filedes_1[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nChild2 process2  is  killed by parent!\n&quot;</span>);<br>    close(filedes_2[<span class="hljs-number">0</span>]);<br>    close(filedes_2[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    pipe(filedes_1);<br>    pipe(filedes_2);<br><br>    <span class="hljs-keyword">char</span> s[<span class="hljs-number">80</span>];<br>    <span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;<br>    pid_1=fork();<br>    <span class="hljs-keyword">if</span>(pid_1&gt;<span class="hljs-number">0</span>)&#123;<br>        pid_2=fork();<br>        <span class="hljs-keyword">if</span>(pid_2&gt;<span class="hljs-number">0</span>)&#123;<br>            signal(SIGINT,fun);<br>            <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>                x++;<br>                <span class="hljs-keyword">char</span> buf[<span class="hljs-number">80</span>];<br>                <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;I send you %d times&quot;</span>, x);<br>                write(filedes_1[<span class="hljs-number">1</span>],buf,<span class="hljs-keyword">sizeof</span>(buf));<br>                write(filedes_2[<span class="hljs-number">1</span>],buf,<span class="hljs-keyword">sizeof</span>(buf));<br>                sleep(<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            signal(SIGINT,SIG_IGN);<br>            signal(SIGUSR1,fun2);<br>            <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>                read(filedes_2[<span class="hljs-number">0</span>],s,<span class="hljs-keyword">sizeof</span>(s));<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s c2\n&quot;</span>,s);<br>                sleep(<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        signal(SIGINT,SIG_IGN);<br>        signal(SIGUSR1,fun1);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            read(filedes_1[<span class="hljs-number">0</span>],s,<span class="hljs-keyword">sizeof</span>(s));<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s c1\n&quot;</span>,s);<br>            sleep(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a><em>xargs</em></h4><p>xarg是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。xarg可以将管道或标准输入数据转换成命令行参数，也能够从文件的输出中读取数据。</p><p>在实验中我们要完成的xargs程序与linux命令类似。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/param.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> line[<span class="hljs-number">256</span>], *p[MAXARG], ch;<br>    <span class="hljs-keyword">int</span> lines = <span class="hljs-number">0</span>, linen, ps = <span class="hljs-number">0</span>, pn, i, j;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; argc - <span class="hljs-number">1</span>; i++) &#123;<br>        p[ps++] = line + lines;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">strlen</span>(argv[i + <span class="hljs-number">1</span>]); j++)<br>            line[lines++] = argv[i + <span class="hljs-number">1</span>][j];<br>        line[lines++] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    &#125;<br>    linen = lines; pn = ps; p[pn++] = line + linen;<br>    <span class="hljs-keyword">while</span> (read(<span class="hljs-number">0</span>, &amp;ch, <span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>            line[linen++] = <span class="hljs-string">&#x27;\0&#x27;</span>; p[pn++] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) exec(argv[<span class="hljs-number">1</span>], p);<br>            <span class="hljs-keyword">else</span> &#123;<br>                wait(<span class="hljs-number">0</span>); linen = lines; pn = ps; p[pn++] = line + linen;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            line[linen++] = <span class="hljs-string">&#x27;\0&#x27;</span>; p[pn++] = line + linen;<br>        &#125; <span class="hljs-keyword">else</span> line[linen++] = ch;<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT_s.081_Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stanford_CS144_Lab1</title>
    <link href="/2021/11/27/Stanford-CS144-Lab1/"/>
    <url>/2021/11/27/Stanford-CS144-Lab1/</url>
    
    <content type="html"><![CDATA[<p>该lab要求我们实现一个流重组类，可以将Sender发来的带索引号的字节碎片重组成有序的字节写入到byte_stream。接收端从发送端读取数据，调用流重组器，流重组器对数据进行排序，排序好后写入byte_stream。</p><p>值得注意的是，无论是lab0中的byte_stream,还是lab1中的重组器，都有capasity的概念，capasity用于模拟内存，capasity由重组器中未排序的数据和已经写入byte_stream中但还未被读取的数据组成，如下图所示：</p><p><img src="http://tvax3.sinaimg.cn/large/007SD2TBly1gwtr4gx6o9j30hp05i0t4.jpg" alt=""></p><p>所以我们在进行重组和读写操作时应该根据capasity的大小维护重组器。为了方便起见，我们依旧使用双端队列作为重组器。</p><p>在重组器类的函数中，push_substring函数完成重组工作。其参数有data(string),index(size_t),eof(bool),data是待排序的数据，index是数据首元素的序号，eof用于判断是否结束。结束后将不再有数据输入。</p><p>在重组的过程中，我们会遇到重复、丢包、重叠、乱序的现象。为了使乱序的数据找到有序的位置，我使用’\0’维护重组器中数据的相对序号，例如，第一次data为make,index为0,第二次data为great,index为13,而处于两组数据中间的数据未知，我们就用’\0’代替，即make\0\0\0\0\0\0\0\0\0great。这样就维护了已经进入重组器的数据的有序。当然，写入的data中也有可能含有\0,这是，我们就需要一个bool双端队列，来记录相应位置的数据是否有序，在上述例子中，队列的bool值为111100000000011111。</p><p>1.我们判断输入序号是否大于内存与已读取数据之和，也就是说，该数据是否属于unacceptable中的数据，如果是这样的数据，我们没有足够的内存写入，因为写入这样的数据需要添加\0，从而超过capasity的大小。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(index&gt;_output.<span class="hljs-built_in">bytes_read</span>()+_capacity)&#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.我们需要判断data中最后一个数据的序号是否大于内存与已读取数据之和，如果大于，我们就要将能写入的部分写入，也就是按data的顺序尽可能地写入数据而不超过capasity,在写入的过程中，我们也会遇到两种情况，一种是序号index大于此时已经在流重组器的最后一个数据的序号，在这种情况下我们要在流重组器最后一个序号与index之间填入’\0′,同时将相应的bool双端队列(_check_byte)设置为false，做完这些工作后，才开始写入新的数据。另一种情况是index的小于或者等于流重组器最后一个数据的序号，我们需要弹出冲突的数据，举个例子就是，index序号为5,此时流重组器中的数据为stanford,我们就要从序号5的数据也就是o开始弹出，变成stanf,再写入data中的数据。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(index+data.<span class="hljs-built_in">length</span>()&gt;_capacity+_output.<span class="hljs-built_in">bytes_read</span>())&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i=_lens_un+_output.<span class="hljs-built_in">bytes_written</span>();i&lt;_capacity+_output.<span class="hljs-built_in">bytes_read</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;index)&#123;<br>            _unassembled_byte.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;\0&#x27;</span>);<br>            _check_byte.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">false</span>);<br><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            _unassembled_byte.<span class="hljs-built_in">push_back</span>(data[i-index]);<br>            _check_byte.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">true</span>);<br><br>        &#125;<br>        _lens_un++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.我们要判断index是否等于已经写入byte_stream(_output)中的数据，如果是的，我们就直接将data中的数据写入byte_stream,然后在重组器中弹出data.length()个数据，值得注意的是，当重组器中的数据个数小于data.length()，我们就全部弹出。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(index==_output.<span class="hljs-built_in">bytes_written</span>())&#123;<br>    _output.<span class="hljs-built_in">write</span>(data);<br>    <span class="hljs-keyword">size_t</span> temp_len=std::<span class="hljs-built_in">min</span>(_lens_un,data.<span class="hljs-built_in">length</span>());<br>    _unassembled_byte.<span class="hljs-built_in">erase</span>(_unassembled_byte.<span class="hljs-built_in">begin</span>(),_unassembled_byte.<span class="hljs-built_in">begin</span>()+temp_len);<br>    _check_byte.<span class="hljs-built_in">erase</span>(_check_byte.<span class="hljs-built_in">begin</span>(),_check_byte.<span class="hljs-built_in">begin</span>()+temp_len);<br>    _lens_un-=temp_len;<br>&#125;<br></code></pre></td></tr></table></figure><p>4.我们要判断index是否大于流重组器中的最后一个数据的序号和写入byte_stream中的数据个数之和，如果大于，我们就可以参考1的处理，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(index&gt;_output.<span class="hljs-built_in">bytes_written</span>()+_lens_un)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i=_output.<span class="hljs-built_in">bytes_written</span>()+_lens_un;i&lt;index;i++)&#123;<br>        _unassembled_byte.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;\0&#x27;</span>);<br>        _check_byte.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">false</span>);<br>        _lens_un++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> i : data)&#123;<br>        _unassembled_byte.<span class="hljs-built_in">push_back</span>(i);<br>        _lens_un++;<br>        _check_byte.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>5.我们要判断data中的数据是否已经被写入byte_stream，这个说法有些不准确，准确的说是相应序号的数据被写入，如果data中的所有数据都被写入了byte_stream，我们就直接返回，如果只是部分被写入，我们就将data中未被写入的部分写入。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(index&lt;_output.<span class="hljs-built_in">bytes_written</span>())&#123;<br>    <span class="hljs-keyword">if</span>(_output.<span class="hljs-built_in">bytes_written</span>()&gt;index+data.<span class="hljs-built_in">length</span>())&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">data_cut</span><span class="hljs-params">(data.begin()+_output.bytes_written()-index,data.end())</span></span>;<br>    _output.<span class="hljs-built_in">write</span>(data_cut);<br>    <span class="hljs-keyword">size_t</span> temp_len=std::<span class="hljs-built_in">min</span>(_lens_un,data_cut.<span class="hljs-built_in">length</span>());<br>    _unassembled_byte.<span class="hljs-built_in">erase</span>(_unassembled_byte.<span class="hljs-built_in">begin</span>(),_unassembled_byte.<span class="hljs-built_in">begin</span>()+temp_len);<br>    _check_byte.<span class="hljs-built_in">erase</span>(_check_byte.<span class="hljs-built_in">begin</span>(),_check_byte.<span class="hljs-built_in">begin</span>()+temp_len);<br>    _lens_un-=temp_len;<br></code></pre></td></tr></table></figure><p>6.在上述特殊情况都被排除之后，剩下的就是index处于流重组器的中间，我们就插入data中的数据到流重组器就行了。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//在中间插入元素</span><br><span class="hljs-comment">//先弹出一部分数据保存到栈中</span><br>std::stack&lt;<span class="hljs-keyword">char</span>&gt; temp;<br>std::stack&lt;<span class="hljs-keyword">bool</span>&gt; temp_check;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span>;i&lt;index-_output.<span class="hljs-built_in">bytes_written</span>();i++)&#123;<br>    temp.<span class="hljs-built_in">push</span>(_unassembled_byte.<span class="hljs-built_in">at</span>(i));<br>    temp_check.<span class="hljs-built_in">push</span>(_check_byte.<span class="hljs-built_in">at</span>(i));<br>&#125;<br><span class="hljs-keyword">size_t</span> temp_len=std::<span class="hljs-built_in">min</span>(_lens_un,data.<span class="hljs-built_in">length</span>()+index-_output.<span class="hljs-built_in">bytes_written</span>());<br>_unassembled_byte.<span class="hljs-built_in">erase</span>(_unassembled_byte.<span class="hljs-built_in">begin</span>(),_unassembled_byte.<span class="hljs-built_in">begin</span>()+temp_len);<br>_check_byte.<span class="hljs-built_in">erase</span>(_check_byte.<span class="hljs-built_in">begin</span>(),_check_byte.<span class="hljs-built_in">begin</span>()+temp_len);<br>_lens_un-=temp_len;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=data.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>    _unassembled_byte.<span class="hljs-built_in">push_front</span>(data[i]);<br>    _check_byte.<span class="hljs-built_in">push_front</span>(<span class="hljs-literal">true</span>);<br>    _lens_un++;<br>&#125;<br><span class="hljs-keyword">while</span>(!temp.<span class="hljs-built_in">empty</span>())&#123;<br>    _unassembled_byte.<span class="hljs-built_in">push_front</span>(temp.<span class="hljs-built_in">top</span>());<br>    _check_byte.<span class="hljs-built_in">push_front</span>(temp_check.<span class="hljs-built_in">top</span>());<br>    _lens_un++;<br>    temp.<span class="hljs-built_in">pop</span>();<br>    temp_check.<span class="hljs-built_in">pop</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>在讲完data中数据插入流重组器操作之后，我们就要讲一讲如何讲流重组器中的数据写入byte_stream，其实非常简单，如果流重组器中的front数据的判定值为true,就说明该数据已经排好序了，我们就可以直接写入，依次判定，直到遇到判定值为false的数据。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::string <span class="hljs-title">n</span><span class="hljs-params">(_unassembled_byte.begin(),_unassembled_byte.begin()+i)</span></span>;<br>_output.<span class="hljs-built_in">write</span>(n);<br>_unassembled_byte.<span class="hljs-built_in">erase</span>(_unassembled_byte.<span class="hljs-built_in">begin</span>(),_unassembled_byte.<span class="hljs-built_in">begin</span>()+i);<br>_lens_un-=i;<br>_check_byte.<span class="hljs-built_in">erase</span>(_check_byte.<span class="hljs-built_in">begin</span>(),_check_byte.<span class="hljs-built_in">begin</span>()+i);<br><span class="hljs-keyword">if</span>(eof) input_end_index=index+data.<span class="hljs-built_in">length</span>();<br><span class="hljs-keyword">if</span>(input_end_index==_output.<span class="hljs-built_in">bytes_written</span>()) _output.<span class="hljs-built_in">end_input</span>();<br></code></pre></td></tr></table></figure><p>至于unassembled_byte函数，就是返回流重组器中false数据的个数，empty就是一个判空函数，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">StreamReassembler::unassembled_bytes</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">size_t</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">bool</span> i:_check_byte)&#123;<br>        <span class="hljs-keyword">if</span>(i)&#123;<br>            res++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">StreamReassembler::empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _lens_un==<span class="hljs-number">0</span>; &#125;<br></code></pre></td></tr></table></figure><p>stream_reassembler.cc代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;stream_reassembler.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;stack&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;cstring&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;iostream&quot;</span></span><br><span class="hljs-comment">// Dummy implementation of a stream reassembler.</span><br><br><span class="hljs-comment">// For Lab 1, please replace with a real implementation that passes the</span><br><span class="hljs-comment">// automated checks run by `make check_lab1`.</span><br><br><span class="hljs-comment">// You will need to add private members to the class declaration in `stream_reassembler.hh`</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Targs&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DUMMY_CODE</span><span class="hljs-params">(Targs &amp;&amp;... <span class="hljs-comment">/* unused */</span>)</span> </span>&#123;&#125;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>StreamReassembler::<span class="hljs-built_in">StreamReassembler</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> capacity) : _output(capacity), _capacity(capacity), _unassembled_byte(<span class="hljs-number">0</span>),_check_byte(<span class="hljs-number">0</span>),_lens_un(<span class="hljs-number">0</span>),<span class="hljs-built_in">input_end_index</span>(<span class="hljs-number">-1</span>)&#123;&#125;<br><br><span class="hljs-comment">//! \details This function accepts a substring (aka a segment) of bytes,</span><br><span class="hljs-comment">//! possibly out-of-order, from the logical stream, and assembles any newly</span><br><span class="hljs-comment">//! contiguous substrings and writes them into the output stream in order.</span><br><span class="hljs-comment">//</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StreamReassembler::push_substring</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string &amp;data, <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> index, <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> eof)</span> </span>&#123;<br>    <span class="hljs-built_in">DUMMY_CODE</span>(data, index, eof);<br>    <span class="hljs-comment">//始终使用绝对索引</span><br>    <span class="hljs-keyword">if</span>(index&gt;_output.<span class="hljs-built_in">bytes_read</span>()+_capacity)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(index+data.<span class="hljs-built_in">length</span>()&gt;_capacity+_output.<span class="hljs-built_in">bytes_read</span>())&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i=_lens_un+_output.<span class="hljs-built_in">bytes_written</span>();i&lt;_capacity+_output.<span class="hljs-built_in">bytes_read</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(i&lt;index)&#123;<br>                _unassembled_byte.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;\0&#x27;</span>);<br>                _check_byte.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">false</span>);<br><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                _unassembled_byte.<span class="hljs-built_in">push_back</span>(data[i-index]);<br>                _check_byte.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">true</span>);<br><br>            &#125;<br>            _lens_un++;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(index==_output.<span class="hljs-built_in">bytes_written</span>())&#123;<br>        _output.<span class="hljs-built_in">write</span>(data);<br>        <span class="hljs-keyword">size_t</span> temp_len=std::<span class="hljs-built_in">min</span>(_lens_un,data.<span class="hljs-built_in">length</span>());<br>        _unassembled_byte.<span class="hljs-built_in">erase</span>(_unassembled_byte.<span class="hljs-built_in">begin</span>(),_unassembled_byte.<span class="hljs-built_in">begin</span>()+temp_len);<br>        _check_byte.<span class="hljs-built_in">erase</span>(_check_byte.<span class="hljs-built_in">begin</span>(),_check_byte.<span class="hljs-built_in">begin</span>()+temp_len);<br>        _lens_un-=temp_len;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(index&gt;_output.<span class="hljs-built_in">bytes_written</span>()+_lens_un)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i=_output.<span class="hljs-built_in">bytes_written</span>()+_lens_un;i&lt;index;i++)&#123;<br>            _unassembled_byte.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;\0&#x27;</span>);<br>            _check_byte.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">false</span>);<br>            _lens_un++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> i : data)&#123;<br>            _unassembled_byte.<span class="hljs-built_in">push_back</span>(i);<br>            _lens_un++;<br>            _check_byte.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">true</span>);<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(index&lt;_output.<span class="hljs-built_in">bytes_written</span>())&#123;<br>        <span class="hljs-keyword">if</span>(_output.<span class="hljs-built_in">bytes_written</span>()&gt;index+data.<span class="hljs-built_in">length</span>())&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-function">std::string <span class="hljs-title">data_cut</span><span class="hljs-params">(data.begin()+_output.bytes_written()-index,data.end())</span></span>;<br>        _output.<span class="hljs-built_in">write</span>(data_cut);<br>        <span class="hljs-keyword">size_t</span> temp_len=std::<span class="hljs-built_in">min</span>(_lens_un,data_cut.<span class="hljs-built_in">length</span>());<br>        _unassembled_byte.<span class="hljs-built_in">erase</span>(_unassembled_byte.<span class="hljs-built_in">begin</span>(),_unassembled_byte.<span class="hljs-built_in">begin</span>()+temp_len);<br>        _check_byte.<span class="hljs-built_in">erase</span>(_check_byte.<span class="hljs-built_in">begin</span>(),_check_byte.<span class="hljs-built_in">begin</span>()+temp_len);<br>        _lens_un-=temp_len;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//在中间插入元素</span><br>        <span class="hljs-comment">//先弹出一部分数据保存到栈中</span><br>        std::stack&lt;<span class="hljs-keyword">char</span>&gt; temp;<br>        std::stack&lt;<span class="hljs-keyword">bool</span>&gt; temp_check;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span>;i&lt;index-_output.<span class="hljs-built_in">bytes_written</span>();i++)&#123;<br>            temp.<span class="hljs-built_in">push</span>(_unassembled_byte.<span class="hljs-built_in">at</span>(i));<br>            temp_check.<span class="hljs-built_in">push</span>(_check_byte.<span class="hljs-built_in">at</span>(i));<br>        &#125;<br>        <span class="hljs-keyword">size_t</span> temp_len=std::<span class="hljs-built_in">min</span>(_lens_un,data.<span class="hljs-built_in">length</span>()+index-_output.<span class="hljs-built_in">bytes_written</span>());<br>        _unassembled_byte.<span class="hljs-built_in">erase</span>(_unassembled_byte.<span class="hljs-built_in">begin</span>(),_unassembled_byte.<span class="hljs-built_in">begin</span>()+temp_len);<br>        _check_byte.<span class="hljs-built_in">erase</span>(_check_byte.<span class="hljs-built_in">begin</span>(),_check_byte.<span class="hljs-built_in">begin</span>()+temp_len);<br>        _lens_un-=temp_len;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=data.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            _unassembled_byte.<span class="hljs-built_in">push_front</span>(data[i]);<br>            _check_byte.<span class="hljs-built_in">push_front</span>(<span class="hljs-literal">true</span>);<br>            _lens_un++;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!temp.<span class="hljs-built_in">empty</span>())&#123;<br>            _unassembled_byte.<span class="hljs-built_in">push_front</span>(temp.<span class="hljs-built_in">top</span>());<br>            _check_byte.<span class="hljs-built_in">push_front</span>(temp_check.<span class="hljs-built_in">top</span>());<br>            _lens_un++;<br>            temp.<span class="hljs-built_in">pop</span>();<br>            temp_check.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;_lens_un)&#123;<br>        <span class="hljs-keyword">if</span>(!_check_byte.<span class="hljs-built_in">at</span>(i))&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        i++;<br>    &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">n</span><span class="hljs-params">(_unassembled_byte.begin(),_unassembled_byte.begin()+i)</span></span>;<br>    _output.<span class="hljs-built_in">write</span>(n);<br>    _unassembled_byte.<span class="hljs-built_in">erase</span>(_unassembled_byte.<span class="hljs-built_in">begin</span>(),_unassembled_byte.<span class="hljs-built_in">begin</span>()+i);<br>    _lens_un-=i;<br>    _check_byte.<span class="hljs-built_in">erase</span>(_check_byte.<span class="hljs-built_in">begin</span>(),_check_byte.<span class="hljs-built_in">begin</span>()+i);<br>    <span class="hljs-keyword">if</span>(eof) input_end_index=index+data.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-keyword">if</span>(input_end_index==_output.<span class="hljs-built_in">bytes_written</span>()) _output.<span class="hljs-built_in">end_input</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">StreamReassembler::unassembled_bytes</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">size_t</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">bool</span> i:_check_byte)&#123;<br>        <span class="hljs-keyword">if</span>(i)&#123;<br>            res++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">StreamReassembler::empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _lens_un==<span class="hljs-number">0</span>; &#125;<br></code></pre></td></tr></table></figure><p>stream_reassembler.hh代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> SPONGE_LIBSPONGE_STREAM_REASSEMBLER_HH</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SPONGE_LIBSPONGE_STREAM_REASSEMBLER_HH</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;byte_stream.hh&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdint&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">//! \brief A class that assembles a series of excerpts from a byte stream (possibly out of order,</span><br><span class="hljs-comment">//! possibly overlapping) into an in-order byte stream.</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamReassembler</span> &#123;</span><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// Your code here -- add private members as necessary.</span><br>    ByteStream _output;  <span class="hljs-comment">//!&lt; The reassembled in-order byte stream</span><br>    <span class="hljs-comment">//capacity是SreamReassembler里面储存的max_index减去在bytestream里面还没有被读取min_index,然后还要加上1</span><br>    <span class="hljs-keyword">size_t</span> _capacity;    <span class="hljs-comment">//!&lt; The maximum number of bytes</span><br>    std::deque&lt;<span class="hljs-keyword">char</span>&gt; _unassembled_byte;<span class="hljs-comment">//</span><br>    std::deque&lt;<span class="hljs-keyword">bool</span>&gt; _check_byte;<br>    <span class="hljs-keyword">size_t</span> _lens_un;<br>    <span class="hljs-keyword">bool</span> _eof;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//! \brief Construct a `StreamReassembler` that will store up to `capacity` bytes.</span><br>    <span class="hljs-comment">//! \note This capacity limits both the bytes that have been reassembled,</span><br>    <span class="hljs-comment">//! and those that have not yet been reassembled.</span><br>    <span class="hljs-built_in">StreamReassembler</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> capacity);<br><br>    <span class="hljs-comment">//! \brief Receive a substring and write any newly contiguous bytes into the stream.</span><br>    <span class="hljs-comment">//!</span><br>    <span class="hljs-comment">//! The StreamReassembler will stay within the memory limits of the `capacity`.</span><br>    <span class="hljs-comment">//! Bytes that would exceed the capacity are silently discarded.</span><br>    <span class="hljs-comment">//!</span><br>    <span class="hljs-comment">//! \param data the substring</span><br>    <span class="hljs-comment">//! \param index indicates the index (place in sequence) of the first byte in `data`</span><br>    <span class="hljs-comment">//! \param eof the last byte of `data` will be the last byte in the entire stream</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_substring</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string &amp;data, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint64_t</span> index, <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> eof)</span></span>;<br><br>    <span class="hljs-comment">//! \name Access the reassembled byte stream</span><br>    <span class="hljs-comment">//!@&#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">const</span> ByteStream &amp;<span class="hljs-title">stream_out</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _output; &#125;<br>    <span class="hljs-function">ByteStream &amp;<span class="hljs-title">stream_out</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _output; &#125;<br>    <span class="hljs-comment">//!@&#125;</span><br><br>    <span class="hljs-comment">//! The number of bytes in the substrings stored but not yet reassembled</span><br>    <span class="hljs-comment">//!</span><br>    <span class="hljs-comment">//! \note If the byte at a particular index has been pushed more than once, it</span><br>    <span class="hljs-comment">//! should only be counted once for the purpose of this function.</span><br>    <span class="hljs-comment">/*unassembled byte是还未传递但是要传递给bytestream的储存在StreamReassembler的字符数，</span><br><span class="hljs-comment">     * 其中如果不同的字符串有重叠部分的话，重叠部分只算一次</span><br><span class="hljs-comment">     * */</span><br>    <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">unassembled_bytes</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><br>    <span class="hljs-comment">//! \brief Is the internal state empty (other than the output stream)?</span><br>    <span class="hljs-comment">//! \returns `true` if no substrings are waiting to be assembled</span><br>    <span class="hljs-comment">//判空函数，</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// SPONGE_LIBSPONGE_STREAM_REASSEMBLER_HH</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>standford_cs144_lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stanford_CS144_Lab3</title>
    <link href="/2021/11/23/Stanford-CS144-Lab3/"/>
    <url>/2021/11/23/Stanford-CS144-Lab3/</url>
    
    <content type="html"><![CDATA[<p>在这个实验中我们要完成tcp_sender的部分。由于我们实现的是简易的TCP，因此在测试集对于拥塞控制并没有太多要求，且计时器我们也只用实现重传计时器。</p><p>我们先来理解bytes_in_flight，bytes_in_flight是发送但还未确认的数据长度。根据概念，这段长度等于_next_seqno减去base。因此我们定义一个base用来维护基序号，同时也可以完成bytes_in_flight函数。代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">uint64_t</span> <span class="hljs-title">TCPSender::bytes_in_flight</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;    <span class="hljs-keyword">return</span> _next_seqno-base;&#125;<br></code></pre></td></tr></table></figure><h4 id="TCP连接与释放（三次握手与四次挥手）"><a href="#TCP连接与释放（三次握手与四次挥手）" class="headerlink" title="TCP连接与释放（三次握手与四次挥手）"></a>TCP连接与释放（三次握手与四次挥手）</h4><p>在这个实验中我们同样要用到三次握手的知识，为了更好的解释实现过程，我们用以下图示解释。</p><p><img src="http://tva4.sinaimg.cn/large/007SD2TBly1gwp74pmbcrj30jv0dgmz0.jpg" alt=""></p><p>在介绍三次握手之前，先要说说TCP头部的一些常用字段（这也是我们实验中要用到的）。</p><ul><li>序号：seqno，占32位，用来标识从发送端到接收端的字节流；</li><li>确认号：ackno，占32位，只有ACK标志位为1时，确认号才有效，ackno=seqno+1；</li><li>标志位：<ul><li>SYN：发起一个连接；</li><li>FIN：释放一个连接；</li><li>ACK：确认序号有效。</li></ul></li></ul><p>我们可以将sender理解为将要发送syn报文的client(事实上，client和server都有sender和receiver，我们将在lab4中具体组装sender和receiver）。至此，我们的lab都是单向通信。发送方只有一个TCPsender，接收方只有一个TCPReceiver，由TCPsender发送的和TCPReceiver返回的都是TCPsegment格式的TCP报文段，只不过由于单向通信，所以发送方的TCPsegment中只包含序列号seqno、 Payload、SYN 和 FIN，接收方返回的TCPsegment中只包含ackno和window size。作为绝对序号，_next_seqno的初始值为0，此时我们必须发送SYN报文建立连接，也就是第一次握手，seqno为 _isn（即上图的x，这是系统赋予的），syn为true，payload置空，报文准备好后，我们将其写入到定义好的队列 _segments_out，等待系统调用，同时，我们为了实现重传，定义了一个 _segments_out_cache,作为缓冲区，用于缓存报文，在特定的情况下将报文重传。当然，我们也要维护GBN中的滑动窗口，因此定义一个curr_window_size，用来维护当前可用窗口的大小。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(_next_seqno==<span class="hljs-number">0</span>)&#123;<br>    TCPSegment seg;<br>    seg.<span class="hljs-built_in">header</span>().seqno=_isn;<br>    seg.<span class="hljs-built_in">header</span>().syn= <span class="hljs-literal">true</span>;<br>    _next_seqno=<span class="hljs-number">1</span>;<br>    curr_window_size--;<span class="hljs-comment">//当前可用窗口减1</span><br>    _segments_out.<span class="hljs-built_in">push</span>(seg);<br>    _segments_out_cache.<span class="hljs-built_in">push</span>(seg);<br>&#125;<br></code></pre></td></tr></table></figure><p>当client接收第二次握手时传入的内容，即ack=x+1，也即ackno_64=1的内容，将会调用ack_received函数，ack_received函数的定义——<code>ack_received(const WrappingInt32 ackno, const uint16_t window_size)</code>，此时ackno=_isn+1，我们会执行如下操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(base==<span class="hljs-number">0</span>&amp;&amp;ackno_64==<span class="hljs-number">1</span>)&#123;    <br>    base=<span class="hljs-number">1</span>;    <br>    _segments_out_cache.<span class="hljs-built_in">pop</span>();    <br>    _consecutive_remission=<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>将base置为1，也就是将基序号+1；将缓冲队列出队（此时对方已经确认，我们不需要了）；连续重传此时对于sender来说，我们可以进行正常的报文发送了，也就是第三次握手。</p><p>无独有偶，实验中也要用到四次挥手的知识，为了更好的解释该过程，我们用下图解释。</p><p><img src="http://tvax2.sinaimg.cn/large/007SD2TBly1gwp7wnrwe6j30kw0ddjtu.jpg" alt=""></p><p>在该实验中，当数据传输完成时，即 _stream.eof等于1时，我们要进行挥手，此时sender发送fin报文，即fin为1。如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(_stream.<span class="hljs-built_in">eof</span>())&#123;<br>    fin_flag=<span class="hljs-literal">true</span>;<br>    TCPSegment seg;<br>    <span class="hljs-comment">//将syn设置为false，将fin设置为true</span><br>    seg.<span class="hljs-built_in">header</span>().syn= <span class="hljs-literal">false</span>;<br>    seg.<span class="hljs-built_in">header</span>().fin=<span class="hljs-literal">true</span>;<br>    seg.<span class="hljs-built_in">header</span>().seqno= <span class="hljs-built_in">wrap</span>(_next_seqno,_isn);<br>    _next_seqno++;<br>    <span class="hljs-comment">//维护窗口</span><br>    curr_window_size--;<br>    _segments_out_cache.<span class="hljs-built_in">push</span>(seg);<br>    _segments_out.<span class="hljs-built_in">push</span>(seg);<br>&#125;<br></code></pre></td></tr></table></figure><p>在该实验中，我们有两种情况发送fin包，第一种是恰好 _stream.eof为1，即刚好将 _stream中的数据全部读取完毕，这个时候我们发送一个fin值为1，payload为空的报文。第二种情况是发送窗口大于 _stream.size，此时也可以将 _stream中的报文读完。此时我们将最后一个报文(读取 _stream之后 _stream为空）的fin值置为1。值得注意的是，当fin值为1是要占用一个序号。因为有MAX_PAYLOAD_SIZE的限制，我们将用while进行循环读取。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">while</span> (!_stream.<span class="hljs-built_in">buffer_empty</span>()&amp;&amp;curr_window_size&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//这里会有两种状况，一种是_stream为空但窗口不为空；一种是窗口为空但_stream不为空。</span><br>        <span class="hljs-comment">//我们找到_stream curr_window_size以及payload中的最小值，作为发送报文的长度</span><br>        <span class="hljs-keyword">uint64_t</span> lens_byte=std::<span class="hljs-built_in">min</span>(_stream.<span class="hljs-built_in">buffer_size</span>(),<span class="hljs-built_in">uint64_t</span> (curr_window_size));<br>        lens_byte=std::<span class="hljs-built_in">min</span>(lens_byte,TCPConfig::MAX_PAYLOAD_SIZE);<br>        TCPSegment seg;<br>        <span class="hljs-comment">//对header中的字段进行赋值</span><br>        seg.<span class="hljs-built_in">header</span>().seqno= <span class="hljs-built_in">wrap</span>(_next_seqno,_isn);<br>        seg.<span class="hljs-built_in">header</span>().syn=<span class="hljs-literal">false</span>;<br>        seg.<span class="hljs-built_in">payload</span>()=_stream.<span class="hljs-built_in">read</span>(lens_byte);<br>        _next_seqno+=lens_byte;<br>        <span class="hljs-comment">//将curr_window_size减去lens_byte</span><br>        curr_window_size-=lens_byte;<br>        <span class="hljs-comment">//如果_stream已经空了，那么我们就进行第一次挥手</span><br>        <span class="hljs-keyword">if</span>(_stream.<span class="hljs-built_in">eof</span>()&amp;&amp;curr_window_size&gt;<span class="hljs-number">0</span>)&#123;<br>            seg.<span class="hljs-built_in">header</span>().fin= <span class="hljs-literal">true</span>;<br>            fin_flag= <span class="hljs-literal">true</span>;<br>            curr_window_size--;<br>            _next_seqno++;<br>        &#125;<br>        _segments_out.<span class="hljs-built_in">push</span>(seg);<br>        _segments_out_cache.<span class="hljs-built_in">push</span>(seg);<br>        <span class="hljs-keyword">if</span>(fin_flag)&#123;<span class="hljs-comment">//开始挥手之后就可以退出</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="TCP重传机制"><a href="#TCP重传机制" class="headerlink" title="TCP重传机制"></a>TCP重传机制</h4><p>在每次发送报文之后，都会启动一个定时器，如果在定时器时间内没有收到，则进行重传。而重传的超时时间，则称为RTO（Retransmission TimeOut），我们就要开始计时，将初始超时重传时间 _time_out设置 _initial_retransmission_timeout，如果发生超时，将 _time_out设置x2。这个跟我们在《计算机网络黑皮书》上学到的不一样，是最新的标准。上述过程用time_waiting标志位进行维护。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(!time_waiting)&#123;<br>    _time_out=_initial_retransmission_timeout;<br>    time_waiting=<span class="hljs-literal">true</span>;<span class="hljs-comment">//为true的时候表示我们正在计时</span><br>    _total_time=<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么这个tick函数就很好做了，每次调用tick函数，_total_time加上 ms_since_last_tick，如果总时间大于超时时间，那么我们就可以进行重传，并将重传的次数+1，我们的 TCPConnection 将使用此信息来决定连接是否无望（连续重传过多）并需要中止，如果window size不为0，那么我们将RTO的值翻倍，称为指数退避。将总计时时间置为0。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sqf">void TCPSender::tick(const size_t ms_since_last_tick) &#123;<br>    DUMMY_CODE(ms_since_last_tick);<br>    <span class="hljs-variable">_total_time</span>+=ms_since_last_tick;<br>    <span class="hljs-comment">//如果缓冲队列不为空，停等时间在运行，且总时间大于超时</span><br>    <span class="hljs-keyword">if</span>(!<span class="hljs-variable">_segments_out_cache</span>.empty()&amp;&amp;time_waiting&amp;&amp;<span class="hljs-variable">_total_time</span>&gt;=<span class="hljs-variable">_time_out</span>)&#123;<br>        <span class="hljs-variable">_segments_out</span>.push(<span class="hljs-variable">_segments_out_cache</span>.front());<br>        <span class="hljs-comment">//重传次数增加</span><br>        <span class="hljs-variable">_consecutive_remission</span>++;<br>        <span class="hljs-keyword">if</span>(!window_zero)&#123;<br>            <span class="hljs-variable">_time_out</span>*=<span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-variable">_total_time</span>=<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>值得注意的是，TCP中有7种定时器，我们在这里只实现了重传定时器：</p><ul><li>建立连接定时器(connection-establishment timer)</li><li>重传定时器(retransmission timer)</li><li>延迟应答定时器(delayed ACK timer)</li><li>坚持定时器(persist timer)</li><li>保活定时器(keepalive timer)</li><li>FIN_WAIT_2定时器(FIN_WAIT_2 timer)</li><li>TIME_WAIT定时器 (TIME_WAIT timer, 也叫2MSL timer)</li></ul><h4 id="ack-received"><a href="#ack-received" class="headerlink" title="ack_received"></a>ack_received</h4><p>1.如果 ackno_64大于 _next_seqno，就会触发SYN_SENT状态，按照常理来说，ackno_64是不应该大于 _next_seqno,如果ackno_64大于 _next_seqno，我们将其定为“<em>stream started but nothing acknowledged</em>“，直接返回即可，等待下一次传入的ackno，至于为什么会出现ackno_64大于 _next_seqno我们并不关心。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">uint <span class="hljs-keyword">64_t</span> ackno_64= <span class="hljs-built_in">unwrap</span>(ackno,_isn,base);<br><span class="hljs-keyword">if</span>(ackno_64&gt;_next_seqno)&#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.对于三次握手中的第二次握手，也就是我们客户端收到确认报文这个情况，对于发送方的窗口而言，我们应当这样实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(base==<span class="hljs-number">0</span>&amp;&amp;ackno_64==<span class="hljs-number">1</span>)&#123;<br>       base=<span class="hljs-number">1</span>;<br>       _segments_out_cache.<span class="hljs-built_in">pop</span>();<br>       _consecutive_remission=<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.如果是正常的接收确认报文，对于窗口而言，我们应当这样实现，代码如下（详解在注释中）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//下面代码就是在模拟GBN,根据接收到的ackno，删除窗口中base和ackno之间的数据</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!_segments_out_cache.<span class="hljs-built_in">empty</span>() &amp;&amp; ackno_64 &gt;= base + _segments_out_cache.<span class="hljs-built_in">front</span>().<span class="hljs-built_in">length_in_sequence_space</span>()) &#123;<span class="hljs-comment">//收到的确认号大于base+发送的报文的长度</span><br>        <span class="hljs-comment">//缓冲队列第一个元素的序号</span><br>        <span class="hljs-keyword">uint64_t</span> copy_seg_seqno = <span class="hljs-built_in">unwrap</span>(_segments_out_cache.<span class="hljs-built_in">front</span>().<span class="hljs-built_in">header</span>().seqno, _isn, base);<br>        <span class="hljs-comment">//缓冲队列第一个元素的长度</span><br>        <span class="hljs-keyword">uint64_t</span> copy_seg_len = _segments_out_cache.<span class="hljs-built_in">front</span>().<span class="hljs-built_in">length_in_sequence_space</span>();<br>        <span class="hljs-comment">//序号加长度小于等于确认号，就一个一个删除</span><br>        <span class="hljs-keyword">while</span> (copy_seg_seqno + copy_seg_len &lt;= ackno_64) &#123;<br>            base += _segments_out_cache.<span class="hljs-built_in">front</span>().<span class="hljs-built_in">length_in_sequence_space</span>();<br>            _segments_out_cache.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (_segments_out_cache.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">break</span>;<br>            copy_seg_seqno = <span class="hljs-built_in">unwrap</span>(_segments_out_cache.<span class="hljs-built_in">front</span>().<span class="hljs-built_in">header</span>().seqno, _isn, base);<br>            copy_seg_len = _segments_out_cache.<span class="hljs-built_in">front</span>().<span class="hljs-built_in">length_in_sequence_space</span>();<br>        &#125;<br>        _time_out = _initial_retransmission_timeout;<br>        _total_time = <span class="hljs-number">0</span>;<br>        _consecutive_remission = <span class="hljs-number">0</span>;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>4.对于流量控制，我们需要用接收方的窗口大小来维护发送方的窗口大小，如果说<code>_next_seqno-base&gt;=window_size</code>，那么此时我们肯定是不能发送报文的，在这种情况下，说明我们发送出去但还没有确认的报文的长度大于接收窗口的长度，这种情况下我们如果再次发送报文可能会导致接收方接收出现问题。代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(_next_seqno-base&gt;=window_size)&#123;<br>        curr_window_size=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的curr_window_size就是活动窗口中待发送的长度，这个长度是根据接收窗口维护的。</p><p><code>tcp_sender.hh</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> SPONGE_LIBSPONGE_TCP_SENDER_HH</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SPONGE_LIBSPONGE_TCP_SENDER_HH</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;byte_stream.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;tcp_config.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;tcp_segment.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;wrapping_integers.hh&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><br><span class="hljs-comment">//! \brief The &quot;sender&quot; part of a TCP implementation.</span><br><br><span class="hljs-comment">//! Accepts a ByteStream, divides it up into segments and sends the</span><br><span class="hljs-comment">//! segments, keeps track of which segments are still in-flight,</span><br><span class="hljs-comment">//! maintains the Retransmission Timer, and retransmits in-flight</span><br><span class="hljs-comment">//! segments if the retransmission timer expires.</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TCPSender</span> &#123;</span><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//! our initial sequence number, the number for our SYN.</span><br>    WrappingInt32 _isn;<br><br>    <span class="hljs-keyword">uint64_t</span> base&#123;<span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-comment">//! outbound queue of segments that the TCPSender wants sent</span><br>    std::queue&lt;TCPSegment&gt; _segments_out&#123;&#125;;<br>    std::queue&lt;TCPSegment&gt; _segments_out_cache&#123;&#125;;<br>    <span class="hljs-comment">//! retransmission timer for the connection</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> _initial_retransmission_timeout;<br><br>    <span class="hljs-comment">//! outgoing stream of bytes that have not yet been sent</span><br>    ByteStream _stream;<br><br>    <span class="hljs-comment">//! the (absolute) sequence number for the next byte to be sent</span><br>    <span class="hljs-keyword">uint64_t</span> _next_seqno&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">uint16_t</span> curr_window_size;<br>    <span class="hljs-keyword">bool</span> fin_flag;<br>    <span class="hljs-keyword">size_t</span> _total_time;<br>    <span class="hljs-keyword">bool</span> time_waiting;<br>    <span class="hljs-keyword">int</span> _consecutive_remission;<br>    <span class="hljs-keyword">size_t</span> _time_out;<br>    <span class="hljs-keyword">bool</span> window_zero;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//! Initialize a TCPSender</span><br>    <span class="hljs-built_in">TCPSender</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> capacity = TCPConfig::DEFAULT_CAPACITY,<br>              <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint16_t</span> retx_timeout = TCPConfig::TIMEOUT_DFLT,<br>              <span class="hljs-keyword">const</span> std::optional&lt;WrappingInt32&gt; fixed_isn = &#123;&#125;);<br><br>    <span class="hljs-comment">//! \name &quot;Input&quot; interface for the writer</span><br>    <span class="hljs-comment">//!@&#123;</span><br>    <span class="hljs-function">ByteStream &amp;<span class="hljs-title">stream_in</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _stream; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">const</span> ByteStream &amp;<span class="hljs-title">stream_in</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _stream; &#125;<br>    <span class="hljs-comment">//!@&#125;</span><br><br>    <span class="hljs-comment">//! \name Methods that can cause the TCPSender to send a segment</span><br>    <span class="hljs-comment">//!@&#123;</span><br><br>    <span class="hljs-comment">//! \brief A new acknowledgment was received</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ack_received</span><span class="hljs-params">(<span class="hljs-keyword">const</span> WrappingInt32 ackno, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint16_t</span> window_size)</span></span>;<br><br>    <span class="hljs-comment">//! \brief Generate an empty-payload segment (useful for creating empty ACK segments)</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">send_empty_segment</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//! \brief create and send segments to fill as much of the window as possible</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fill_window</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//! \brief Notifies the TCPSender of the passage of time</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tick</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> ms_since_last_tick)</span></span>;<br>    <span class="hljs-comment">//!@&#125;</span><br><br>    <span class="hljs-comment">//! \name Accessors</span><br>    <span class="hljs-comment">//!@&#123;</span><br><br>    <span class="hljs-comment">//! \brief How many sequence numbers are occupied by segments sent but not yet acknowledged?</span><br>    <span class="hljs-comment">//! \note count is in &quot;sequence space,&quot; i.e. SYN and FIN each count for one byte</span><br>    <span class="hljs-comment">//! (see TCPSegment::length_in_sequence_space())</span><br>    <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">bytes_in_flight</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><br>    <span class="hljs-comment">//! \brief Number of consecutive retransmissions that have occurred in a row</span><br>    <span class="hljs-comment">//连续发生的重传次数</span><br>    <span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">consecutive_retransmissions</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><br>    <span class="hljs-comment">//! \brief TCPSegments that the TCPSender has enqueued for transmission.</span><br>    <span class="hljs-comment">//! \note These must be dequeued and sent by the TCPConnection,</span><br>    <span class="hljs-comment">//! which will need to fill in the fields that are set by the TCPReceiver</span><br>    <span class="hljs-comment">//! (ackno and window size) before sending.</span><br>    <span class="hljs-function">std::queue&lt;TCPSegment&gt; &amp;<span class="hljs-title">segments_out</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _segments_out; &#125;<br>    <span class="hljs-comment">//!@&#125;</span><br><br>    <span class="hljs-comment">//! \name What is the next sequence number? (used for testing)</span><br>    <span class="hljs-comment">//!@&#123;</span><br><br>    <span class="hljs-comment">//! \brief absolute seqno for the next byte to be sent</span><br>    <span class="hljs-function"><span class="hljs-keyword">uint64_t</span> <span class="hljs-title">next_seqno_absolute</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _next_seqno; &#125;<br><br>    <span class="hljs-comment">//! \brief relative seqno for the next byte to be sent</span><br>    <span class="hljs-function">WrappingInt32 <span class="hljs-title">next_seqno</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">wrap</span>(_next_seqno, _isn); &#125;<br>    <span class="hljs-comment">//!@&#125;</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// SPONGE_LIBSPONGE_TCP_SENDER_HH</span></span><br></code></pre></td></tr></table></figure><p><code>tcp_sender.cc</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;tcp_sender.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;iostream&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;tcp_config.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;random&gt;</span></span><br><br><span class="hljs-comment">// Dummy implementation of a TCP sender</span><br><br><span class="hljs-comment">// For Lab 3, please replace with a real implementation that passes the</span><br><span class="hljs-comment">// automated checks run by `make check_lab3`.</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Targs&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DUMMY_CODE</span><span class="hljs-params">(Targs &amp;&amp;... <span class="hljs-comment">/* unused */</span>)</span> </span>&#123;&#125;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//! \param[in] capacity the capacity of the outgoing byte stream</span><br><span class="hljs-comment">//! \param[in] retx_timeout the initial amount of time to wait before retransmitting the oldest outstanding segment</span><br><span class="hljs-comment">//! \param[in] fixed_isn the Initial Sequence Number to use, if set (otherwise uses a random ISN)</span><br>TCPSender::<span class="hljs-built_in">TCPSender</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> capacity, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint16_t</span> retx_timeout, <span class="hljs-keyword">const</span> std::optional&lt;WrappingInt32&gt; fixed_isn)<br>    : _isn(fixed_isn.<span class="hljs-built_in">value_or</span>(WrappingInt32&#123;<span class="hljs-built_in">random_device</span>()()&#125;))<br>    ,<span class="hljs-built_in">base</span>(<span class="hljs-number">0</span>)<br>    , _initial_retransmission_timeout&#123;retx_timeout&#125;<br>    , _stream(capacity)<br>    , <span class="hljs-built_in">curr_window_size</span>(<span class="hljs-number">1</span>)<br>    , <span class="hljs-built_in">fin_flag</span>(<span class="hljs-literal">false</span>)<br>    , _total_time(<span class="hljs-number">0</span>)<br>    , <span class="hljs-built_in">time_waiting</span>(<span class="hljs-literal">false</span>)<br>    , _consecutive_remission(<span class="hljs-number">0</span>)<br>    , _time_out(<span class="hljs-number">0</span>)<br>    , <span class="hljs-built_in">window_zero</span>(<span class="hljs-literal">false</span>)<br>    &#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">uint64_t</span> <span class="hljs-title">TCPSender::bytes_in_flight</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> _next_seqno-base;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TCPSender::fill_window</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(curr_window_size==<span class="hljs-number">0</span>||fin_flag)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(_next_seqno==<span class="hljs-number">0</span>)&#123;<br>        TCPSegment seg;<br>        seg.<span class="hljs-built_in">header</span>().seqno=_isn;<br>        seg.<span class="hljs-built_in">header</span>().syn= <span class="hljs-literal">true</span>;<br>        _next_seqno=<span class="hljs-number">1</span>;<br>        curr_window_size--;<br>        _segments_out.<span class="hljs-built_in">push</span>(seg);<br>        _segments_out_cache.<span class="hljs-built_in">push</span>(seg);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(_stream.<span class="hljs-built_in">eof</span>())&#123;<br>        fin_flag=<span class="hljs-literal">true</span>;<br>        TCPSegment seg;<br>        seg.<span class="hljs-built_in">header</span>().syn= <span class="hljs-literal">false</span>;<br>        seg.<span class="hljs-built_in">header</span>().fin=<span class="hljs-literal">true</span>;<br>        seg.<span class="hljs-built_in">header</span>().seqno= <span class="hljs-built_in">wrap</span>(_next_seqno,_isn);<br>        _next_seqno++;<br>        curr_window_size--;<br>        _segments_out_cache.<span class="hljs-built_in">push</span>(seg);<br>        _segments_out.<span class="hljs-built_in">push</span>(seg);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">while</span> (!_stream.<span class="hljs-built_in">buffer_empty</span>()&amp;&amp;curr_window_size&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">uint64_t</span> lens_byte=std::<span class="hljs-built_in">min</span>(_stream.<span class="hljs-built_in">buffer_size</span>(),<span class="hljs-built_in">uint64_t</span> (curr_window_size));<br>            lens_byte=std::<span class="hljs-built_in">min</span>(lens_byte,TCPConfig::MAX_PAYLOAD_SIZE);<br>            TCPSegment seg;<br>            seg.<span class="hljs-built_in">header</span>().seqno= <span class="hljs-built_in">wrap</span>(_next_seqno,_isn);<br>            seg.<span class="hljs-built_in">header</span>().syn=<span class="hljs-literal">false</span>;<br>            seg.<span class="hljs-built_in">payload</span>()=_stream.<span class="hljs-built_in">read</span>(lens_byte);<br>            _next_seqno+=lens_byte;<br>            curr_window_size-=lens_byte;<br>            <span class="hljs-keyword">if</span>(_stream.<span class="hljs-built_in">eof</span>()&amp;&amp;curr_window_size&gt;<span class="hljs-number">0</span>)&#123;<br>                seg.<span class="hljs-built_in">header</span>().fin= <span class="hljs-literal">true</span>;<br>                fin_flag= <span class="hljs-literal">true</span>;<br>                curr_window_size--;<br>                _next_seqno++;<br>            &#125;<br>            _segments_out.<span class="hljs-built_in">push</span>(seg);<br>            _segments_out_cache.<span class="hljs-built_in">push</span>(seg);<br>            <span class="hljs-keyword">if</span>(fin_flag)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//开始计时</span><br>    <span class="hljs-keyword">if</span>(!time_waiting)&#123;<br>        _time_out=_initial_retransmission_timeout;<br>        time_waiting=<span class="hljs-literal">true</span>;<br>        _total_time=<span class="hljs-number">0</span>;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//! \param ackno The remote receiver&#x27;s ackno (acknowledgment number)</span><br><span class="hljs-comment">//! \param window_size The remote receiver&#x27;s advertised window size</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TCPSender::ack_received</span><span class="hljs-params">(<span class="hljs-keyword">const</span> WrappingInt32 ackno, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint16_t</span> window_size)</span> </span>&#123;<br>    <span class="hljs-built_in">DUMMY_CODE</span>(ackno, window_size);<br>    <span class="hljs-keyword">uint64_t</span> ackno_64= <span class="hljs-built_in">unwrap</span>(ackno,_isn,base);<br>    <span class="hljs-keyword">if</span>(base==<span class="hljs-number">0</span>&amp;&amp;ackno_64==<span class="hljs-number">1</span>)&#123;<br>        base=<span class="hljs-number">1</span>;<br>        _segments_out_cache.<span class="hljs-built_in">pop</span>();<br>        _consecutive_remission=<span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!_segments_out_cache.<span class="hljs-built_in">empty</span>() &amp;&amp; ackno_64 &gt;= base + _segments_out_cache.<span class="hljs-built_in">front</span>().<span class="hljs-built_in">length_in_sequence_space</span>()) &#123;<br>        <span class="hljs-comment">//缓冲队列第一个元素的序号</span><br>        <span class="hljs-keyword">uint64_t</span> copy_seg_seqno = <span class="hljs-built_in">unwrap</span>(_segments_out_cache.<span class="hljs-built_in">front</span>().<span class="hljs-built_in">header</span>().seqno, _isn, base);<br>        <span class="hljs-comment">//缓冲队列第一个元素的长度</span><br>        <span class="hljs-keyword">uint64_t</span> copy_seg_len = _segments_out_cache.<span class="hljs-built_in">front</span>().<span class="hljs-built_in">length_in_sequence_space</span>();<br>        <span class="hljs-comment">//序号加长度小于等于确认号，就一个一个删除</span><br>        <span class="hljs-keyword">while</span> (copy_seg_seqno + copy_seg_len &lt;= ackno_64) &#123;<br>            base += _segments_out_cache.<span class="hljs-built_in">front</span>().<span class="hljs-built_in">length_in_sequence_space</span>();<br>            _segments_out_cache.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (_segments_out_cache.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">break</span>;<br>            copy_seg_seqno = <span class="hljs-built_in">unwrap</span>(_segments_out_cache.<span class="hljs-built_in">front</span>().<span class="hljs-built_in">header</span>().seqno, _isn, base);<br>            copy_seg_len = _segments_out_cache.<span class="hljs-built_in">front</span>().<span class="hljs-built_in">length_in_sequence_space</span>();<br>        &#125;<br>        _time_out = _initial_retransmission_timeout;<br>        _total_time = <span class="hljs-number">0</span>;<br>        _consecutive_remission = <span class="hljs-number">0</span>;<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ackno_64==_next_seqno&amp;&amp;fin_flag)&#123;<br>        base=ackno_64;<br>        _segments_out_cache.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">if</span>(_next_seqno-base==<span class="hljs-number">0</span>)&#123;<br>        time_waiting= <span class="hljs-literal">false</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(_next_seqno-base&gt;=window_size)&#123;<br>        curr_window_size=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(window_size==<span class="hljs-number">0</span>)&#123;<br>        curr_window_size=<span class="hljs-number">1</span>;<br>        window_zero= <span class="hljs-literal">true</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        curr_window_size=window_size;<br>        window_zero= <span class="hljs-literal">false</span>;<br>        _consecutive_remission=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">fill_window</span>();<br>&#125;<br><br><span class="hljs-comment">//! \param[in] ms_since_last_tick the number of milliseconds since the last call to this method</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TCPSender::tick</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> ms_since_last_tick)</span> </span>&#123;<br>    <span class="hljs-built_in">DUMMY_CODE</span>(ms_since_last_tick);<br>    _total_time+=ms_since_last_tick;<br>    <span class="hljs-comment">//如果缓冲队列不为空，停等时间在运行，且总时间大于超时</span><br>    <span class="hljs-keyword">if</span>(!_segments_out_cache.<span class="hljs-built_in">empty</span>()&amp;&amp;time_waiting&amp;&amp;_total_time&gt;=_time_out)&#123;<br>        _segments_out.<span class="hljs-built_in">push</span>(_segments_out_cache.<span class="hljs-built_in">front</span>());<br>        <span class="hljs-comment">//重传次数增加</span><br>        _consecutive_remission++;<br>        <span class="hljs-keyword">if</span>(!window_zero)&#123;<br>            _time_out*=<span class="hljs-number">2</span>;<br>        &#125;<br>        _total_time=<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">TCPSender::consecutive_retransmissions</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _consecutive_remission; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TCPSender::send_empty_segment</span><span class="hljs-params">()</span> </span>&#123;<br>    TCPSegment seg;<br>    seg.<span class="hljs-built_in">header</span>().seqno= <span class="hljs-built_in">wrap</span>(_next_seqno,_isn);<br>    seg.<span class="hljs-built_in">payload</span>()=&#123;&#125;;<br>    _segments_out.<span class="hljs-built_in">push</span>(seg);<br>&#125;<br></code></pre></td></tr></table></figure><p>做到这里我们就可以理解几个面经的问题了：</p><p>Q1:<strong><em>TCP建立连接可以两次握手吗？为什么？</em></strong></p><p>A1:不可以。有两个原因：</p><ol><li><p>已经失效的连接请求报文段又传到了服务器端。</p><blockquote><p>client发出的第一个连接请求报文并没有丢失，而是在某个网络结点长时间地滞留了，以致于延误到连接释放以后的某个时间才到达server，本来这是一个已经失效的报文段，但server收到此失效的连接请求报文段后，还是向client发出确认报文段，同意建立连接。假设不采用三次握手，那么只要server发出确认，新的连接就建立了，由于此时client不会与server进行通讯，那么server的资源就白白浪费了。</p></blockquote></li><li><p>两次握手无法保证client端正确接收第二次握手的报文，无法保证client和server之间成功互换了初始序列号。</p></li></ol><p>Q2:<strong><em>为什么TCP连接的时候是3次，关闭的时候却是4次？</em></strong></p><p>A2:因为关闭的时候必须要确保通信双方都能通知对方释放连接，假设客户端发送完数据向服务端发送释放连接的请求，客户端并不知道，服务端是否已经发送完数据，所以此次断开的是客户端到服务端的单项连接，服务端返回给客户端确认报文后，服务端还能继续单向给客户端发送数据。也就是说第二次挥手就是服务端向客户端发送确认报文，这之后服务端还能单向给客户端发送数据。当服务端发送完数据后还需要向客户端发送释放连接请求，客户端返回确认报文，TCP才彻底关闭，四次挥手代表的是客户端和服务器端分别向对方发送释放连接的报文和发送确认报文，一共需要四次。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>standford_cs144_lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stanford_CS144_Lab2</title>
    <link href="/2021/11/20/Stanford-CS144-Lab2/"/>
    <url>/2021/11/20/Stanford-CS144-Lab2/</url>
    
    <content type="html"><![CDATA[<p>CS144实际上是基于UDP实现TCP，我们都知道TCP是以stream传输，而UDP是以segment传输，在CS144中，我们会将发送方的stream封装到segment中然后发送，当接收方收到segment后，会将其解析为stream，传递到上层。所以我们说基于UDP实现TCP。</p><h3 id="Translating-between-64-bit-indexes-and-32-bit-seqnos"><a href="#Translating-between-64-bit-indexes-and-32-bit-seqnos" class="headerlink" title="Translating between 64-bit indexes and 32-bit seqnos"></a>Translating between 64-bit indexes and 32-bit seqnos</h3><p>《自顶向下》中，在讲到GBN协议时有这样一段话可能大家都忽略了，原文如下：</p><blockquote><p>在实践中，一个分组的序号承载在分组首部的一个固定长度的字段中。如果分组序号字段的比特数是k,则该序号范围是[0,2^k]。 在一个有限的序号范围内，所有涉及序号的运算必须使用模2^k 运算。（即序号空间可被看作是一个长度为2^k 的环，其中序号2^k-1紧挨着0）。</p></blockquote><p>序号的大小始终限制在2^k 之内，事实上，我们往往取k为32,这个序号被称为相对序号，与之相对应的还有绝对序号，即没有被取模2^k 序号，其大小范围为2^64,在这个任 务中我们要完成相对序号和绝对序号的转换。</p><p>值得注意的是，相对序号的起始值是一个随机数_isn，这样取的好处是增加报文复杂程度，而绝对序号的起始值为0,具体如下图所示：</p><p><img src="http://tvax1.sinaimg.cn/large/007SD2TBly1gwp70kj8i8j30el0383z6.jpg" alt=""></p><p>首先是绝对序号转化为相对序号，根据位运算和模运算，我们只需要将绝对序号n加上相对序号_isn,赋值给一个32位数字。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">WrappingInt32 <span class="hljs-title">wrap</span><span class="hljs-params">(<span class="hljs-keyword">uint64_t</span> n, WrappingInt32 isn)</span> </span>&#123;    <span class="hljs-built_in">DUMMY_CODE</span>(n, isn);    <span class="hljs-function">WrappingInt32 <span class="hljs-title">res</span><span class="hljs-params">(n+isn.raw_value())</span></span>;    <span class="hljs-keyword">return</span> res;&#125;<br></code></pre></td></tr></table></figure><p>接着是相对序号转化为绝对序号，其中n是待转化的相对序号，_isn是相对序号的起始值，checkpoint是参考值，也就是我们要找到离checkpoint最近的绝对序号。那么如何找到相应的绝对序号呢，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">uint64_t</span> <span class="hljs-title">unwrap</span><span class="hljs-params">(WrappingInt32 n, WrappingInt32 isn, <span class="hljs-keyword">uint64_t</span> checkpoint)</span> </span>&#123;<br>    <span class="hljs-built_in">DUMMY_CODE</span>(n, isn, checkpoint);<br>    <span class="hljs-keyword">uint64_t</span> temp=n.<span class="hljs-built_in">raw_value</span>()-isn.<span class="hljs-built_in">raw_value</span>();<br>    <span class="hljs-keyword">if</span>(checkpoint==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br>    <span class="hljs-keyword">uint32_t</span> div=checkpoint/(<span class="hljs-number">1ul</span>&lt;&lt;<span class="hljs-number">32</span>);<br>    <span class="hljs-keyword">uint32_t</span> res=checkpoint%(<span class="hljs-number">1ul</span>&lt;&lt;<span class="hljs-number">32</span>);<br>    <span class="hljs-keyword">if</span> (res&lt;=temp) &#123;<br>        temp=(checkpoint-temp-(div<span class="hljs-number">-1</span>)*(<span class="hljs-number">1ul</span>&lt;&lt;<span class="hljs-number">32</span>))&lt;(temp+div*(<span class="hljs-number">1ul</span>&lt;&lt;<span class="hljs-number">32</span>)-checkpoint)?temp+(div<span class="hljs-number">-1</span>)*(<span class="hljs-number">1ul</span>&lt;&lt;<span class="hljs-number">32</span>):temp+div*(<span class="hljs-number">1ul</span>&lt;&lt;<span class="hljs-number">32</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        temp=(checkpoint-temp-div*(<span class="hljs-number">1ul</span>&lt;&lt;<span class="hljs-number">32</span>))&lt;(temp+(div+<span class="hljs-number">1</span>)*(<span class="hljs-number">1ul</span>&lt;&lt;<span class="hljs-number">32</span>)-checkpoint)?temp+div*(<span class="hljs-number">1ul</span>&lt;&lt;<span class="hljs-number">32</span>):temp+(div+<span class="hljs-number">1</span>)*(<span class="hljs-number">1ul</span>&lt;&lt;<span class="hljs-number">32</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Implementing-the-TCP-receiver"><a href="#Implementing-the-TCP-receiver" class="headerlink" title="Implementing the TCP receiver"></a>Implementing the TCP receiver</h3><p>这个任务的主要目标是实现tcp的接收部分，在实现receiver之前，我们首先要熟悉segment类，具体可以参考tcp_segment.cc中的内容。TCP头部的一些常用字段（这也是我们实验中要用到的）如下：</p><ul><li>序号：seqno，占32位，用来标识从发送端到接收端的字节流；</li><li>确认号：ackno，占32位，只有ACK标志位为1时，确认号才有效，ackno=seqno+1；</li><li>标志位：<ul><li>SYN：发起一个连接；</li><li>FIN：释放一个连接；</li><li>ACK：确认序号有效。</li></ul></li></ul><p>1.在这个任务中我们要用到三次握手的知识，为了更好的解释实现过程，我们用以下图示解释(在下一个实验sender中也会用到该图）。</p><p><img src="http://tva4.sinaimg.cn/large/007SD2TBly1gwp74pmbcrj30jv0dgmz0.jpg" alt=""></p><p>我们可以将receiver简单地理解为接收syn时的server,也就是上图中第一个箭头所指向的server,客户端发送一个tcp的syn标志位置1的包，以及初始序号X，保存在包头的序列号seqno(Sequence Number)字段里。我们用syn_flag维护连接，如果传过来的syn值为1，则表示开始建立连接，（全部的建立连接过程将在lab3和lab4中完成），我们将syn_flag置为1，相反，如果syn值不为1且syn_flag不为1，则表示未开始建立连接或者根本没有建立连接，我们直接返回。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(seg.<span class="hljs-built_in">header</span>().syn)&#123;    <br>    syn_flag= <span class="hljs-literal">true</span>;    <span class="hljs-comment">//窗口的左端    </span><br>    ISN=seg.<span class="hljs-built_in">header</span>().seqno;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!syn_flag)&#123;    <br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.我们为了调用流重组器函数，要找到相应的data，index，eof，显然，data就是segment.payload()，index是seqno的绝对序号，请注意，在实验中syn和fin本身要占用一个序号，故除开建立连接时传过来的payload（实际上建立连接时不应该传输数据，仅本实验如此），index需要减去1。至于eof，则是根据fin值而定的。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TCPReceiver::segment_received</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCPSegment &amp;seg)</span> </span>&#123;<br>    <span class="hljs-built_in">DUMMY_CODE</span>(seg);<br>    <span class="hljs-comment">//代表第一个传过来的seg</span><br>    <span class="hljs-keyword">if</span>(seg.<span class="hljs-built_in">header</span>().syn)&#123;<br>        syn_flag= <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//窗口的左端</span><br>        ISN=seg.<span class="hljs-built_in">header</span>().seqno;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!syn_flag)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">uint64_t</span> received_lens=_reassembler.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">bytes_written</span>();<br>    <span class="hljs-keyword">size_t</span> index= <span class="hljs-built_in">unwrap</span>(seg.<span class="hljs-built_in">header</span>().seqno,ISN,received_lens);<br>    <span class="hljs-keyword">if</span>(!seg.<span class="hljs-built_in">header</span>().syn)&#123;<br>        index--;<br>    &#125;<br>    <span class="hljs-comment">//进行重组</span><br>    _reassembler.<span class="hljs-built_in">push_substring</span>(seg.<span class="hljs-built_in">payload</span>().<span class="hljs-built_in">copy</span>(),index,seg.<span class="hljs-built_in">header</span>().fin);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就完成了接收操作。然后我们要返回确认报文。</p><p>对于要返回的ackno，如果还未建立连接，我们就返回nullopt，否则，我们分为两种情况，一种是全部数据传输未完成，我们返回写入byte_stream的数据的序号加1，这样一种是全部数据传输完成之后，end_input为true,这个时候我们的返回值应该为写入byte_streamde的数据的序号加2（因为fin标志位要占1个位置）。</p><p>发送方没有收到ACK分为两种情况，一种是发送方发送的数据报丢失，因此接收方并没有向发送方返回ACK；另一种是接收方收到了发送方的数据报，但是返回的ACK丢失了，这种情况发送方重传后，接收方会直接丢弃发送方重传的数据报，然后再次发送ACK响应报文。</p><p>在代码中我们并没有实现这种情况，因为在<code>_reassembler.push_substring</code>中有解决这个问题的相关实现，如果说非要做一个这样的检验是否是重传的数据报的函数，可以增加一个buffer队列，用来缓存收到的segment的header，然后将收到的segment与其进行对比，但是lab并没有要求我们实现，所以没有做。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">optional&lt;WrappingInt32&gt; <span class="hljs-title">TCPReceiver::ackno</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!syn_flag)&#123;<br>        <span class="hljs-keyword">return</span> std::nullopt;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(_reassembler.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">input_ended</span>())&#123;<br>            <span class="hljs-keyword">return</span> ISN+_reassembler.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">bytes_written</span>()+<span class="hljs-number">2</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> ISN+_reassembler.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">bytes_written</span>()+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至于滑动窗口大小，就是我们之前提到过的重组器大小，即capacity减去已经写入byte_stream但还没有读取的数据的大小。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">TCPReceiver::window_size</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;    <span class="hljs-keyword">return</span> _capacity-_reassembler.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">bytes_written</span>()+_reassembler.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">bytes_read</span>();&#125;<br></code></pre></td></tr></table></figure><p><code>wrapping_integers.cc</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;wrapping_integers.hh&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;cmath&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// Dummy implementation of a 32-bit wrapping integer</span><br><br><span class="hljs-comment">// For Lab 2, please replace with a real implementation that passes the</span><br><span class="hljs-comment">// automated checks run by `make check_lab2`.</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Targs&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DUMMY_CODE</span><span class="hljs-params">(Targs &amp;&amp;... <span class="hljs-comment">/* unused */</span>)</span> </span>&#123;&#125;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//! Transform an &quot;absolute&quot; 64-bit sequence number (zero-indexed) into a WrappingInt32</span><br><span class="hljs-comment">//! \param n The input absolute 64-bit sequence number</span><br><span class="hljs-comment">//! \param isn The initial sequence number</span><br><span class="hljs-function">WrappingInt32 <span class="hljs-title">wrap</span><span class="hljs-params">(<span class="hljs-keyword">uint64_t</span> n, WrappingInt32 isn)</span> </span>&#123;<br>    <span class="hljs-built_in">DUMMY_CODE</span>(n, isn);<br>    <span class="hljs-function">WrappingInt32 <span class="hljs-title">res</span><span class="hljs-params">(n+isn.raw_value())</span></span>;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">//! Transform a WrappingInt32 into an &quot;absolute&quot; 64-bit sequence number (zero-indexed)</span><br><span class="hljs-comment">//! \param n The relative sequence number</span><br><span class="hljs-comment">//! \param isn The initial sequence number</span><br><span class="hljs-comment">//! \param checkpoint A recent absolute 64-bit sequence number</span><br><span class="hljs-comment">//! \returns the 64-bit sequence number that wraps to `n` and is closest to `checkpoint`</span><br><span class="hljs-comment">//!</span><br><span class="hljs-comment">//! \note Each of the two streams of the TCP connection has its own ISN. One stream</span><br><span class="hljs-comment">//! runs from the local TCPSender to the remote TCPReceiver and has one ISN,</span><br><span class="hljs-comment">//! and the other stream runs from the remote TCPSender to the local TCPReceiver and</span><br><span class="hljs-comment">//! has a different ISN.</span><br><span class="hljs-function"><span class="hljs-keyword">uint64_t</span> <span class="hljs-title">unwrap</span><span class="hljs-params">(WrappingInt32 n, WrappingInt32 isn, <span class="hljs-keyword">uint64_t</span> checkpoint)</span> </span>&#123;<br>    <span class="hljs-built_in">DUMMY_CODE</span>(n, isn, checkpoint);<br>    <span class="hljs-keyword">uint64_t</span> temp=n.<span class="hljs-built_in">raw_value</span>()-isn.<span class="hljs-built_in">raw_value</span>();<br>    <span class="hljs-keyword">if</span>(checkpoint==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br>    <span class="hljs-keyword">uint32_t</span> div=checkpoint/(<span class="hljs-number">1ul</span>&lt;&lt;<span class="hljs-number">32</span>);<br>    <span class="hljs-keyword">uint32_t</span> res=checkpoint%(<span class="hljs-number">1ul</span>&lt;&lt;<span class="hljs-number">32</span>);<br>    <span class="hljs-keyword">if</span> (res&lt;=temp) &#123;<br>        temp=(checkpoint-temp-(div<span class="hljs-number">-1</span>)*(<span class="hljs-number">1ul</span>&lt;&lt;<span class="hljs-number">32</span>))&lt;(temp+div*(<span class="hljs-number">1ul</span>&lt;&lt;<span class="hljs-number">32</span>)-checkpoint)?temp+(div<span class="hljs-number">-1</span>)*(<span class="hljs-number">1ul</span>&lt;&lt;<span class="hljs-number">32</span>):temp+div*(<span class="hljs-number">1ul</span>&lt;&lt;<span class="hljs-number">32</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        temp=(checkpoint-temp-div*(<span class="hljs-number">1ul</span>&lt;&lt;<span class="hljs-number">32</span>))&lt;(temp+(div+<span class="hljs-number">1</span>)*(<span class="hljs-number">1ul</span>&lt;&lt;<span class="hljs-number">32</span>)-checkpoint)?temp+div*(<span class="hljs-number">1ul</span>&lt;&lt;<span class="hljs-number">32</span>):temp+(div+<span class="hljs-number">1</span>)*(<span class="hljs-number">1ul</span>&lt;&lt;<span class="hljs-number">32</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>wrapping_integers.hh</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> SPONGE_LIBSPONGE_WRAPPING_INTEGERS_HH</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SPONGE_LIBSPONGE_WRAPPING_INTEGERS_HH</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdint&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ostream&gt;</span></span><br><br><span class="hljs-comment">//! \brief A 32-bit integer, expressed relative to an arbitrary initial sequence number (ISN)</span><br><span class="hljs-comment">//! \note This is used to express TCP sequence numbers (seqno) and acknowledgment numbers (ackno)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WrappingInt32</span> &#123;</span><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//原始32位储存整数</span><br>    <span class="hljs-keyword">uint32_t</span> _raw_value;  <span class="hljs-comment">//!&lt; The raw 32-bit stored integer</span><br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//! Construct from a raw 32-bit unsigned integer</span><br>    <span class="hljs-comment">//显式构造</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">WrappingInt32</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> raw_value)</span> : _raw_value(raw_value) &#123;</span>&#125;<br>    <span class="hljs-comment">//访问原始存储值</span><br>    <span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">raw_value</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _raw_value; &#125;  <span class="hljs-comment">//!&lt; Access raw stored value</span><br>&#125;;<br><br><span class="hljs-comment">//! Transform a 64-bit absolute sequence number (zero-indexed) into a 32-bit relative sequence number</span><br><span class="hljs-comment">//! \param n the absolute sequence number</span><br><span class="hljs-comment">//! \param isn the initial sequence number</span><br><span class="hljs-comment">//! \returns the relative sequence number</span><br><span class="hljs-function">WrappingInt32 <span class="hljs-title">wrap</span><span class="hljs-params">(<span class="hljs-keyword">uint64_t</span> n, WrappingInt32 isn)</span></span>;<br><br><span class="hljs-comment">//! Transform a 32-bit relative sequence number into a 64-bit absolute sequence number (zero-indexed)</span><br><span class="hljs-comment">//! \param n The relative sequence number</span><br><span class="hljs-comment">//! \param isn The initial sequence number</span><br><span class="hljs-comment">//! \param checkpoint A recent absolute sequence number</span><br><span class="hljs-comment">//! \returns the absolute sequence number that wraps to `n` and is closest to `checkpoint`</span><br><span class="hljs-comment">//!</span><br><span class="hljs-comment">//! \note Each of the two streams of the TCP connection has its own ISN. One stream</span><br><span class="hljs-comment">//! runs from the local TCPSender to the remote TCPReceiver and has one ISN,</span><br><span class="hljs-comment">//! and the other stream runs from the remote TCPSender to the local TCPReceiver and</span><br><span class="hljs-comment">//! has a different ISN.</span><br><span class="hljs-function"><span class="hljs-keyword">uint64_t</span> <span class="hljs-title">unwrap</span><span class="hljs-params">(WrappingInt32 n, WrappingInt32 isn, <span class="hljs-keyword">uint64_t</span> checkpoint)</span></span>;<br><br><span class="hljs-comment">//! \name Helper functions</span><br><span class="hljs-comment">//!@&#123;</span><br><br><span class="hljs-comment">//! \brief The offset of `a` relative to `b`</span><br><span class="hljs-comment">//! \param b the starting point</span><br><span class="hljs-comment">//! \param a the ending point</span><br><span class="hljs-comment">//! \returns the number of increments needed to get from `b` to `a`,</span><br><span class="hljs-comment">//! negative if the number of decrements needed is less than or equal to</span><br><span class="hljs-comment">//! the number of increments</span><br><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int32_t</span> <span class="hljs-keyword">operator</span>-(WrappingInt32 a, WrappingInt32 b) &#123; <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">raw_value</span>() - b.<span class="hljs-built_in">raw_value</span>(); &#125;<br><br><span class="hljs-comment">//! \brief Whether the two integers are equal.</span><br><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(WrappingInt32 a, WrappingInt32 b) &#123; <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">raw_value</span>() == b.<span class="hljs-built_in">raw_value</span>(); &#125;<br><br><span class="hljs-comment">//! \brief Whether the two integers are not equal.</span><br><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(WrappingInt32 a, WrappingInt32 b) &#123; <span class="hljs-keyword">return</span> !(a == b); &#125;<br><br><span class="hljs-comment">//! \brief Serializes the wrapping integer, `a`.</span><br><span class="hljs-keyword">inline</span> std::ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp;os, WrappingInt32 a) &#123; <span class="hljs-keyword">return</span> os &lt;&lt; a.<span class="hljs-built_in">raw_value</span>(); &#125;<br><br><span class="hljs-comment">//! \brief The point `b` steps past `a`.</span><br><span class="hljs-keyword">inline</span> WrappingInt32 <span class="hljs-keyword">operator</span>+(WrappingInt32 a, <span class="hljs-keyword">uint32_t</span> b) &#123; <span class="hljs-keyword">return</span> WrappingInt32&#123;a.<span class="hljs-built_in">raw_value</span>() + b&#125;; &#125;<br><br><span class="hljs-comment">//! \brief The point `b` steps before `a`.</span><br><span class="hljs-keyword">inline</span> WrappingInt32 <span class="hljs-keyword">operator</span>-(WrappingInt32 a, <span class="hljs-keyword">uint32_t</span> b) &#123; <span class="hljs-keyword">return</span> a + -b; &#125;<br><span class="hljs-comment">//!@&#125;</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// SPONGE_LIBSPONGE_WRAPPING_INTEGERS_HH</span></span><br></code></pre></td></tr></table></figure><p><code>tcp_receiver.cc</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;tcp_receiver.hh&quot;</span></span><br><br><span class="hljs-comment">// Dummy implementation of a TCP receiver</span><br><br><span class="hljs-comment">// For Lab 2, please replace with a real implementation that passes the</span><br><span class="hljs-comment">// automated checks run by `make check_lab2`.</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Targs&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DUMMY_CODE</span><span class="hljs-params">(Targs &amp;&amp;... <span class="hljs-comment">/* unused */</span>)</span> </span>&#123;&#125;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TCPReceiver::segment_received</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCPSegment &amp;seg)</span> </span>&#123;<br>    <span class="hljs-built_in">DUMMY_CODE</span>(seg);<br>    <span class="hljs-comment">//代表第一个传过来的seg</span><br>    <span class="hljs-keyword">if</span>(seg.<span class="hljs-built_in">header</span>().syn)&#123;<br>        syn_flag= <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//窗口的左端</span><br>        ISN=seg.<span class="hljs-built_in">header</span>().seqno;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!syn_flag)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">uint64_t</span> received_lens=_reassembler.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">bytes_written</span>();<br>    <span class="hljs-keyword">size_t</span> index= <span class="hljs-built_in">unwrap</span>(seg.<span class="hljs-built_in">header</span>().seqno,ISN,received_lens);<br>    <span class="hljs-keyword">if</span>(!seg.<span class="hljs-built_in">header</span>().syn)&#123;<br>        index--;<br>    &#125;<br>    _reassembler.<span class="hljs-built_in">push_substring</span>(seg.<span class="hljs-built_in">payload</span>().<span class="hljs-built_in">copy</span>(),index,seg.<span class="hljs-built_in">header</span>().fin);<br><br>&#125;<br><br><span class="hljs-function">optional&lt;WrappingInt32&gt; <span class="hljs-title">TCPReceiver::ackno</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!syn_flag)&#123;<br>        <span class="hljs-keyword">return</span> std::nullopt;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(_reassembler.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">input_ended</span>())&#123;<br>            <span class="hljs-keyword">return</span> ISN+_reassembler.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">bytes_written</span>()+<span class="hljs-number">2</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> ISN+_reassembler.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">bytes_written</span>()+<span class="hljs-number">1</span>;<span class="hljs-comment">//返回当前接收窗口的初始序号</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">TCPReceiver::window_size</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> _capacity-_reassembler.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">bytes_written</span>()+_reassembler.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">bytes_read</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">TCPReceiver::recv_fin</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(_reassembler.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">input_ended</span>())&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p><code>tcp_receiver.hh</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> SPONGE_LIBSPONGE_TCP_RECEIVER_HH</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SPONGE_LIBSPONGE_TCP_RECEIVER_HH</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;byte_stream.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;stream_reassembler.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;tcp_segment.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;wrapping_integers.hh&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;optional&gt;</span></span><br><br><span class="hljs-comment">//! \brief The &quot;receiver&quot; part of a TCP implementation.</span><br><br><span class="hljs-comment">//! Receives and reassembles segments into a ByteStream, and computes</span><br><span class="hljs-comment">//! the acknowledgment number and window size to advertise back to the</span><br><span class="hljs-comment">//! remote TCPSender.</span><br><span class="hljs-comment">//接收重组segments为 ByteStream，并计算确认号和窗口大小以通告回远程 TCPSender。</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TCPReceiver</span> &#123;</span><br>    <span class="hljs-comment">//! Our data structure for re-assembling bytes.</span><br>    <span class="hljs-comment">//我们用于重新组装字节的数据结构。</span><br>    StreamReassembler _reassembler;<br><br>    <span class="hljs-comment">//! The maximum number of bytes we&#x27;ll store.</span><br>    <span class="hljs-comment">//容量大小</span><br>    <span class="hljs-keyword">size_t</span> _capacity;<br>    WrappingInt32 ISN;<br>    <span class="hljs-keyword">bool</span> syn_flag;<br>  <span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">//! \brief Construct a TCP receiver</span><br>    <span class="hljs-comment">//!</span><br>    <span class="hljs-comment">//! \param capacity the maximum number of bytes that the receiver will</span><br>    <span class="hljs-comment">//!                 store in its buffers at any give time.</span><br>    <span class="hljs-comment">//构造函数，构造一个 TCP 接收器，容量接收器在任何给定时间将存储在其缓冲区中的最大字节数。</span><br>    <span class="hljs-built_in">TCPReceiver</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> capacity) : _reassembler(capacity), _capacity(capacity),<span class="hljs-built_in">ISN</span>(<span class="hljs-number">0</span>) ,<span class="hljs-built_in">syn_flag</span>(<span class="hljs-number">0</span>)&#123;&#125;<br><br>    <span class="hljs-comment">//! \name Accessors to provide feedback to the remote TCPSender</span><br>    <span class="hljs-comment">//!@&#123;</span><br><br>    <span class="hljs-comment">//! \brief The ackno that should be sent to the peer</span><br>    <span class="hljs-comment">//! \returns empty if no SYN has been received</span><br>    <span class="hljs-comment">//!</span><br>    <span class="hljs-comment">//! This is the beginning of the receiver&#x27;s window, or in other words, the sequence number</span><br>    <span class="hljs-comment">//! of the first byte in the stream that the receiver hasn&#x27;t received.</span><br>    <span class="hljs-comment">// 如果没有收到 SYN，则应发送给对等方的 ackno 为空</span><br>    <span class="hljs-comment">//这是接收器窗口的开始，否则，接收器未接收到的流中第一个字节的序列号。</span><br>    <span class="hljs-function">std::optional&lt;WrappingInt32&gt; <span class="hljs-title">ackno</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><br>    <span class="hljs-comment">//! \brief The window size that should be sent to the peer</span><br>    <span class="hljs-comment">//!</span><br>    <span class="hljs-comment">//! Operationally: the capacity minus the number of bytes that the</span><br>    <span class="hljs-comment">//! TCPReceiver is holding in its byte stream (those that have been</span><br>    <span class="hljs-comment">//! reassembled, but not consumed).</span><br>    <span class="hljs-comment">//!</span><br>    <span class="hljs-comment">//! Formally: the difference between (a) the sequence number of</span><br>    <span class="hljs-comment">//! the first byte that falls after the window (and will not be</span><br>    <span class="hljs-comment">//! accepted by the receiver) and (b) the sequence number of the</span><br>    <span class="hljs-comment">//! beginning of the window (the ackno).</span><br>    <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">window_size</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>    <span class="hljs-comment">//!@&#125;</span><br><br>    <span class="hljs-comment">//! \brief number of bytes stored but not yet reassembled</span><br>    <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">unassembled_bytes</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _reassembler.<span class="hljs-built_in">unassembled_bytes</span>(); &#125;<br><br>    <span class="hljs-comment">//! \brief handle an inbound segment</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">segment_received</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCPSegment &amp;seg)</span></span>;<br><br>    <span class="hljs-comment">//! \name &quot;Output&quot; interface for the reader</span><br>    <span class="hljs-comment">//!@&#123;</span><br>    <span class="hljs-function">ByteStream &amp;<span class="hljs-title">stream_out</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _reassembler.<span class="hljs-built_in">stream_out</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">const</span> ByteStream &amp;<span class="hljs-title">stream_out</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _reassembler.<span class="hljs-built_in">stream_out</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">recv_fin</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>    <span class="hljs-comment">//!@&#125;</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// SPONGE_LIBSPONGE_TCP_RECEIVER_HH</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>standford_cs144_lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stanford_CS144_Lab0</title>
    <link href="/2021/11/20/Stanford-CS144-Lab0/"/>
    <url>/2021/11/20/Stanford-CS144-Lab0/</url>
    
    <content type="html"><![CDATA[<p>Stanford大学的CS144 lab要求我们实现一个TCP。CS144的课程我觉得可以配合《自顶向下》来学习，它是目前最好的中文的计算机网络书籍了。《自顶向下》中采用的是五层模型，当然在CS144中介绍了四层模型和七层模型。华科的计算机网络课程是根据《自顶向下》来备课的，如果有空的话，还可以听一听华科的计网mooc。既然都写到这里了，我们在前言来聊聊计算机网络模型：</p><hr><h5 id="四层网络模型"><a href="#四层网络模型" class="headerlink" title="四层网络模型"></a>四层网络模型</h5><p>链路层：定义单个链路如何传输。</p><p>网络层：选择合适的网间路由，确保数据及时到达。常见的协议有IP协议。在internet中连接局域网和广域网是路由器。</p><p>传输层：端到端的通信，负责向两台主机之间提供数据传输服务。传输层的主要协议有传输控制协议TCP和用户数据协议UDP。</p><p>应用层：通过应用进程之间的交互来完成特定的网络作用</p><p><img src="https://img-blog.csdnimg.cn/20190323002502144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RqbDgwNjk0MzM3MQ==,size_16,color_FFFFFF,t_70" alt=""></p><h5 id="五层模型"><a href="#五层模型" class="headerlink" title="五层模型"></a>五层模型</h5><p>五层模型把四层模型的link层分为了数据层和物理层。</p><p>数据层：数据层的作用是在物理层提供比特流服务的基础上，建立相连节点之间的数据链路，通过差错控制提供数据帧在信道上无差错的传输。</p><p>物理层：实现相邻计算机节点之间的比特流的透明传输。</p><h5 id="七层模型"><a href="#七层模型" class="headerlink" title="七层模型"></a>七层模型</h5><p>表示层和会话层实际上是和应用层一起实现的。</p><p>为什么网络协议要分层呢？</p><ul><li>层层封装，易于实现和维护；</li><li>有利于协议等标准化的制定。</li></ul><p>今天在连接网络的时候发现一个很有意思的现象，我用设置了全局代理，并用v2ray连接了代理服务器，之后我用ping命令<code>ping google.com</code>，却ping不通，原来v2ray是作用于会话层，而ping是作用于网络层，所以我们即使连接了代理服务器却不能ping通google.com。</p><p>我们常用的v2ray、shadowsocks等客户端位于会话层，只能代理应用层的应用，当然我们也可以通过一些软件去实现真正的全局代理，如：SSTap、Proxifier、tun2sock2、SocksCap等。</p><hr><p><strong><em>Fetch a web page</em></strong></p><p>该部分要求使用telnet手动获取网页，具体步骤如下：</p><p>1.键入<code>telnet cs144.keithw.org http</code>得到如下响应（http可替换为80）：</p><p><img src="http://tva2.sinaimg.cn/large/007SD2TBly1gwlp6u8yfnj30dn02s0tf.jpg" alt=""></p><p>2.继续键入GET / hello HTTP / 1.1。 这告诉服务器URL的路径部分。</p><p>3.继续键入Host：<a href="https://link.zhihu.com/?target=http%3A//cs144.keithw.org">http://cs144.keithw.org</a>。这告诉服务器URL的主机部分。</p><p>4.再按一次Enter键 这告诉服务器您已经完成了HTTP请求。</p><p>实验结果如下所示：</p><p><img src="http://tva3.sinaimg.cn/large/007SD2TBly1gwlp6ucnxxj30eo08h76y.jpg" alt=""></p><p>我们知道，telnet是作用于应用层的一个应用，通常用来进行远程请求。当远程请求获取成功，我们通过<code>GET / hello HTTP / 1.1</code>获取超文本文档，这里的HTTP是超文本传输协议。这里我们再来讲讲HTTP不同版本协议的区别：</p><p>HTTP 1.0和HTTP 1.1的区别</p><ul><li><p>长连接</p><p>HTTP 1.1支持长连接和请求的流水线操作。长连接是指不在需要每次请求都重新建立一次连接，HTTP 1.0默认使用短连接，每次请求都要重新建立一次TCP连接，资源消耗较大。请求的流水线操作是指客户端在收到HTTP的响应报文之前可以先发送新的请求报文，不支持请求的流水线操作需要等到收到HTTP的响应报文后才能继续发送新的请求报文。</p></li><li><p>缓存处理</p><p>在HTTP 1.0中主要使用header中的If-Modified-Since,Expires作为缓存判断的标准，HTTP 1.1引入了Entity tag，If-Unmodified-Since, If-Match等更多可供选择的缓存头来控制缓存策略。</p></li><li><p>错误状态码</p><p>在HTTP 1.1新增了24个错误状态响应码</p></li><li><p>HOST域</p><p>在HTTP 1.0 中认为每台服务器都会绑定唯一的IP地址，所以，请求中的URL并没有传递主机名。但后来一台服务器上可能存在多个虚拟机，它们共享一个IP地址，所以HTTP 1.1中请求消息和响应消息都应该支持Host域。</p></li><li><p>带宽优化及网络连接的使用</p><p>在HTTP 1.0中会存在浪费带宽的现象，主要是因为不支持断点续传功能，客户端只是需要某个对象的一部分，服务端却将整个对象都传了过来。在HTTP 1.1中请求头引入了range头域，它支持只请求资源的某个部分，返回的状态码为206。</p></li></ul><p>HTTP 2.0的新特性</p><ul><li>新的二进制格式：HTTP 1.x的解析是基于文本，HTTP 2.0的解析采用二进制，实现方便，健壮性更好。</li><li>多路复用：每一个request对应一个id，一个连接上可以有多个request，每个连接的request可以随机混在一起，这样接收方可以根据request的id将request归属到各自不同的服务端请求里。</li><li>header压缩：在HTTP 1.x中，header携带大量信息，并且每次都需要重新发送，HTTP 2.0采用编码的方式减小了header的大小，同时通信双方各自缓存一份header fields表，避免了header的重复传输。</li><li>服务端推送：客户端在请求一个资源时，会把相关资源一起发给客户端，这样客户端就不需要再次发起请求。</li></ul><p><code>GET / hello HTTP / 1.1</code>就是我们的请求行，请求行包括请求方法，请求URL，HTTP版本协议。那么我们又不得不讲一讲请求头了，请求头包括若干个属性值，服务端据此获取客户端的信息。至于请求体，它承载多个请求参数的数据。再来说说GET和POST的区别：</p><ul><li><p>作用</p><p>GET用于获取资源，POST用于传输实体主体</p></li><li><p>参数位置</p><p>GET的参数放在URL中，POST的参数存储在实体主体中，并且GET方法提交的请求的URL中的数据做多是2048字节，POST请求没有大小限制。</p></li><li><p>安全性</p><p>GET方法因为参数放在URL中，安全性相对于POST较差一些</p></li><li><p>幂等性</p><p>GET方法是具有幂等性的，而POST方法不具有幂等性。这里幂等性指客户端连续发出多次请求，收到的结果都是一样的.</p></li></ul><p>而上述图片返回的则是响应报文。响应报文的响应行包括报文协议及版本，状态吗及状态描述。响应头也是属性值，至于响应体，则是我们请求的需要的数据。我们看到响应代码是200，我们来说说常见的状态码：</p><div class="table-container"><table><thead><tr><th style="text-align:center">状态码</th><th style="text-align:center">类别</th></tr></thead><tbody><tr><td style="text-align:center">1XX</td><td style="text-align:center">信息性状态码</td></tr><tr><td style="text-align:center">2XX</td><td style="text-align:center">成功状态码</td></tr><tr><td style="text-align:center">3XX</td><td style="text-align:center">重定向状态码</td></tr><tr><td style="text-align:center">4XX</td><td style="text-align:center">客户端错误状态码</td></tr><tr><td style="text-align:center">5XX</td><td style="text-align:center">服务端错误状态码</td></tr></tbody></table></div><p><strong><em>Writing webget</em></strong></p><p>利用TCPsocket与Host建立连接，发送请求头，达到获取网页的目的。</p><p>众所周知，请求头为</p><figure class="highlight http"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">path</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>host<br></code></pre></td></tr></table></figure><p>故write函数里面的字符输入为<code>sock.write(&quot;GET &quot; + path + &quot; HTTP/1.1\r\nHost: &quot; + host + &quot;\r\n\r\n\r\n&quot;);</code></p><p>webget.cc代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_URL</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string &amp;host, <span class="hljs-keyword">const</span> string &amp;path)</span> </span>&#123;<br>    <span class="hljs-comment">// Your code here.</span><br><br>    <span class="hljs-comment">// You will need to connect to the &quot;http&quot; service on</span><br>    <span class="hljs-comment">// the computer whose name is in the &quot;host&quot; string,</span><br>    <span class="hljs-comment">// then request the URL path given in the &quot;path&quot; string.</span><br><br>    <span class="hljs-comment">// Then you&#x27;ll need to print out everything the server sends back,</span><br>    <span class="hljs-comment">// (not just one call to read() -- everything) until you reach</span><br>    <span class="hljs-comment">// the &quot;eof&quot; (end of file).</span><br>    TCPSocket sock;<br>    sock.<span class="hljs-built_in">connect</span>(<span class="hljs-built_in">Address</span>(host, <span class="hljs-string">&quot;http&quot;</span>));<br>    sock.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;GET &quot;</span> + path + <span class="hljs-string">&quot; HTTP/1.1\r\nHost: &quot;</span> + host + <span class="hljs-string">&quot;\r\n\r\n\r\n&quot;</span>);<br>    sock.<span class="hljs-built_in">shutdown</span>(SHUT_WR);<br>    <span class="hljs-keyword">while</span>(!sock.<span class="hljs-built_in">eof</span>())<br>        std::cout &lt;&lt; sock.<span class="hljs-built_in">read</span>();<br>    sock.<span class="hljs-built_in">close</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>实验结果：</p><p><img src="http://tvax2.sinaimg.cn/large/007SD2TBly1gwlp6w4d77j30ip04lq4y.jpg" alt=""></p><p><strong><em>An in-memory reliable byte stream</em></strong></p><p>该部分要在计算机的内存中实现一个提供可靠的有序字节流的抽象。该抽象充当运输层与应用层的连接。也就是应用层从socket中读取数据的部分。其中，byte_stream的byte_read函数将byte_stream中的数据发送到应用层，byte_write函数将有序的而数据写入byte_stream。</p><p>该抽象使用deque实现。</p><p>对于write函数，我们将data中的数据写入deque,返回累计写入数据的长度，注意capasity作为内存大小，我们最多只能写入capasity个数据。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">ByteStream::write</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string &amp;data)</span> </span>&#123;<br>    <span class="hljs-built_in">DUMMY_CODE</span>(data);<br>    <span class="hljs-comment">//取其中的较小值，data的长度，bytestream的容量和deque长度的差,保证其不超过bytestream容量</span><br>    <span class="hljs-keyword">size_t</span> lens_byte = std::<span class="hljs-built_in">min</span>(data.<span class="hljs-built_in">size</span>(),stream_capacity - byte_stream.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-comment">//在deque的末尾插入data的数据</span><br>    byte_stream.<span class="hljs-built_in">insert</span>(byte_stream.<span class="hljs-built_in">end</span>(),data.<span class="hljs-built_in">begin</span>(),data.<span class="hljs-built_in">begin</span>()+lens_byte);<br>    <span class="hljs-comment">//写入的长度增加</span><br>    byte_written+=lens_byte;<br>    <span class="hljs-keyword">return</span> lens_byte;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于read函数，我们只需要弹出len个数据，注意是len和deque.size()的较小值。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::string <span class="hljs-title">ByteStream::read</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> len)</span> </span>&#123;<br>    <span class="hljs-built_in">DUMMY_CODE</span>(len);<br>    <span class="hljs-comment">//找到要read的长度byte_stream长度的较小值，尽可能地读</span><br>    <span class="hljs-keyword">size_t</span> lens_byte = std::<span class="hljs-built_in">min</span>(len,byte_stream.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-comment">//读取数据</span><br>    <span class="hljs-function">std::string <span class="hljs-title">n</span><span class="hljs-params">(byte_stream.begin(),byte_stream.begin()+lens_byte)</span></span>;<br>    <span class="hljs-comment">//将读取后的数据弹出</span><br>    <span class="hljs-built_in">pop_output</span>(len);<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure><p>byte_stream.hh代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> SPONGE_LIBSPONGE_BYTE_STREAM_HH</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SPONGE_LIBSPONGE_BYTE_STREAM_HH</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-comment">//! \brief An in-order byte stream.</span><br><br><span class="hljs-comment">//! Bytes are written on the &quot;input&quot; side and read from the &quot;output&quot;</span><br><span class="hljs-comment">//! side.  The byte stream is finite: the writer can end the input,</span><br><span class="hljs-comment">//! and then no more bytes can be written.</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteStream</span> &#123;</span><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// Your code here -- add private members as necessary.</span><br>    <span class="hljs-keyword">size_t</span> stream_capacity;<span class="hljs-comment">//容量大小</span><br>    <span class="hljs-keyword">size_t</span> byte_written;<span class="hljs-comment">//写入</span><br>    <span class="hljs-keyword">size_t</span> byte_read;<span class="hljs-comment">//读取</span><br>    std::deque&lt;<span class="hljs-keyword">char</span>&gt; byte_stream;<span class="hljs-comment">//快速插入和删除</span><br>    <span class="hljs-keyword">bool</span> _end;<span class="hljs-comment">//结束标志</span><br>    <span class="hljs-comment">// Hint: This doesn&#x27;t need to be a sophisticated data structure at</span><br>    <span class="hljs-comment">// all, but if any of your tests are taking longer than a second,</span><br>    <span class="hljs-comment">// that&#x27;s a sign that you probably want to keep exploring</span><br>    <span class="hljs-comment">// different approaches.</span><br><br>    <span class="hljs-keyword">bool</span> _error&#123;&#125;;  <span class="hljs-comment">//!&lt; Flag indicating that the stream suffered an error.</span><br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//! Construct a stream with room for `capacity` bytes.</span><br>    <span class="hljs-comment">//构造函数，构造一个带有容量字节空间的流。</span><br>    <span class="hljs-built_in">ByteStream</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> capacity);<br><br>    <span class="hljs-comment">//! \name &quot;Input&quot; interface for the writer</span><br>    <span class="hljs-comment">//!@&#123;</span><br><br>    <span class="hljs-comment">//! Write a string of bytes into the stream. Write as many</span><br>    <span class="hljs-comment">//! as will fit, and return how many were written.</span><br>    <span class="hljs-comment">//! \returns the number of bytes accepted into the stream</span><br>    <span class="hljs-comment">//写入字节，返回字节的数量</span><br>    <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string &amp;data)</span></span>;<br><br>    <span class="hljs-comment">//! \returns the number of additional bytes that the stream has space for</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">remaining_capacity</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><br>    <span class="hljs-comment">//! Signal that the byte stream has reached its ending</span><br>    <span class="hljs-comment">//结束输入</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">end_input</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//! Indicate that the stream suffered an error.</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_error</span><span class="hljs-params">()</span> </span>&#123; _error = <span class="hljs-literal">true</span>; &#125;<br>    <span class="hljs-comment">//!@&#125;</span><br><br>    <span class="hljs-comment">//! \name &quot;Output&quot; interface for the reader</span><br>    <span class="hljs-comment">//!@&#123;</span><br><br>    <span class="hljs-comment">//! Peek at next &quot;len&quot; bytes of the stream</span><br>    <span class="hljs-comment">//! \returns a string</span><br>    <span class="hljs-function">std::string <span class="hljs-title">peek_output</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> len)</span> <span class="hljs-keyword">const</span></span>;<br><br>    <span class="hljs-comment">//! Remove bytes from the buffer</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop_output</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> len)</span></span>;<br><br>    <span class="hljs-comment">//! Read (i.e., copy and then pop) the next &quot;len&quot; bytes of the stream</span><br>    <span class="hljs-comment">//! \returns a string</span><br>    <span class="hljs-function">std::string <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> len)</span></span>;<br><br>    <span class="hljs-comment">//! \returns `true` if the stream input has ended</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">input_ended</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><br>    <span class="hljs-comment">//! \returns `true` if the stream has suffered an error</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">error</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _error; &#125;<br><br>    <span class="hljs-comment">//! \returns the maximum amount that can currently be read from the stream</span><br>    <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">buffer_size</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><br>    <span class="hljs-comment">//! \returns `true` if the buffer is empty</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">buffer_empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><br>    <span class="hljs-comment">//! \returns `true` if the output has reached the ending</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">eof</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>    <span class="hljs-comment">//!@&#125;</span><br><br>    <span class="hljs-comment">//! \name General accounting</span><br>    <span class="hljs-comment">//!@&#123;</span><br><br>    <span class="hljs-comment">//! Total number of bytes written</span><br>    <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">bytes_written</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><br>    <span class="hljs-comment">//! Total number of bytes popped</span><br>    <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">bytes_read</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>    <span class="hljs-comment">//!@&#125;</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// SPONGE_LIBSPONGE_BYTE_STREAM_HH</span></span><br></code></pre></td></tr></table></figure><p>byte_stream.cc代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;byte_stream.hh&quot;</span></span><br><br><span class="hljs-comment">// Dummy implementation of a flow-controlled in-memory byte stream.</span><br><br><span class="hljs-comment">// For Lab 0, please replace with a real implementation that passes the</span><br><span class="hljs-comment">// automated checks run by `make check_lab0`.</span><br><br><span class="hljs-comment">// You will need to add private members to the class declaration in `byte_stream.hh`</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Targs&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DUMMY_CODE</span><span class="hljs-params">(Targs &amp;&amp;... <span class="hljs-comment">/* unused */</span>)</span> </span>&#123;&#125;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>ByteStream::<span class="hljs-built_in">ByteStream</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> capacity) : <span class="hljs-built_in">stream_capacity</span>(capacity),<span class="hljs-built_in">byte_written</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">byte_read</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">byte_stream</span>(<span class="hljs-number">0</span>),_end(<span class="hljs-literal">false</span>),_error(<span class="hljs-literal">false</span>)&#123;<br>    <span class="hljs-built_in">DUMMY_CODE</span>(capacity);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">ByteStream::write</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string &amp;data)</span> </span>&#123;<br>    <span class="hljs-built_in">DUMMY_CODE</span>(data);<br>    <span class="hljs-comment">//取其中的</span><br>    <span class="hljs-keyword">size_t</span> lens_byte = std::<span class="hljs-built_in">min</span>(data.<span class="hljs-built_in">size</span>(),stream_capacity - byte_stream.<span class="hljs-built_in">size</span>());<br>    byte_stream.<span class="hljs-built_in">insert</span>(byte_stream.<span class="hljs-built_in">end</span>(),data.<span class="hljs-built_in">begin</span>(),data.<span class="hljs-built_in">begin</span>()+lens_byte);<br>    byte_written+=lens_byte;<br>    <span class="hljs-keyword">return</span> lens_byte;<br>&#125;<br><br><span class="hljs-comment">//! \param[in] len bytes will be copied from the output side of the buffer</span><br><span class="hljs-function">string <span class="hljs-title">ByteStream::peek_output</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> len)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">DUMMY_CODE</span>(len);<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string</span>(byte_stream.<span class="hljs-built_in">begin</span>(),byte_stream.<span class="hljs-built_in">begin</span>()+std::<span class="hljs-built_in">min</span>(len,byte_stream.<span class="hljs-built_in">size</span>()));<br>&#125;<br><br><span class="hljs-comment">//! \param[in] len bytes will be removed from the output side of the buffer</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ByteStream::pop_output</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> len)</span> </span>&#123;<br>    <span class="hljs-built_in">DUMMY_CODE</span>(len);<br>    <span class="hljs-keyword">size_t</span> lens_byte = std::<span class="hljs-built_in">min</span>(len,byte_stream.<span class="hljs-built_in">size</span>());<br>    byte_stream.<span class="hljs-built_in">erase</span>(byte_stream.<span class="hljs-built_in">begin</span>(),byte_stream.<span class="hljs-built_in">begin</span>()+lens_byte);<br>    byte_read+=lens_byte;<br>&#125;<br><br><span class="hljs-comment">//! Read (i.e., copy and then pop) the next &quot;len&quot; bytes of the stream</span><br><span class="hljs-comment">//! \param[in] len bytes will be popped and returned</span><br><span class="hljs-comment">//! \returns a string</span><br><span class="hljs-function">std::string <span class="hljs-title">ByteStream::read</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> len)</span> </span>&#123;<br>    <span class="hljs-built_in">DUMMY_CODE</span>(len);<br>    <span class="hljs-keyword">size_t</span> lens_byte = std::<span class="hljs-built_in">min</span>(len,byte_stream.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-function">std::string <span class="hljs-title">n</span><span class="hljs-params">(byte_stream.begin(),byte_stream.begin()+lens_byte)</span></span>;<br>    <span class="hljs-built_in">pop_output</span>(len);<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ByteStream::end_input</span><span class="hljs-params">()</span> </span>&#123;_end= <span class="hljs-literal">true</span>;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ByteStream::input_ended</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _end; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">ByteStream::buffer_size</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> byte_stream.<span class="hljs-built_in">size</span>(); &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ByteStream::buffer_empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> byte_stream.<span class="hljs-built_in">empty</span>(); &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ByteStream::eof</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _end&amp;&amp;byte_stream.<span class="hljs-built_in">empty</span>(); &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">ByteStream::bytes_written</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> byte_written; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">ByteStream::bytes_read</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> byte_read; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">ByteStream::remaining_capacity</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> stream_capacity-byte_stream.<span class="hljs-built_in">size</span>(); &#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;byte_stream.hh&quot;</span></span><br><br><span class="hljs-comment">// Dummy implementation of a flow-controlled in-memory byte stream.</span><br><br><span class="hljs-comment">// For Lab 0, please replace with a real implementation that passes the</span><br><span class="hljs-comment">// automated checks run by `make check_lab0`.</span><br><br><span class="hljs-comment">// You will need to add private members to the class declaration in `byte_stream.hh`</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Targs&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DUMMY_CODE</span><span class="hljs-params">(Targs &amp;&amp;... <span class="hljs-comment">/* unused */</span>)</span> </span>&#123;&#125;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>ByteStream::<span class="hljs-built_in">ByteStream</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> capacity) : <span class="hljs-built_in">stream_capacity</span>(capacity),<span class="hljs-built_in">byte_written</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">byte_read</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">byte_stream</span>(<span class="hljs-number">0</span>),_end(<span class="hljs-literal">false</span>),_error(<span class="hljs-literal">false</span>)&#123;<br>    <span class="hljs-built_in">DUMMY_CODE</span>(capacity);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">ByteStream::write</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string &amp;data)</span> </span>&#123;<br>    <span class="hljs-built_in">DUMMY_CODE</span>(data);<br>    <span class="hljs-comment">//取其中的较小值，data的长度，bytestream的容量和deque长度的差,保证其不超过bytestream容量</span><br>    <span class="hljs-keyword">size_t</span> lens_byte = std::<span class="hljs-built_in">min</span>(data.<span class="hljs-built_in">size</span>(),stream_capacity - byte_stream.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-comment">//在deque的末尾插入data的数据</span><br>    byte_stream.<span class="hljs-built_in">insert</span>(byte_stream.<span class="hljs-built_in">end</span>(),data.<span class="hljs-built_in">begin</span>(),data.<span class="hljs-built_in">begin</span>()+lens_byte);<br>    <span class="hljs-comment">//写入的长度增加</span><br>    byte_written+=lens_byte;<br>    <span class="hljs-keyword">return</span> lens_byte;<br>&#125;<br><br><span class="hljs-comment">//! \param[in] len bytes will be copied from the output side of the buffer</span><br><span class="hljs-function">string <span class="hljs-title">ByteStream::peek_output</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> len)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">DUMMY_CODE</span>(len);<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string</span>(byte_stream.<span class="hljs-built_in">begin</span>(),byte_stream.<span class="hljs-built_in">begin</span>()+std::<span class="hljs-built_in">min</span>(len,byte_stream.<span class="hljs-built_in">size</span>()));<br>&#125;<br><br><span class="hljs-comment">//! \param[in] len bytes will be removed from the output side of the buffer</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ByteStream::pop_output</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> len)</span> </span>&#123;<br>    <span class="hljs-built_in">DUMMY_CODE</span>(len);<br>    <span class="hljs-comment">//其实在实际情况下并不需要求较小值，但是为了通过单个测试，必须要求较小值</span><br>    <span class="hljs-keyword">size_t</span> lens_byte = std::<span class="hljs-built_in">min</span>(len,byte_stream.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-comment">//删除这些数据</span><br>    byte_stream.<span class="hljs-built_in">erase</span>(byte_stream.<span class="hljs-built_in">begin</span>(),byte_stream.<span class="hljs-built_in">begin</span>()+lens_byte);<br>    <span class="hljs-comment">//已经读取的数据增加</span><br>    byte_read+=lens_byte;<br>&#125;<br><br><span class="hljs-comment">//! Read (i.e., copy and then pop) the next &quot;len&quot; bytes of the stream</span><br><span class="hljs-comment">//! \param[in] len bytes will be popped and returned</span><br><span class="hljs-comment">//! \returns a string</span><br><span class="hljs-function">std::string <span class="hljs-title">ByteStream::read</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> len)</span> </span>&#123;<br>    <span class="hljs-built_in">DUMMY_CODE</span>(len);<br>    <span class="hljs-comment">//找到要read的长度byte_stream长度的较小值，尽可能地读</span><br>    <span class="hljs-keyword">size_t</span> lens_byte = std::<span class="hljs-built_in">min</span>(len,byte_stream.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-comment">//读取数据</span><br>    <span class="hljs-function">std::string <span class="hljs-title">n</span><span class="hljs-params">(byte_stream.begin(),byte_stream.begin()+lens_byte)</span></span>;<br>    <span class="hljs-comment">//将读取后的数据弹出</span><br>    <span class="hljs-built_in">pop_output</span>(len);<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ByteStream::end_input</span><span class="hljs-params">()</span> </span>&#123;_end= <span class="hljs-literal">true</span>;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ByteStream::input_ended</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _end; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">ByteStream::buffer_size</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> byte_stream.<span class="hljs-built_in">size</span>(); &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ByteStream::buffer_empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> byte_stream.<span class="hljs-built_in">empty</span>(); &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ByteStream::eof</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _end&amp;&amp;byte_stream.<span class="hljs-built_in">empty</span>(); &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">ByteStream::bytes_written</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> byte_written; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">ByteStream::bytes_read</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> byte_read; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">ByteStream::remaining_capacity</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> stream_capacity-byte_stream.<span class="hljs-built_in">size</span>(); &#125;<br></code></pre></td></tr></table></figure><p>实验结果如下：</p><p><img src="http://tva4.sinaimg.cn/large/007SD2TBly1gwlp6wmd2kj30oc0cfn4a.jpg" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>standford_cs144_lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
